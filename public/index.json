[{"categories":["Bug"],"contents":"Bug 描述 lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项 步骤:\n 进入首页，选择地区上海，关键字输入软件测试 待搜索结果显示之后，工作经验选择为应届毕业生 所有结果出现后，取消应届的选择，不能再回退到工作经验的选项   期望结果: 取消应届选择后，回退到有工作经验的所有选项 疑问: 这是一个Bug吗？还是产品经理的一个设计? 有方便的地方，也有不方便的地方，如果测试人员不知道这个需求,你要怎么处理这个事情?  ","date":"October 7, 2019","image":null,"permalink":"/blog/bugs/lagou/","title":"lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项"},{"categories":["Performance","Java"],"contents":"以下简单介绍一下如何使用JunitPerf进行性能测试，JunitPerf是基于JUnit4的一个单元性能测试插件，对于会远程调用API测试比较合适，如果想要比较nanosecond 延迟的则需要使用JMH.\nJunitPerf 依赖声明 此例子假设使用MAVEN管理项目，所以在POM文件中添加：\n\u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.github.noconnor\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junitperf\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 构建压力测试类 假设你想衡量DemoPerfService 类中的getServiceId方法：\npublic class DemoPerfService {   public String getServiceId(String userId){   return UUID.randomUUID().toString();  } } 那么你可以构建如下的测试类：\npublic class DemoServiceTest {  @Rule  public JUnitPerfRule perfTestRule = new JUnitPerfRule();  DemoPerfService demoPerfService;  @Before  public void setupService(){  this.demoPerfService = new DemoPerfService();  }  @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  public void getServiceId_withoutTestRequirement() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  } 直接运行就可以进行压力测试,默认的测试报告可以在build/reports 目录下获取：\n以下是对于测试类的几点说明：\n   Item 定义说明 Default值或说明     @Rule 申明为JUnit 的Rule类    JUnitPerfRule JUnitPerf 测试规则类    @JunitPerfTest 声明为性能测试方法    threads 测试使用的线程数    durationMs 测试持续时间    warmUpMs 测试热身时间 热身时间的测试数据不会计算进最后的测试结果   maxExecutionsPerSecond 方法执行的上限 RateLimiter，控制TPS上限    对自己的测试设置期望值 使用@JUnitPerfTestRequirement 可以给性能测试设置期望值，这个annotation的属性有:\n   属性 定义     percentits 设置例如90%/95%/50% 响应时间的期望   executionsPerSec 期望每秒执行测试(TPS)   allowedErrorPercentage 允许错误比例   minLatency 期望最小延时，如果实际最小延时超过这个数，则失败   maxLatency 期望最大延时，如果实际最大延时超过这个，则失败   meanLatency 期望中位数延时    下面是使用了JUnitPerfTestRequirement的一个测试方法,需要和@JUnitPerfTest一起使用：\n @JUnitPerfTest 定义了压测的运行参数 @JUnitPerfTestRequirement定义了压测的期望值  具体代码如下例:\n @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  @JUnitPerfTestRequirement(percentiles = \u0026#34;90:7,95:7,98:7,99:8\u0026#34;, executionsPerSec = 10_000, allowedErrorPercentage = 0.10f)  public void getServiceId() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  } 运行之后，如果发现没有满足JUnitPerfTestRequirement定义，则报错:\njava.lang.AssertionError: Test throughput threshold not achieved Expected: is \u0026lt;true\u0026gt;  but: was \u0026lt;false\u0026gt; Expected :is \u0026lt;true\u0026gt; 是不是很简单！\n设置测试报告地址 JUnitPerf 有不同的测试报告，个人觉得HTML的测试报告比较实用，具体只需要:\n@Rule public JUnitPerfRule perfTestRule = new JUnitPerfRule(new HtmlReportGenerator(\u0026#34;perf/report.html\u0026#34;)); 完整的例子 public class DemoServiceTest {  @Rule // public JUnitPerfRule perfTestRule = new JUnitPerfRule(new HtmlReportGenerator(\u0026#34;perf/report.html\u0026#34;));  public JUnitPerfRule perfTestRule = new JUnitPerfRule();  DemoPerfService demoPerfService;  @Before  public void setupService(){  this.demoPerfService = new DemoPerfService();  }   @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  @JUnitPerfTestRequirement(percentiles = \u0026#34;90:7,95:7,98:7,99:8\u0026#34;, executionsPerSec = 10_000, allowedErrorPercentage = 0.10f)  public void getServiceId() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  }   @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  public void getServiceId_withoutTestRequirement() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  } } 最后可以再设定的目录中查看测试报告，测试报告和默认的HTML 测试报告是一致的.\n一点问题 压力测试过程中，有时数据不能复用，举个例子来说，如果想测试完全没有访问redis缓存情况下，通过userid查询的user信息速度，那么压测的时候userid就不能复用，因为一旦访问了就会放入redis缓存而影响结果，这个可以通过使用其他的方法解决，比如曾今使用过BlockingQueue的方法进行过尝试，具体方法如下：\n 读取所有userid的文件 把userid放到一个BlockingQueue中 压测时获取userid通过BlockingQueue去获取  这样就解决了数据不能重复的方法，具体方法可以参考如下代码:\n static BlockingQueue\u0026lt;String\u0026gt; distinctIdQueue ;  @Rule  public JUnitPerfRule perfTestRule =  new JUnitPerfRule(new HtmlReportGenerator(\u0026#34;data/report_test.html\u0026#34;));   @BeforeClass  public static void setupQueue() throws IOException {   distinctIdQueue = new LinkedBlockingQueue\u0026lt;\u0026gt;();  Files.readAllLines(  Paths.get(\u0026#34;data/userid.txt\u0026#34;)  ).parallelStream().forEach(  item-\u0026gt; {  try {  distinctIdQueue.put(item);  } catch (InterruptedException e) {  e.printStackTrace();  }  }  );   }   @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  @JUnitPerfTestRequirement(percentiles = \u0026#34;90:7,95:7,98:7,99:8\u0026#34;, executionsPerSec = 10_000, allowedErrorPercentage = 0.10f)  public void getServiceId() {  String uesrId = distinctIdQueue.take();  String result =demoPerfService.getServiceId(userId);  System.out.println(result);  Assert.assertNotNull(result);  } } ","date":"July 24, 2018","image":null,"permalink":"/blog/automation/junit-perf/","title":"使用JunitPerf进行性能测试"},{"categories":["devops"],"contents":"Ansible 介绍 Ansible可以用来帮助IT自动化，关于ansible的一点说明:\nAnsible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems. ansible-docs\nInstallation- 安装 在MAC 上面安装ansible有两种方式：\n python pip  pip install ansible  brew  brew install ansible  install in centos  sudo yum install epel-release sudo yum install ansible -y ansible playbook 的简单使用 ansible的大的框架先跳过，我们通过例子来说明ansible的使用。\n下面简单介绍一个使用ansible的例子：\n  配置hosts文件 在当前目录创建一个hosts文件：\n [jenkins]  192.168.3.50   配置ansible yml playbook文件 配置当前一个yml文件:\n- hosts: jenkins  user: root  accelerate:true  tasks:  - name: restart_nginx  shell: sh /root/auto_publish_qadoc.sh   运行命令\n ansible-playbook playbook.yml -i hosts -vv 就可以运行这些命令了,最简单的ansible就是这样上手非常容易. 不过仔细看看他的帮助文档的话，其实对于python不熟的人还是会有一定难度，不过如果写过程序的人，写过python东西的人来说，其实 过一下这个document估计也就是1天时间就可以上手干活了.\n  Ansible Basic Concept 基本概念 ansible 是一个操作机器的工具,可以通过编排不同的inventory,组合不同的命令来将日常运维的操作 变成可运行的脚本资产,同时也可以积累常用的脚本以便复用.\n下面是关于ansible的一些基础概念的脑图,总体而言ansible包括了以下几个概念：\n inventory: 定义主机,定义操作对象  Host:主机 Group：不同的主机组合成一个组，一个组下面可以有子组，于是就构成了一个树形结构   variable： 变量，主要用来定义对于操作机器时使用的可变参数  Configure hosts for ansible ssh connector  copy ssh key to different hosts  ssh-keygen ssh-copy-id remoteuser@remote.server ssh-keyscan remote.server \u0026gt;\u0026gt; ~/.ssh/known_hosts  check ssh connection  ssh remoteuser@remote.server Done.\nAnsible Ad-hoc Commands ansible 命令的pattern 如下：\nansible \u0026lt;host-pattern\u0026gt; [options] 具体查看ansible 的使用帮助是：\nansible --help ansible ad-hoc command - 检查安装环境 ansible all -m ping -u root ansible ad-hoc command - 执行命令 ansible all -a \u0026#34;/bin/sh echo hello world\u0026#34; ansible ad-hoc command - copy files ansible web -m copy -a \u0026#34;src=/etc/hosts dest=/tmp/hosts\u0026#34; ansible ad-hoc command - yum install ansible web -m yum -a \u0026#34;name=acme state=present\u0026#34; ansible ad-hoc command - add user ansible all -m user -a \u0026#34;name=foo passsword=\u0026lt;crypted password here\u0026gt;\u0026#34; ansible ad-hoc command - download git 包 ansible web -m git -a \u0026#34;repo=git://foo.example.io/repo.git dest=/src/myapp\u0026#34; ansible ad-hoc command - start service ansible web -m service -a \u0026#34;name=httpd state=started\u0026#34; ansible ad-hoc command - 并行运行 ansible web -a \u0026#34;/sbin/reboot\u0026#34; -f 10 ansible ad-hoc command - 查看全部系统信息 ansible all -m setup ansible ad-hoc command 小结 从以上的例子中我们可以看到ansible的命令一般都会使用如下几点：\n module: -m module_args: -a hosts: all/web/\u0026hellip;\u0026hellip;  以上三个组合成为了下面的一个命令：\nansible all -m service -a \u0026#34;name=httpd state=started\u0026#34; 从python的角度看,可以用伪代码的方式:\n def copy(args={}):  for kwarg, v in args.items():  print(\u0026#34;{key}={value}\u0026#34;.format(key=kwarg, value=v))   def test(args={}):  for kwarg, v in args.items():  print(\u0026#34;{key}={value}\u0026#34;.format(key=kwarg, value=v))   module_mapping = {  \u0026#34;copy\u0026#34;: copy,  \u0026#34;test\u0026#34;: test }   def ansible(module, module_args):  func = module_mapping.get(module)  parsed = module_args.split(\u0026#34; \u0026#34;)  args = {}  for module_arg in parsed:  kv = module_arg.split(\u0026#34;=\u0026#34;)  args[kv[0]] = kv[1]  func(args) if __name__ == \u0026#39;__main__\u0026#39;:  ansible(module=\u0026#39;copy\u0026#39;, module_args=\u0026#34;name=name test=test\u0026#34;) mindmap of ansible Ansible 脑图:\nAnsible modules使用介绍 写一个Ansbile Module实际上非常容易，我从看 https://github.com/SeleniumHQ/ansible-selenium.git 这个源码的方式大概可以了解Ansible的一个简单的 插件.\n下面分几个内容来看：\n 插件运行代码 插件的meta的数据  Ansible 插件代码  首先Ansible 插件的入口函数为main函数  所以先定义一个main函数，以及main函数的运行\ndef main():  pass  main()  实现main函数  主要步骤是：\n module定义，Ansible的module，定义这个AnsibleModule的argument_spec,这个里面用来声明这个插件使用的参数 module.params，ansible的输入为task的yml文件，这里面定义的内容都会传递到这个params中 然后根据不同的state的值去调用不同的任务，所有不同的任务的参数都是module，module用来传递了运行时的上下文 实现不同state对应的任务 基本上就结束了一个Ansible插件了   module = AnsibleModule(  argument_spec=dict(  role=dict(choices=[\u0026#39;standalone\u0026#39;, \u0026#39;hub\u0026#39;, \u0026#39;node\u0026#39;], default=\u0026#39;standalone\u0026#39;),  state=dict(choices=[\u0026#39;running\u0026#39;, \u0026#39;stopped\u0026#39;, \u0026#39;restarted\u0026#39;], default=\u0026#39;running\u0026#39;),  version=dict(default=\u0026#39;2.53.0\u0026#39;),  path=dict(default=\u0026#39;.\u0026#39;),  force=dict(default=False, type=\u0026#39;bool\u0026#39;),  args=dict(required=False, default=\u0026#39;\u0026#39;),  java=dict(required=False, default=\u0026#39;/usr/bin/java\u0026#39;),  logfile=dict(required=False, default=\u0026#39;./selenium.log\u0026#39;),  javaargs=dict(required=False, default=[], type=\u0026#39;list\u0026#39;),  ),   supports_check_mode=False,   mutually_exclusive=[]  )   state = module.params[\u0026#39;state\u0026#39;]  role = module.params[\u0026#39;role\u0026#39;]   if state == \u0026#39;running\u0026#39;:  (changed, pid) = start(module)  finish(module, msg=\u0026#39;%sis running\u0026#39; % role, changed=changed, pid=pid)  elif state == \u0026#39;stopped\u0026#39;:  changed = stop(module)  finish(module, msg=\u0026#39;%sis stopped\u0026#39; % role, changed=changed)  elif state == \u0026#39;restarted\u0026#39;:  (changed, pid) = restart(module)  finish(module, msg=\u0026#39;%shas restarted\u0026#39; % role, changed=changed, pid=pid) start 任务的一个例子：\ndef start(module):  \u0026#34;\u0026#34;\u0026#34; Start the Selenium standalone :param module: :return: \u0026#34;\u0026#34;\u0026#34;   _, jar_file = download(module)   changed = False  role = module.params[\u0026#39;role\u0026#39;]  if role != \u0026#39;standalone\u0026#39;:  role = \u0026#34;-role %s\u0026#34; % role  else:  role = \u0026#39;\u0026#39;   if not is_running(module): # in another implementation  changed = True  args = \u0026#39;\u0026#39;  java_args = \u0026#39;\u0026#39;  if module.params[\u0026#39;args\u0026#39;]:  for (k, v) in module.params[\u0026#39;args\u0026#39;].iteritems():  args += \u0026#39;-%s=%s\u0026#39; % (k, v)   if module.params[\u0026#39;javaargs\u0026#39;]:  for arg in module.params[\u0026#39;javaargs\u0026#39;]:  java_args += \u0026#39;-%s\u0026#39; % arg   java_executable = os.path.abspath(os.path.expandvars(module.params[\u0026#39;java\u0026#39;]))  log_file = os.path.abspath(os.path.expandvars(module.params[\u0026#39;logfile\u0026#39;]))   cmd = \u0026#34;%s%s-jar %s%s%s\u0026gt;\u0026gt; %s2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; % (java_executable,  java_args,  jar_file,  role,  args,  log_file)   os.setsid()   #print cmd  rc = os.system(cmd)   if rc != 0:  abort(module, \u0026#39;Running the %srole returned code %s!\u0026#39; % (role, rc))   pid = get_pid(module)  if pid:  return changed, pid  else:  abort(module, \u0026#39;Couldnt fetch the pid of the running %s! It may have ended abruptly.\u0026#39; % module.params[\u0026#39;role\u0026#39;]) Meta 插件的meta的数据 meta信息一般存放在meta目录中，具体写的方式参考源码:\n https://github.com/SeleniumHQ/ansible-selenium.git  ","date":"March 30, 2016","image":null,"permalink":"/blog/ansible/","title":"Ansible 60分钟入门"},{"categories":["Devops"],"contents":"Jenkins 介绍 Jenkins是一个非常有用的持续集成的工具，可以通过它完成代码的build，测试，发布等一系列的事情.\nFrom Jenkins Home Page\nJenkins is an automation engine with an unparalleled plugin ecosystem to support all of your favorite tools in your delivery pipelines, whether your goal is continuous integration, automated testing, or continuous delivery. Jenkins 使用 关于Jenkins的基本使用网上有很多的教程，基本使用其事没有太多说的，它是个平台，可以集成很多不同的工具，脚本等等. 总结下来这些东西包括：\n jenkins parameter setting, string, choice, \u0026hellip;\u0026hellip; JAVA 的maven, ant, gradle 等打包工具，其他语言也有类似的build，deploy，依赖管理的工具 定制化的脚本，可以在一个Jenkins的build步骤中运行这些脚本如shell命令，python脚本 定制插件来完成自己的特殊的目的  这些内容非常庞大，自己也不可能完全都知道，如果遇到实际的一些问题需要解决的话, 大体的逻辑就是，如果遇到一些特殊需求，那么先去找插件看能不能完成，如果没有插件就再想shell，python脚本等不同的事情，或者自己开发插件.\nJenkins 的实践问题 随着Jenkins里面的任务越来越多，管理的环境越来越多，变更越来愈多，手工管理就会遇到一些问题：\n 比如为了改一个IP地址，可能需要没一个任务都去改具体的配置，比如部署同一个war到不同的测试环境，就需要给不同的job改IP 为了不同的环境配置不同的任务，需要很多的人工的配置修改等等 如果需要迁移一个多应用的测试环境，那么需要很多的复制，修改工作  那么为了解决这些问题，个人觉得可以改善的地方是：\n 定义一些类型项目的模版，抽象一些参数出来给Jenkins里面的Job做参数话，当然有时需要修改的是默认值 在定义了一些模版之后，就可以通过操作Jenkins API的方式来操作 在尝试了一些Jenkins API之后，感觉纯粹通过API的方式去操作，不一定比复制Jenkins 任务，然后修改来的快，但是通过Jenkins API的方式 来操作Jenkins 的好处是，如果这些东西融入到运维的流程中，那么它会提高生产率  一些体会是，可能代码方式的操作单个单个来看不一定会提高多少生产率(参数一样要设)，但是如果放在一个流程的角度看，那么他的效率是高的，比如你如果需要运维帮你建环境，那么你需要提供一些信息，而这些信息就可以直接建立Jenkins的Job了，那么作为用户你只提供一次信息，就可以完成你需要的所有事情，这样效率就高了.\n我对于自动化一切的看法是，也许对于单个任务来说，通过写代码的方式不一定是最优方式，但是如果放在一个流程中来看，那么一定是.所以平常可以积累点不同类型的脚本，代码，然后在某个时间点，也许连接你的这些脚本，代码，就可以流水线化一些你的工作了，不要以为这不会带来，我觉得这一天一定会有的。\nJenkins API 的使用 对于Jenkins API来说，我使用过Java和Python的，总结下来大同小异，逻辑上可以分为几个层次：\n Job: 不同类型的Job  添加，修改，删除Job Job的详细信息 可以通过Job的config.xml文件来修改配置 Job创建属于哪个父类和Jenkins的URL有关系   View 基本功能和Job类似  Jenkins API - JAVA 我自己使用的是这个Jenkins的这个API client.\n \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.offbytwo.jenkins\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jenkins-client\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;0.3.3\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; 这个包中最主要的两个类是：\n JenkinsServer: JenkinsServer 可以认为是一个JenkinsHttpClient的一个Wrapper，封装了一些常用的方法，如getJob，getJobXml等等，具体可以参考他github JenkinsHttpClient：可以通过这个HttpClient组装URL和参数来达到完成调用其他API的方法，提供的一些方法主要包括了:  post post_xml: 主要用来修改job的config.xml    大体的东西就是这些，那么通过这个Jenkins的API client，完成了一些一些功能：\n 复制Job,根据参数修改复制出来的Job 复制View，根据参数修改复制出来的View，同时包括了所有的子Job 查询到使用了某个shell 命令或者某个配置的任务  一些实例代码如下：\n复制任务：\npublic class JenkinsReplicator {  private final String COPY_FROM_VIEW_URL = \u0026#34;/view/%s/createItem?\u0026#34;;  private final String DEFAULT_VIEW = \u0026#34;All\u0026#34;;  private JenkinsInstance instance;  private JenkinsHttpClient client;   public JenkinsReplicator(JenkinsInstance instance) {  this.instance = instance;  this.client = instance.getJenkinsHttpClient();  }   /** * @param fromName: copied from issue * @param toName: new Name * @param parentName: to View name */  public void copyItem(String fromName, String toName, String parentName) {  Map\u0026lt;String, String\u0026gt; formData = new HashMap\u0026lt;\u0026gt;();  formData.put(\u0026#34;name\u0026#34;, toName);  formData.put(\u0026#34;mode\u0026#34;, \u0026#34;copy\u0026#34;);  formData.put(\u0026#34;from\u0026#34;, fromName);  formData.put(\u0026#34;json\u0026#34;, String.format(\u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;, \\\u0026#34;mode\\\u0026#34;: \\\u0026#34;copy\\\u0026#34;, \\\u0026#34;from\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;}\u0026#34;, toName, fromName));  formData.put(\u0026#34;Submit\u0026#34;, \u0026#34;OK\u0026#34;);  try {  this.client.post_form(String.format(COPY_FROM_VIEW_URL, parentName), formData, false);  } catch (IOException e) {  throw new JenkinsBaseException(\u0026#34;copy item \u0026#34;+ fromName+ \u0026#34;to \u0026#34; + toName+\u0026#34; in view \u0026#34; + parentName + \u0026#34; failed\u0026#34;, e);  }  } } update config file:\nString configXml = jobDescription.jobConfigXml(); this.getJenkins().updateJob(jobDescription.getJobName(),configXml,false); 复制整个view下面同时包括了不同的子Job:\n@Override  public View copy(String fromName, String toName, String parentNameOrNull) {  View fromView = getByName(fromName);  if (fromView == null) throw new JenkinsViewException(fromName + \u0026#34;view is not found,can\u0026#39;t copy from it!\u0026#34;);  View toView = getOrCreate(toName, fromName, parentNameOrNull);  Map\u0026lt;String, Job\u0026gt; viewJobs = jobController.getJobsByViewName(fromName);  for (Map.Entry\u0026lt;String, Job\u0026gt; entry : viewJobs.entrySet()) {  jobController.copy(entry.getKey(), toName + \u0026#34;_\u0026#34; + entry.getKey(), toView.getName());  }   return getByName(toName);  } Python API 使用 Python的Jenkins API client 可以通过以下命令安装：\n pip install jenkinsapi 基本的python jenkins api client 和JAVA的概念比较类似，不过python 的这个jenkinsapi很明显要比java的这个客户端功能要丰富的多的多，后面会详细介绍这个python client api的使用.\n代码 GITHUB\n","date":"March 30, 2016","image":null,"permalink":"/blog/automation/2016-03-30-jenkins_basic/","title":"Jenkins API的简单介绍"},{"categories":["DevTips"],"contents":"由于一直都在进行测试的工作，所以会关注Assertion的工具，发现两个不错的Assertion 第三方包，准备在实践中使用. 这两个分别是：\n Google Truth(http://google.github.io/truth/usage/) assertj  这个里面有很多自己想实现的比较的功能。一下是一些简单的试用的代码。\nGoogle Truth 基础的验证：\n@Test  public void test_basic_truth(){  Set\u0026lt;String\u0026gt; foo = Sets.newHashSet();  assertThat(foo).isEmpty();  assertThat(foo).isNotNull();  assertThat(5).isEqualTo(5L);  assertThat(5L).isEqualTo(5);  assert_().that(50).isEqualTo(50);  assertThat(\u0026#34;test\u0026#34;).isEqualTo(\u0026#34;test\u0026#34;);  assertThat(\u0026#34;test\u0026#34;).contains(\u0026#34;te\u0026#34;);  } Collections/Maps的验证:\n@Test  public void test_basic_truth_maps_collections(){  Set\u0026lt;String\u0026gt; foo = Sets.newHashSet();  assertThat(foo).isEmpty();  assertThat(foo).isNotNull();  foo.add(\u0026#34;test\u0026#34;);  foo.add(\u0026#34;test1\u0026#34;);  foo.add(\u0026#34;test2\u0026#34;);  assertThat(foo).contains(\u0026#34;test\u0026#34;);  assertThat(foo).containsAllOf(\u0026#34;test\u0026#34;, \u0026#34;test1\u0026#34;);  assertThat(foo).containsExactly(\u0026#34;test2\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;test1\u0026#34;);  assertThat(foo).containsNoneOf(\u0026#34;test889\u0026#34;, \u0026#34;test10\u0026#34;);   Map\u0026lt;String,String\u0026gt; maps = Maps.newHashMap();  maps.put(\u0026#34;test\u0026#34;, \u0026#34;test1\u0026#34;);  maps.put(\u0026#34;test1\u0026#34;, \u0026#34;test2\u0026#34;);  maps.put(\u0026#34;test2\u0026#34;, \u0026#34;test3\u0026#34;);  assertThat(maps).containsKey(\u0026#34;test1\u0026#34;);  assertThat(maps).containsEntry(\u0026#34;test1\u0026#34;, \u0026#34;test2\u0026#34;);  assertThat(maps).doesNotContainEntry(\u0026#34;test0\u0026#34;, \u0026#34;test0\u0026#34;);  } assertj 基础的验证：\n@Test  public void test_contains(){  assertThat(\u0026#34;aaa\u0026#34;).contains(\u0026#34;aa\u0026#34;);  }   @Test  public void test_list_contains(){  List\u0026lt;String\u0026gt; result = Lists.newArrayList(\u0026#34;abcd\u0026#34;,\u0026#34;ddds\u0026#34;,\u0026#34;ttest\u0026#34;);  assertThat(result).contains(\u0026#34;ddds\u0026#34;);  }  @Test  public void test_list_contains_onlyonce(){  List\u0026lt;String\u0026gt; result = Lists.newArrayList(\u0026#34;abcd\u0026#34;,\u0026#34;ddds\u0026#34;,\u0026#34;ttest\u0026#34;);  assertThat(result).containsOnlyOnce(\u0026#34;ddds\u0026#34;);  }   @Test  public void test_list_contains_ELementOf(){  List\u0026lt;String\u0026gt; result = Lists.newArrayList(\u0026#34;abcd\u0026#34;,\u0026#34;ddds\u0026#34;,\u0026#34;ttest\u0026#34;);  assertThat(result).containsExactlyElementsOf(Lists.newArrayList(\u0026#34;abcd\u0026#34;, \u0026#34;ddds\u0026#34;, \u0026#34;ttest\u0026#34;));  } Guava 的验证：\n@Test  public void MultiMap_assertions() {  Multimap\u0026lt;String, String\u0026gt; actual = ArrayListMultimap.create();  actual.putAll(\u0026#34;Lakers\u0026#34;, newArrayList(\u0026#34;Kobe Bryant\u0026#34;, \u0026#34;Magic Johnson\u0026#34;, \u0026#34;Kareem Abdul Jabbar\u0026#34;));  actual.putAll(\u0026#34;Spurs\u0026#34;, newArrayList(\u0026#34;Tony Parker\u0026#34;, \u0026#34;Tim Duncan\u0026#34;, \u0026#34;Manu Ginobili\u0026#34;));   assertThat(actual).containsKeys(\u0026#34;Lakers\u0026#34;, \u0026#34;Spurs\u0026#34;);  assertThat(actual).contains(entry(\u0026#34;Lakers\u0026#34;, \u0026#34;Kobe Bryant\u0026#34;),  entry(\u0026#34;Spurs\u0026#34;, \u0026#34;Tim Duncan\u0026#34;));  }   @Test  public void multiple_set_assertions() {  Multimap\u0026lt;String, String\u0026gt; listMultimap = ArrayListMultimap.create();  listMultimap.putAll(\u0026#34;Spurs\u0026#34;, newArrayList(\u0026#34;Tony Parker\u0026#34;, \u0026#34;Tim Duncan\u0026#34;, \u0026#34;Manu Ginobili\u0026#34;));  listMultimap.putAll(\u0026#34;Bulls\u0026#34;, newArrayList(\u0026#34;Michael Jordan\u0026#34;, \u0026#34;Scottie Pippen\u0026#34;, \u0026#34;Derrick Rose\u0026#34;));   Multimap\u0026lt;String, String\u0026gt; setMultimap = TreeMultimap.create();  setMultimap.putAll(\u0026#34;Spurs\u0026#34;, newHashSet(\u0026#34;Tony Parker\u0026#34;, \u0026#34;Tim Duncan\u0026#34;, \u0026#34;Manu Ginobili\u0026#34;));  setMultimap.putAll(\u0026#34;Bulls\u0026#34;, newHashSet(\u0026#34;Michael Jordan\u0026#34;, \u0026#34;Scottie Pippen\u0026#34;, \u0026#34;Derrick Rose\u0026#34;));  // assertion will pass as listMultimap and setMultimap have the same content  assertThat(listMultimap).hasSameEntriesAs(setMultimap);  // this assertion FAILS even though both multimaps have the same content  assertThat(listMultimap).isEqualTo(setMultimap);  }    @Test  public void range_assertions() {  Range\u0026lt;Integer\u0026gt; range = Range.closed(10, 12);  assertThat(range).isNotEmpty()  .contains(10, 11, 12)  .hasClosedLowerBound()  .hasLowerEndpointEqualTo(10)  .hasUpperEndpointEqualTo(12);  }   @Test  public void table_assertion() {  // Table assertions  Table\u0026lt;Integer, String, String\u0026gt; bestMovies = HashBasedTable.create();   bestMovies.put(1970, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;M.A.S.H\u0026#34;);  bestMovies.put(1994, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Pulp Fiction\u0026#34;);  bestMovies.put(2008, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Entre les murs\u0026#34;);  bestMovies.put(2000, \u0026#34;Best picture Oscar\u0026#34;, \u0026#34;American Beauty\u0026#34;);  bestMovies.put(2011, \u0026#34;Goldene Bär\u0026#34;, \u0026#34;A Separation\u0026#34;);   assertThat(bestMovies).hasRowCount(5).hasColumnCount(3).hasSize(5)  .containsValues(\u0026#34;American Beauty\u0026#34;, \u0026#34;A Separation\u0026#34;, \u0026#34;Pulp Fiction\u0026#34;)  .containsCell(1994, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Pulp Fiction\u0026#34;)  .containsColumns(\u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Best picture Oscar\u0026#34;, \u0026#34;Goldene Bär\u0026#34;)  .containsRows(1970, 1994, 2000, 2008, 2011);  }   @Test  public void test_opotions() {  // Optional assertions  Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Test\u0026#34;);  assertThat(optional).isPresent().contains(\u0026#34;Test\u0026#34;);   Optional\u0026lt;Long\u0026gt; optionalNum = Optional.of(12L);  assertThat(optionalNum).extractingValue()  .isInstanceOf(Long.class)  .isEqualTo(12L);   optional = Optional.of(\u0026#34;Bill\u0026#34;); // extractingCharSequence allows to chain String specific assertion  assertThat(optional).extractingCharSequence()  .startsWith(\u0026#34;Bi\u0026#34;);   } 日期的验证：\n@Test  public void date_before(){   DateTime dateTime = new DateTime();  DateTime firstDateTime = new DateTime();  firstDateTime.plus(10000L);  assertThat(dateTime).isBefore(firstDateTime);  assertThat(dateTime).isAfter(\u0026#34;2004-12-13T21:39:45.618-08:00\u0026#34;);  assertThat(dateTime).isAfter(\u0026#34;2004-12-13T21:39:00\u0026#34;);  assertThat(dateTime).isAfter(\u0026#34;2004-12-13T21:39:00\u0026#34;);   }   @Test  public void joda_datetime_compare(){   DateTime utcTime = new DateTime(2013, 6, 10, 0, 0, DateTimeZone.UTC);  DateTime cestTime = new DateTime(2013, 6, 10, 2, 0, DateTimeZone.forID(\u0026#34;Europe/Berlin\u0026#34;));   assertThat(utcTime).as(\u0026#34;in UTC time\u0026#34;).isEqualTo(cestTime);  } ","date":"February 1, 2016","image":null,"permalink":"/blog/automation/2016-02-01-assertions/","title":"assertions"},{"categories":["DevTips"],"contents":"再试用了Web 开发的框架之后，归纳一下大致的一个基础Web 开发需要的那些元素:\n URL Router，如何定义URL的访问 Request Handler/Response Handler， HTTP请求/返回的处理  如果组织这些Request Handler/Response Handler 如何定义全局/局部的URL拦截器 如何处理特殊的HTTP Header 如何处理Session/Cookie   Database Access Layer/ORM， 数据操作CRUD  如何CRUD 如何进行分页，排序，filterByCriteria\u0026hellip;..等数据库的常见操作 如何管理事务 如何定义，初始化数据库表 如何组织不同的数据库操作成不同的业务动作 详细，复杂的ORM操作可以不用太在意   Template Render,模版渲染  不同模版的试用 静态资源的访问   单元测试  断言，EXCEPTION检查 Mock 数据，内存数据库的使用   Web Application部署  不同环境的配置管理 不同语言的打包工具，如MAVEN，GRADLE 不同的构建工具,GULP 不同的服务器，NGINX，TOMCAT，JBOSS    ","date":"January 27, 2016","image":null,"permalink":"/blog/automation/2016-01-27-web-dev/","title":"WEB 开发的几个重点"},{"categories":["Thoughts"],"contents":"在做一件事情之前，问一句为什么是必要的.做自动化测试之前也是一样，不管如何总是要有一个理由的吗，哪怕是所有的人都做，我也要做这样的理由. 以下说说我觉得要做自动化的理由.\n为什么自动化(Why Automation Testing) 为什么自动化,对于测试的而言的理由 VS 实际情况\n 自动化可以减少重复的回归测试(实际中的我问题:那么回归测试在你日常的测试中比例是多少) 自动化测试可以提高自己的编码能力(这个原因无论如何是成立的) 自动化测试可以进行更快的迭代（实际中的问题：自动化测试的不稳定可能不一定起到预想的作用） 自动化测试可以做更多的回归测试内容，减少风险(实际中的问题：不稳定的测试可能不一定能够达到目的) 不同的测试环境可以运行相同的测试(实际的问题： 可能没有那么多的环境，一般情况下都有测试环境，集成环境，预发布环境，生产环境，其实不是没个公司都需要这样做的\u0026hellip;\u0026hellip;) 对于被测系统有更深刻的理解.由于需要编写代码，有时需要更深刻的理解内部的代码实现原理(实际中因人而异\u0026hellip;\u0026hellip;) 自动化测试不仅仅包括进行测试，还包括一切去提高交付产品效率质量的东西，对于测试而言提出了新要求(always true if QA really does this) 功能测试的业务知识可能在这家公司有用，到别家就没用了，但是会写代码可以积累自己(always true) 无论是性能测试和安全测试都需要代码能力，通过自动化代码的编写可以更好的了解，掌握性能测试或者安全测试(实际情况：不是没个人都对编码感兴趣的)  为什么自动化,对于公司的而言的理由 VS 实际情况\n 测试用例通过代码的方式积累下来，自动化测试可能不会立竿见影，但是他有复利的效果（实际情况：遗留的测试代码真的有用吗？） 系统如果重构那么通过自动化测试来完成很大一部分的功能测试（实际情况：遗留的测试代码真的有用吗？） 减少回归测试少测漏测风险（实际情况：遗留的测试代码真的有用吗？） 可以加速交付(交付流水线中不同的环境可以通过代码来跑，实际情况：遗留的测试代码真的有用吗？)  How to automation test  有统一的框架(框架一定要有IoC／DI的概念使用) 有扩展性的框架 方便实用，可以代码生产的工具链 安装自动化测试金字塔（单元，接口，UI）方式 千万不要使用自动化测试的anti-pattern 有规划，一步一步优化，不要贪多  ","date":"January 10, 2016","image":null,"permalink":"/blog/opinons/2016-01-10-why_how_automation/","title":"为什么自动化，如何自动化"},{"categories":["DevTips"],"contents":"HTTP Status Codes This page is created from HTTP status code information found at ietf.org and Wikipedia. Click on the category heading or the status code link to read more.\n1xx Informational  100 Continue 101 Switching Protocols 102 Processing (WebDAV)  2xx Success  200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 207 Multi-Status (WebDAV) 208 Already Reported (WebDAV) 226 IM Used  3xx Redirection  300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 306 (Unused) 307 Temporary Redirect 308 Permanent Redirect (experiemental)  4xx Client Error  401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Request Entity Too Large 414 Request-URI Too Long 415 Unsupported Media Type 416 Requested Range Not Satisfiable 417 Expectation Failed 418 I\u0026rsquo;m a teapot (RFC 2324) 420 Enhance Your Calm (Twitter) 422 Unprocessable Entity (WebDAV) 423 Locked (WebDAV) 424 Failed Dependency (WebDAV) 425 Reserved for WebDAV 426 Upgrade Required 428 Precondition Required 429 Too Many Requests 431 Request Header Fields Too Large 444 No Response (Nginx) 449 Retry With (Microsoft) 450 Blocked by Windows Parental Controls (Microsoft) 499 Client Closed Request (Nginx)  5xx Server Error  500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported 506 Variant Also Negotiates (Experimental) 507 Insufficient Storage (WebDAV) 508 Loop Detected (WebDAV) 509 Bandwidth Limit Exceeded (Apache) 510 Not Extended 511 Network Authentication Required 598 Network read timeout error 599 Network connect timeout error  ","date":"December 23, 2015","image":null,"permalink":"/blog/automation/2015-12-23-http_status_code/","title":"http status code HTTP 状态码"},{"categories":["api-testing"],"contents":"在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。\n下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：\n 如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法  如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：\n 通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试  我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:\n 发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们  总体上我自己的总结是如下图:\n接口自动化测试脚手架的构建 根据以上的分析如果自己需要实现的话，最主要需要实现一下其实就是请求的构建，请求构建包括了:\n 发起请求的客户端 请求数据的构建  对于发起请求的客户端就直接使用了Spring RestTemplate,考虑的主要原因如下:\n 使用相对比较方便,模块化比较清晰 可以使用HTTPClient的实现 Spring RestTemplate所在的包还有其他一些接口的支持，以后如果使用其他接口可以不需要换包也可以做  在实际的使用过程中，其实也遇到了一些问题，比如如下的内容:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  如何解决这些问题,在后面再详细介绍，这里说明一下使用RestTemplate的一个主要流程：\n   构建请求，设置请求的Header，URL，Accept，ContextType，Token等等    调用请求获取返回的Response， 这个ResponseRestTemplate中实际上封装了一个ResponseEntity的类，里面包括了请求状态，Body之类 RestTemplate 有个好处就是如果给RestTemplate设定了MessageConverter的话，他可以自动把请求的返回类型直接转换，比如你发起请求的时候设置了JOSN的Message Converter，他可以帮你把类，或者字符串自己转化为JSON来发送，同样如果是返回值是JSON的话，也可以帮你自己将JSON转换成你指定类型的JAVA BEAN    说完这个流程，我们就说说如何通过RestTemplate构建一个简单的HTTP请求:\n Map\u0026lt;String,String\u0026gt; urlVariable = new Map\u0026lt;String,String\u0026gt; ();  urlVariable.put(\u0026#34;q\u0026#34;,\u0026#34;test\u0026#34;);  JavaBean javaBean = restTemplate.getForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  JavaBean javaBean1 = restTemplate.postForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  ResponseEntity e = restTemplate.getForEntity(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable); 实际上使用RestTemplate还是挺简单的，不过为了让使测试更为方便一点，然后每个人的代码更统一点，自己重新封装了一下RestTemplate的使用，主要分为三个概念:\n Service 的描述 测试数据 客户端调用  接口服务描述 Service的描述实际上就是一个JSON文件，只不过自己规定了一下，格式类似于,这个文件描述了API的定义，当然API的body没有在这个里面，不过为了不把事情搞复杂，就暂时不放在这个里面.\n{ \u0026#34;apiDomainName\u0026#34;: \u0026#34;applicationName\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;application/json, text/javascript, */*\u0026#34; }, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;pathParameters\u0026#34;: [], \u0026#34;queryParameters\u0026#34;: [ \u0026#34;username\u0026#34;, ], \u0026#34;resourceURL\u0026#34;: \u0026#34;/application/subdomain\u0026#34; } 测试数据类：\n private Map\u0026lt;String, String\u0026gt; queryParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; pathParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; headers = Maps.newHashMap();  private T body; 而如何调用客户端就变成,而且其实每一个API的访问其实都可以这样子来做，\n ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call(); 说明一下的是：\n serviceDescriptionPath就是接口的描述 requestData就是需要进行测试的数据  然后实际上接口的描述是开发还没有开发好的时候就已经定了的，所以这里的变量就变成如何构建requestData了\n构建RequestData 构建requestData实际上就是设计测试用例，那么这里也是使用Excel的方式，将不同的值填写到excel里面，不过为了减少set值这样的操作，这个脚手架就提供了一些工具，可以直接将数据设置到RequestData实例，具体的操作如下:\nExcel是如下格式的：\n   变量名 测试用例1 测试用例2     data.queryParameters(username) 1 1   data.queryParameters(year) 2015 2014   data.queryParameters(month) 10 11    说明一下，通过反射的方式，可以直接生成一个requestData的实例,同时queryParameters中值已经设置好了，这样调用代码中就不需要写类似于：\n RequestData data = new RequestData();  data.queryParameters.put(\u0026#34;username\u0026#34;,\u0026#34;1\u0026#34;);  data.queryParameters.put(\u0026#34;year\u0026#34;,\u0026#34;2015\u0026#34;); 这里有兴趣的同学可以参考这个包:里面其实已经有很方便的通过反射去赋值了,\n\u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.jodd\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jodd-bean\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.6.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用TestNG的DataProvider 刚才讲述了如何发生生成数据，那么通过Excel的方式提供不同的数据，就可以通过TestNG的DataProvider了 所以测试数据通过，TestNG data provider的实现在这里就不多少了，网上其实有很多内容了.\n接口测试的代码看起来就是这个样子了 @DataProvider(name = \u0026#34;data\u0026#34;)  public Iterator\u0026lt;Object[]\u0026gt; getAPITestData(Method m) throws Exception {  Map\u0026lt;String, Class\u0026gt; clazz = new HashMap\u0026lt;String, Class\u0026gt;();  clazz.put(\u0026#34;RequestData\u0026#34;, RequestData.class);  Iterator\u0026lt;Object[]\u0026gt; y = TestData.provider(\u0026#34;testcase/api1.xls\u0026#34;, m, clazzMap);   return y;  }   @Test(dataProvider = \u0026#34;data\u0026#34;)  public void testAPITest(RequestData data) {  ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call();  Assert.assertEqual(response.getStatus,200); // response 的期望值实际可以通过dataprovider传入  } 而且几乎所有的代码都差不多成这个样子了，那么获取可以写个代码生成的东西,当然最后通过了JsonPath写了一些获取JSON值的工具，这个暂时也就不说了.\n那么代码生成吧 当封装好这些东西之后，发现所有的接口都类似了，然后就做了代码生成的工具了,代码生成器的入口实际上个就是那个服务描述文件开始的， 所以代码生成器的参数就是服务描述文件，在实际的使用的过程中，接口描述这个文件也可以自动生成，目前总共支持以下几种:\n 手动编写描述文件 抓取开发API规格网站接口的描述，自动生成描述文件 解析HAR文件自动生成描述文件，解析HAR其实不难，就是繁琐一点字段有点多  后续想打通和POSTMAN的连接，可以接收POSTMAN的导出文件，然后也可以导出POSTMANT的，以后开BUG就什么也不说，直接放一个POSTMAN文件其实也挺帅的\n至此一个接口测试的脚手架就大致完成了.总结起来就是:\n 封装了RestTemplate，让他接受一个接口的描述文件，一个请求的数据 通过Excel传数据给请求的数据进行数据驱动 相同类似的代码进行代码生成  最后其实这样子使用下来,接口构建几个简单一点的自动化测试用例，其实也就是几分钟的事情.\n一些细节 在实现过程中，实际上还有一些特殊情况，比如说需要token，认证信息，这些通过一个公用函数的方式就可以解决，然后在代码生成的时候 直接讲这个放在实际测试的接口前面调用. 后有就是上面说到的的:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  HTTPS的访问是通过如下代码解决的,创建一个略SSL的httpclient就可以了\npublic static RestTemplateClientHelper getHttpClientImplInstance(){  RestTemplateClientHelper client = new RestTemplateClientHelper();  HttpClient httpClient = getIgnoreSSLHttpClient();  client.setTemplate(new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient)));  return client;  }   /** * 获取忽略SSL的httpclient，支持https的请求 * @return */  private static HttpClient getIgnoreSSLHttpClient() {  CloseableHttpClient httpClient = null;  try {   httpClient = HttpClients.custom().  setHostnameVerifier(new AllowAllHostnameVerifier()).  setSslcontext(new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {  public boolean isTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {  return true;  }  }).build()).build();  } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {  logger.error(e);  }  return httpClient;  } 还有一个就是有时开发的接口返回类型(accept type)不能让RestTemplate处理，那么其实添加自己定义个MessageConverter就好了: 下面是一个修改阿里自己的FastJSON的MessageConverter的例子, 其实也没改什么，就是捕捉了一个异常，主要是不知道什么原因调用时候readInternal就抛出和编码格式有关系的异常，然后就捕捉了一下异常反正也就把那个问题就没有了，不过这个改法应该也是有问题的.\npublic class ModifiedFastJsonHttpMessageConverter extends AbstractHttpMessageConverter\u0026lt;Object\u0026gt; {  ........  public ModifiedFastJsonHttpMessageConverter() {  super(new MediaType(\u0026#34;application\u0026#34;, \u0026#34;json\u0026#34;, UTF8), new MediaType(\u0026#34;application\u0026#34;, \u0026#34;*+json\u0026#34;, UTF8));  this.charset = UTF8;  this.features = new SerializerFeature[0];  }   ............   protected Object readInternal(Class\u0026lt;?\u0026gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {  ByteArrayOutputStream baos = new ByteArrayOutputStream();  InputStream in = inputMessage.getBody();  byte[] buf = new byte[1024];   while(true) {  int bytes = in.read(buf);  if(bytes == -1) {  byte[] bytes1 = baos.toByteArray();  try {  return JSON.parseObject(bytes1, 0, bytes1.length, this.charset.newDecoder(), clazz);  }catch (Exception e){  return baos.toString(\u0026#34;UTF-8\u0026#34;);  }  }   if(bytes \u0026gt; 0) {  baos.write(buf, 0, bytes);  }  }  }  ........  } 后续的一些想法 后续希望在这个基础上再做点其他的一些事情:\n 增加POSTMAN的代码生成的支持 探索能不能通过API接口描述直接生成JMETER的JMX文件，可以讲基础的JMETER性能测试的基础代码也生成好 整理一下放到GITHUB上面，其实整个脚手架自己也就是几个文件而已，:) 建立一个MOCK SERVER，方便模拟一些API调用的方式 做一个简单点获取JSON中指定字段，然后传递给下一个API使用的工具  一些资源  unitest json-placeholder wiremock mockbin  ","date":"November 27, 2015","image":null,"permalink":"/blog/api-testing/2015-11-27-webservice-automation/","title":"自动化测试－接口测试"},{"categories":["Thoughts"],"contents":"在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。\n下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：\n 如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法  如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：\n 通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试  我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:\n 发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们  总体上我自己的总结是如下图:\n接口自动化测试脚手架的构建 根据以上的分析如果自己需要实现的话，最主要需要实现一下其实就是请求的构建，请求构建包括了:\n 发起请求的客户端 请求数据的构建  对于发起请求的客户端就直接使用了Spring RestTemplate,考虑的主要原因如下:\n 使用相对比较方便,模块化比较清晰 可以使用HTTPClient的实现 Spring RestTemplate所在的包还有其他一些接口的支持，以后如果使用其他接口可以不需要换包也可以做  在实际的使用过程中，其实也遇到了一些问题，比如如下的内容:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  如何解决这些问题,在后面再详细介绍，这里说明一下使用RestTemplate的一个主要流程：\n   构建请求，设置请求的Header，URL，Accept，ContextType，Token等等    调用请求获取返回的Response， 这个ResponseRestTemplate中实际上封装了一个ResponseEntity的类，里面包括了请求状态，Body之类 RestTemplate 有个好处就是如果给RestTemplate设定了MessageConverter的话，他可以自动把请求的返回类型直接转换，比如你发起请求的时候设置了JOSN的Message Converter，他可以帮你把类，或者字符串自己转化为JSON来发送，同样如果是返回值是JSON的话，也可以帮你自己将JSON转换成你指定类型的JAVA BEAN    说完这个流程，我们就说说如何通过RestTemplate构建一个简单的HTTP请求:\n Map\u0026lt;String,String\u0026gt; urlVariable = new Map\u0026lt;String,String\u0026gt; ();  urlVariable.put(\u0026#34;q\u0026#34;,\u0026#34;test\u0026#34;);  JavaBean javaBean = restTemplate.getForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  JavaBean javaBean1 = restTemplate.postForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  ResponseEntity e = restTemplate.getForEntity(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable); 实际上使用RestTemplate还是挺简单的，不过为了让使测试更为方便一点，然后每个人的代码更统一点，自己重新封装了一下RestTemplate的使用，主要分为三个概念:\n Service 的描述 测试数据 客户端调用  接口服务描述 Service的描述实际上就是一个JSON文件，只不过自己规定了一下，格式类似于,这个文件描述了API的定义，当然API的body没有在这个里面，不过为了不把事情搞复杂，就暂时不放在这个里面.\n{ \u0026#34;apiDomainName\u0026#34;: \u0026#34;applicationName\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;application/json, text/javascript, */*\u0026#34; }, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;pathParameters\u0026#34;: [], \u0026#34;queryParameters\u0026#34;: [ \u0026#34;username\u0026#34;, ], \u0026#34;resourceURL\u0026#34;: \u0026#34;/application/subdomain\u0026#34; } 测试数据类：\n private Map\u0026lt;String, String\u0026gt; queryParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; pathParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; headers = Maps.newHashMap();  private T body; 而如何调用客户端就变成,而且其实每一个API的访问其实都可以这样子来做，\n ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call(); 说明一下的是：\n serviceDescriptionPath就是接口的描述 requestData就是需要进行测试的数据  然后实际上接口的描述是开发还没有开发好的时候就已经定了的，所以这里的变量就变成如何构建requestData了\n构建RequestData 构建requestData实际上就是设计测试用例，那么这里也是使用Excel的方式，将不同的值填写到excel里面，不过为了减少set值这样的操作，这个脚手架就提供了一些工具，可以直接将数据设置到RequestData实例，具体的操作如下:\nExcel是如下格式的：\n   变量名 测试用例1 测试用例2     data.queryParameters(username) 1 1   data.queryParameters(year) 2015 2014   data.queryParameters(month) 10 11    说明一下，通过反射的方式，可以直接生成一个requestData的实例,同时queryParameters中值已经设置好了，这样调用代码中就不需要写类似于：\n RequestData data = new RequestData();  data.queryParameters.put(\u0026#34;username\u0026#34;,\u0026#34;1\u0026#34;);  data.queryParameters.put(\u0026#34;year\u0026#34;,\u0026#34;2015\u0026#34;); 这里有兴趣的同学可以参考这个包:里面其实已经有很方便的通过反射去赋值了,\n\u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.jodd\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jodd-bean\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.6.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用TestNG的DataProvider 刚才讲述了如何发生生成数据，那么通过Excel的方式提供不同的数据，就可以通过TestNG的DataProvider了 所以测试数据通过，TestNG data provider的实现在这里就不多少了，网上其实有很多内容了.\n接口测试的代码看起来就是这个样子了 @DataProvider(name = \u0026#34;data\u0026#34;)  public Iterator\u0026lt;Object[]\u0026gt; getAPITestData(Method m) throws Exception {  Map\u0026lt;String, Class\u0026gt; clazz = new HashMap\u0026lt;String, Class\u0026gt;();  clazz.put(\u0026#34;RequestData\u0026#34;, RequestData.class);  Iterator\u0026lt;Object[]\u0026gt; y = TestData.provider(\u0026#34;testcase/api1.xls\u0026#34;, m, clazzMap);   return y;  }   @Test(dataProvider = \u0026#34;data\u0026#34;)  public void testAPITest(RequestData data) {  ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call();  Assert.assertEqual(response.getStatus,200); // response 的期望值实际可以通过dataprovider传入  } 而且几乎所有的代码都差不多成这个样子了，那么获取可以写个代码生成的东西,当然最后通过了JsonPath写了一些获取JSON值的工具，这个暂时也就不说了.\n那么代码生成吧 当封装好这些东西之后，发现所有的接口都类似了，然后就做了代码生成的工具了,代码生成器的入口实际上个就是那个服务描述文件开始的， 所以代码生成器的参数就是服务描述文件，在实际的使用的过程中，接口描述这个文件也可以自动生成，目前总共支持以下几种:\n 手动编写描述文件 抓取开发API规格网站接口的描述，自动生成描述文件 解析HAR文件自动生成描述文件，解析HAR其实不难，就是繁琐一点字段有点多  后续想打通和POSTMAN的连接，可以接收POSTMAN的导出文件，然后也可以导出POSTMANT的，以后开BUG就什么也不说，直接放一个POSTMAN文件其实也挺帅的\n至此一个接口测试的脚手架就大致完成了.总结起来就是:\n 封装了RestTemplate，让他接受一个接口的描述文件，一个请求的数据 通过Excel传数据给请求的数据进行数据驱动 相同类似的代码进行代码生成  最后其实这样子使用下来,接口构建几个简单一点的自动化测试用例，其实也就是几分钟的事情.\n一些细节 在实现过程中，实际上还有一些特殊情况，比如说需要token，认证信息，这些通过一个公用函数的方式就可以解决，然后在代码生成的时候 直接讲这个放在实际测试的接口前面调用. 后有就是上面说到的的:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  HTTPS的访问是通过如下代码解决的,创建一个略SSL的httpclient就可以了\npublic static RestTemplateClientHelper getHttpClientImplInstance(){  RestTemplateClientHelper client = new RestTemplateClientHelper();  HttpClient httpClient = getIgnoreSSLHttpClient();  client.setTemplate(new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient)));  return client;  }   /** * 获取忽略SSL的httpclient，支持https的请求 * @return */  private static HttpClient getIgnoreSSLHttpClient() {  CloseableHttpClient httpClient = null;  try {   httpClient = HttpClients.custom().  setHostnameVerifier(new AllowAllHostnameVerifier()).  setSslcontext(new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {  public boolean isTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {  return true;  }  }).build()).build();  } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {  logger.error(e);  }  return httpClient;  } 还有一个就是有时开发的接口返回类型(accept type)不能让RestTemplate处理，那么其实添加自己定义个MessageConverter就好了: 下面是一个修改阿里自己的FastJSON的MessageConverter的例子, 其实也没改什么，就是捕捉了一个异常，主要是不知道什么原因调用时候readInternal就抛出和编码格式有关系的异常，然后就捕捉了一下异常反正也就把那个问题就没有了，不过这个改法应该也是有问题的.\npublic class ModifiedFastJsonHttpMessageConverter extends AbstractHttpMessageConverter\u0026lt;Object\u0026gt; {  ........  public ModifiedFastJsonHttpMessageConverter() {  super(new MediaType(\u0026#34;application\u0026#34;, \u0026#34;json\u0026#34;, UTF8), new MediaType(\u0026#34;application\u0026#34;, \u0026#34;*+json\u0026#34;, UTF8));  this.charset = UTF8;  this.features = new SerializerFeature[0];  }   ............   protected Object readInternal(Class\u0026lt;?\u0026gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {  ByteArrayOutputStream baos = new ByteArrayOutputStream();  InputStream in = inputMessage.getBody();  byte[] buf = new byte[1024];   while(true) {  int bytes = in.read(buf);  if(bytes == -1) {  byte[] bytes1 = baos.toByteArray();  try {  return JSON.parseObject(bytes1, 0, bytes1.length, this.charset.newDecoder(), clazz);  }catch (Exception e){  return baos.toString(\u0026#34;UTF-8\u0026#34;);  }  }   if(bytes \u0026gt; 0) {  baos.write(buf, 0, bytes);  }  }  }  ........  } 后续的一些想法 后续希望在这个基础上再做点其他的一些事情:\n 增加POSTMAN的代码生成的支持 探索能不能通过API接口描述直接生成JMETER的JMX文件，可以讲基础的JMETER性能测试的基础代码也生成好 整理一下放到GITHUB上面，其实整个脚手架自己也就是几个文件而已，:) 建立一个MOCK SERVER，方便模拟一些API调用的方式 做一个简单点获取JSON中指定字段，然后传递给下一个API使用的工具  一些资源  unitest json-placeholder wiremock mockbin  ","date":"November 27, 2015","image":null,"permalink":"/blog/opinons/2015-11-27-webservice-automation/","title":"自动化测试－接口测试"},{"categories":["automation","javascript"],"contents":"自己学习Phatomjs的教程,分享之.\nQuick Start 首先phantomjs是个什么? 以下是官方网站的解释:\nPhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG. phantomjs可以用来做什么?\n HEADLESS WEBSITETESTING SCREENSHOT PAGE AUTOMATION NETWORK MONITORING \u0026hellip;\u0026hellip; depends on your imagination  这里主要来介绍一下PhantomJS的基础用法,包括了:\n 基础语法 HEADLESS WEB TESTING SCREEN Capture Network Monitoring Page Automation  安装PhantomJS请参考: http://phantomjs.org/download.html\n基础语法  Hello World  console.log(\u0026#39;Hello World!\u0026#39;); phantom.exit(); result:\nphantomjs hello_world.js Hello World!  Page Loading 一下代码是访问百度首页,计算页面加载时间并且截屏的例子:  var page = require(\u0026#39;webpage\u0026#39;).create(); var url = \u0026#39;http://www.baidu.com\u0026#39;; t = Date.now(); page.open(url, function (status) {  console.log(\u0026#34;Status:\u0026#34; + status);  if (status !== \u0026#39;success\u0026#39;) {  console.log(\u0026#39;FAIL to load the address\u0026#39;);  } else {  t = Date.now() - t;  console.log(\u0026#39;Loading \u0026#39; + url);  console.log(\u0026#39;Loading time \u0026#39; + t + \u0026#39; msec\u0026#39;);  page.render(\u0026#39;baidu.png\u0026#39;); //capture the screenshot  }   phantom.exit(); }) 运行结果：\n●✚  phantomjs pageload.js [10:43:41] Status:success Loading http://www.baidu.com Loading time 699 msec 是不是很简单，只要几行代码就可以实现了,这里主要使用了:webpage 这个模块\n Code Evaluation  通过evaluate 方法可以在当前页面运行js程序，但是也仅限于当前页面的范围\nvar page = require(\u0026#39;webpage\u0026#39;).create(); page.onConsoleMessage = function(msg) {  console.log(\u0026#39;Page title is \u0026#39; + msg); }; page.open(\u0026#34;http://www.baidu.com\u0026#34;, function(status) {  page.evaluate(function() {  console.log(document.title);  var element = document.getElementById(\u0026#39;kw\u0026#39;);  console.log(element.getAttribute(\u0026#39;name\u0026#39;));  });  phantom.exit(); }); 运行结果：\nphantomjs code_evaluation.js [10:51:55] Page title is 一张网页，要经历怎样的过程，才能抵达用户面前？ 一位新人，要经历怎样的成长，才能站在技术之巅？ 探寻这里的秘密； 体验这里的挑战； 成为这里的主人； 加入百度，加入网页搜索，你，可以影响世界。  Page title is 请将简历发送至 %c ps_recruiter@baidu.com（ 邮件标题请以“姓名-应聘XX职位-来自console”命名） color:red Page title is 职位介绍：http://dwz.cn/hr2013 Page title is 百度一下，你就知道 Page title is wd  On request and Response  通过phantomjs 监听request和response，代码：\nvar page = require(\u0026#39;webpage\u0026#39;).create(); var url=\u0026#34;http://www.baidu.com\u0026#34; page.onResourceRequested = function(request) {  console.log(\u0026#39;Request \u0026#39; + JSON.stringify(request, undefined, 4)); }; page.onResourceReceived = function(response) {  console.log(\u0026#39;Receive \u0026#39; + JSON.stringify(response, undefined, 4)); }; page.open(url,function(){  console.log(\u0026#34;success\u0026#34;);  phantom.exit() }); 运行结果：\n............... } ], \u0026#34;id\u0026#34;: 18, \u0026#34;redirectURL\u0026#34;: null, \u0026#34;stage\u0026#34;: \u0026#34;end\u0026#34;, \u0026#34;status\u0026#34;: 200, \u0026#34;statusText\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2015-10-24T04:05:39.086Z\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=\u0026amp;json=1\u0026amp;p=3\u0026amp;sid=17521_1455_17619_13245_17640_17001_17470_17072_15640_11634_17051\u0026amp;req=2\u0026amp;csor=0\u0026amp;cb=jQuery110209065551124513149_1445659538702\u0026amp;_=1445659538703\u0026#34; } success HEADLESS WEB TESTING please refer here:http://phantomjs.org/headless-testing.html\nSCREENSHOT screen capture is quite simple,just use:\nvar page = require(\u0026#39;webpage\u0026#39;).create(); var url = \u0026#39;http://www.baidu.com\u0026#39;; t = Date.now(); page.open(url, function (status) {  console.log(\u0026#34;Status:\u0026#34; + status);  if (status !== \u0026#39;success\u0026#39;) {  console.log(\u0026#39;FAIL to load the address\u0026#39;);  } else {  t = Date.now() - t;  console.log(\u0026#39;Loading \u0026#39; + url);  console.log(\u0026#39;Loading time \u0026#39; + t + \u0026#39; msec\u0026#39;);  page.render(\u0026#39;baidu.png\u0026#39;); //capture the screenshot  }   phantom.exit(); }) also actual use page.render('baidu.pdf') to generate a PDF file\npage-automation 操作\nvar page = require(\u0026#39;webpage\u0026#39;).create(); var url =\u0026#34;http://www.baidu.com\u0026#34;; var cdn_url= \u0026#39;http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js\u0026#39;;  page.open(url, function() {  page.includeJs(cdn_url, function() {  page.evaluate(function() {   $(\u0026#34;button\u0026#34;).click();  });  phantom.exit()  });  page.render(\u0026#39;baidu.png\u0026#39;); }); Related Projects 相关的项目请参考： projects\n","date":"October 24, 2015","image":null,"permalink":"/blog/automation/2015-10-24-phantomjs-usage/","title":"Phantomjs Tutorial"},{"categories":["automation","java"],"contents":"本文主要用来分析Page Factory实现的原理以及一些扩展的可能性。\nPage Factory 的例子 Selenium Page Factory Wiki\n首先解释一下这个例子：\n 使用注解描述元素定位 使用 PageFactory.initElements(driver, page);   public class GoogleSearchPage {  // The element is now looked up using the name attribute  @FindBy(how = How.NAME, using = \u0026#34;q\u0026#34;)  private WebElement searchBox;   public void searchFor(String text) {  // We continue using the element just as before  searchBox.sendKeys(text);  searchBox.submit();  }   public void searchFor(String text) {  GoogleSearchPage page＝ PageFactory.initElements(new ChromeDriver(), GoogleSearchPage.class);  } } 以上一个显而易见的好处就是减少了查找元素的代码量，比如类似于一下的代码：\n driver.findElement(By.id(\u0026#34;q\u0026#34;)) 但是只有这样的好处吗？我们先从分析Selenium Page Factory实现的原理说起\n##Page Factory 实现的原理\nPageFactory 是使用反射(Reflection)和动态代理(dynamic proxies)的方式来创建页面的每 每个元素:\n PageFactory: initElements and proxyFields  public static void initElements(FieldDecorator decorator, Object page) {  for(Class proxyIn = page.getClass(); proxyIn != Object.class; proxyIn = proxyIn.getSuperclass()) {  proxyFields(decorator, page, proxyIn);  }  }  private static void proxyFields(FieldDecorator decorator, Object page, Class\u0026lt;?\u0026gt; proxyIn) {  Field[] fields = proxyIn.getDeclaredFields();  Field[] arr$ = fields;  int len$ = fields.length;   for(int i$ = 0; i$ \u0026lt; len$; ++i$) {  Field field = arr$[i$];  Object value = decorator.decorate(page.getClass().getClassLoader(), field);  if(value != null) {  try {  field.setAccessible(true);  field.set(page, value);  } catch (IllegalAccessException var10) {  throw new RuntimeException(var10);  }  }  }  }  FieldDecorator：DefaultFieldDecorator 源码 从DefaultFieldDecorator的源码看:   实现decorate方法,WebElement 和List 都是通过proxy的方式创建的 每个Proxy的方式都有一个对应的invocationHandler处理 Selenium的源码有两个invocationHandler：  LocatingElementHandler LocatingElementListHandler    public Object decorate(ClassLoader loader, Field field) {  if(!WebElement.class.isAssignableFrom(field.getType()) \u0026amp;\u0026amp; !this.isDecoratableList(field)) {  return null;  } else {  ElementLocator locator = this.factory.createLocator(field);  return locator == null?null:(WebElement.class.isAssignableFrom(field.getType())?this.proxyForLocator(loader, locator):(List.class.isAssignableFrom(field.getType())?this.proxyForListLocator(loader, locator):null));  }  }   private boolean isDecoratableList(Field field) {  if(!List.class.isAssignableFrom(field.getType())) {  return false;  } else {  Type genericType = field.getGenericType();  if(!(genericType instanceof ParameterizedType)) {  return false;  } else {  Type listType = ((ParameterizedType)genericType).getActualTypeArguments()[0];  return !WebElement.class.equals(listType)?false:field.getAnnotation(FindBy.class) != null || field.getAnnotation(FindBys.class) != null || field.getAnnotation(FindAll.class) != null;  }  }  }   protected WebElement proxyForLocator(ClassLoader loader, ElementLocator locator) {  LocatingElementHandler handler = new LocatingElementHandler(locator);  WebElement proxy = (WebElement)Proxy.newProxyInstance(loader, new Class[]{WebElement.class, WrapsElement.class, Locatable.class}, handler);  return proxy;  }   protected List\u0026lt;WebElement\u0026gt; proxyForListLocator(ClassLoader loader, ElementLocator locator) {  LocatingElementListHandler handler = new LocatingElementListHandler(locator);  List proxy = (List)Proxy.newProxyInstance(loader, new Class[]{List.class}, handler);  return proxy;  } 我们再看一下LocatingElementHandler,可以看到实际在待用PageFactory创建的元素时候 都是通过这个掉用LocatingElementHandler:\npublic class LocatingElementHandler implements InvocationHandler {  private final ElementLocator locator;   public LocatingElementHandler(ElementLocator locator) {  this.locator = locator;  }   public Object invoke(Object object, Method method, Object[] objects) throws Throwable {  WebElement element;  try {  element = this.locator.findElement();  } catch (NoSuchElementException var7) {  if(\u0026#34;toString\u0026#34;.equals(method.getName())) {  return \u0026#34;Proxy element for: \u0026#34; + this.locator.toString();  }   throw var7;  }   if(\u0026#34;getWrappedElement\u0026#34;.equals(method.getName())) {  return element;  } else {  try {  return method.invoke(element, objects);  } catch (InvocationTargetException var6) {  throw var6.getCause();  }  }  } } 以上Selenium PageFactory大致的实现，从过程来看： PageFaction-\u0026gt; initElements-\u0026gt; proxyFields\nPage Factory 有什么好处 个人理解的好处:\n 可以通过修改InvocationHandler里面的处理,比如 element = this.locator.findElement(); 如果都使用wait().util的方式,这样可以使所有查找的元素更加稳定 使用了proxy的方式,在实例化WebElement的时候，实际上不管WebElement存在不存在都可以创建 而实际findElement都会延迟到真的调用这个元素时执行,这带来一个好处就是如果WebElement的实例创建后 页面DOM刷新后,需要重新查找WebElement,否则可能抛出StaleElementReferenceException,而Proxy之后每次都会自动 查找,这样就减少了代码处理 工厂的设计模式同时也带了了灵活程度,在创建页面或者页面元素的时候,可以开始添加统一的前置或者后置的处理  但是可惜的是Selenium并没有提供开发的接口来让用户定制,所以如果自己定制PageFactory模式,则需要自己去实现Selenium这 一套方法,同时加入自己特殊的实现\n","date":"September 24, 2015","image":null,"permalink":"/blog/automation/2015-09-24-page-factory/","title":"Page Factory in Selenium"},{"categories":["Automation","Java"],"contents":"如果需要定制TestNG的测试报告,可以先想一下首先需要什么的数据,其实最简单的数据就是测试用例成功失败的数据, 那么实际上TestNG提供了ITestListener的接口可以让你获取这些测试数据. 同时IReporter 接口可以让用户在调用最后自己生成测试报告.\n所以其实只要用一个类实现ITestListener,IReporter就可以了.\nITestListener,IReporter实现 一下是我一个最简单的实现, 实际上TestNG开放出来的这些监听器,主要是让你可以获取TestNG 测试容器中运行测试的数据,上下文. 关于代码里面的ITestResult, xmlSuites,suites 可以自行查找\npublic class TestNGSimpleReport implements ITestListener, IReporter {  private List\u0026lt;String\u0026gt; testPassed = Lists.newArrayList();  private List\u0026lt;String\u0026gt; testFailed = Lists.newArrayList();  private List\u0026lt;String\u0026gt; testSkipped = Lists.newArrayList();   @Override  public void generateReport(List\u0026lt;XmlSuite\u0026gt; xmlSuites, List\u0026lt;ISuite\u0026gt; suites,  String outputDirectory) {  System.out.println(\u0026#34;Passed Case: \u0026#34; + testPassed.size());  System.out.println(\u0026#34;testFailed Case: \u0026#34; + testFailed.size());  System.out.println(\u0026#34;testSkipped Case: \u0026#34; + testSkipped.size());   for (String passed : testPassed) {  System.out.println(\u0026#34;passed case:\u0026#34; + passed);  }  for (String passed : testFailed) {  System.out.println(\u0026#34;failed case:\u0026#34; + passed);  }   for (String passed : testSkipped) {  System.out.println(\u0026#34;skipped case:\u0026#34; + passed);  }   }   @Override  public void onTestStart(ITestResult result) {   }   @Override  public void onTestSuccess(ITestResult result) {  testPassed.add(result.getMethod().getMethodName());  }   @Override  public void onTestFailure(ITestResult result) {  testFailed.add(result.getMethod().getMethodName());  }   @Override  public void onTestSkipped(ITestResult result) {  testSkipped.add(result.getMethod().getMethodName());  }   @Override  public void onTestFailedButWithinSuccessPercentage(ITestResult result) {   }   @Override  public void onStart(ITestContext context) {   }   @Override  public void onFinish(ITestContext context) {   } } 编写TestNG的测试 public class TestNGTest {   @Test  public void test_pass(){  System.out.println(\u0026#34;passed_case\u0026#34;);  }   @Test  public void test_failed(){  Assert.assertTrue(false);  }   @Test  public void test_pass_2(){  System.out.println(\u0026#34;passed_case_2\u0026#34;);  } } 将监听器放入Testng.xml文件  \u0026lt;suite name=\u0026#34;SimpleReport\u0026#34;\u0026gt;  \u0026lt;listeners\u0026gt;  \u0026lt;listener class-name=\u0026#34;com.hedwig.testng.TestNGSimpleReport\u0026#34;/\u0026gt;  \u0026lt;/listeners\u0026gt;  \u0026lt;test verbose=\u0026#34;1\u0026#34; name=\u0026#34;simple test\u0026#34; \u0026gt;  \u0026lt;classes\u0026gt;  \u0026lt;class name=\u0026#34;com.hedwig.testng.TestNGTest\u0026#34;/\u0026gt;  \u0026lt;/classes\u0026gt;  \u0026lt;/test\u0026gt;   \u0026lt;/suite\u0026gt; 运行Testng.xml文件,查看结果 结果如下,是不是很简单? 如果想做的cool一点,可以将这些数据写到一个html模版,写入文件就可以了\n=============================================== SimpleReport Total tests run: 3, Failures: 1, Skips: 0 ===============================================  Passed Case: 2 testFailed Case: 1 testSkipped Case: 0 passed case:test_pass passed case:test_pass_2 failed case:test_failed ","date":"September 24, 2015","image":null,"permalink":"/blog/automation/2015-09-24-testng-simple-report/","title":"TestNG 报告定制最简单的原理"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/about/","title":"About The Author"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/contact/","title":"Let's, Talk About You"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/privacy-policy/","title":"Privacy Policy"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/search/","title":"Search Result"}]