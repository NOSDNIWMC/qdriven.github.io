<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fluent QA Blog</title><link>https://qdriven.github.io/</link><description>Recent content on Fluent QA Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 28 Apr 2022 18:19:25 +0600</lastBuildDate><atom:link href="https://qdriven.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>个人网站搭建-主题篇</title><link>https://qdriven.github.io/handson/website/1-build-personal-site-theme/</link><pubDate>Thu, 28 Apr 2022 18:19:25 +0600</pubDate><guid>https://qdriven.github.io/handson/website/1-build-personal-site-theme/</guid><description>github个人网站自建 hugo-theme icon : https://www.iconfont.cn/ 海报设计： WPS svg: https://convertio.co/ banner VSCODE： markdown past 视频制作</description></item><item><title>Android 命令Cheetsheet</title><link>https://qdriven.github.io/blog/cheetsheet/android_tips-1/</link><pubDate>Thu, 27 May 2021 21:34:04 +0000</pubDate><guid>https://qdriven.github.io/blog/cheetsheet/android_tips-1/</guid><description>Android截图命令screencap 查看帮助命令 adb shell screencap -v screencap: invalid option -- v usage: screencap [-hp] [-d display-id] [FILENAME] -h: this message -p: save the file as a png.</description></item><item><title>数据中台研究-1</title><link>https://qdriven.github.io/blog/data-platform/1-intro/</link><pubDate>Thu, 27 May 2021 21:34:04 +0000</pubDate><guid>https://qdriven.github.io/blog/data-platform/1-intro/</guid><description>关于所以中台的研究，我的第一个问题总是为什么有中台这个东西？所以对应到数据中台就是为什么有数据中台这个概念？ 他解决什么问题？和原来的不是中台的情况下有什么优势？有什么不同点？
为什么有数据中台 我自己的理解是从三方面看:
数据量和多样性的指数式增长，必然造成数据相关技术的快速迭代，以及沿用旧技术越来越难以跟上新的发展，技术能力直接会影响到企业的业务和产品能力 单独业务团队负责自身数据的技术在原有的基础上变得越来越困难，面临的选择是： 扩张自身团队，跟上技术发展 把这部分数据业务交给专门人来做，自己专注使用和自身业务而不是基础技术 公司层面，自然看到了数据能力的重要性，但是在业务团队有两种不同的选择时，个人认为为倾向选择业务团队2的选项，为什么？因为1选项自然会出现重复建设， 大数据成本还是相当高的，公司从自身出发自然会选择看起来成本有优势的选择；同时数据的关联性变得越来越重要也支持公司建立数据中台的决策 以上是我认为公司会选择数据中台的原因。 同样我相信公司也了解数据中台之后，面临的问题是沟通成本上升，但是公司一定认为自己的组织能力是有办法解决这个问题的.
数据中台做什么事情和需要的能力 数据中台分层 ODS： Operation Data Store： 数据仓库源头系统的数据表通常会原封不动的存储一份，这称为ODS层，是后续数据仓库加工数据的来源 数据仓库： DWD: Datawarehouse Detail DWB: Datawarehouse Base DWS: Data warehouse service ADS: Application Data Service DWM: Data warehouse Detail DIM: dimension ETL: Extract-Transform-Load 范式： 第一范式：字段值不可分理 第二范式：确保表的每列都和主键相关 第三范式：确保每列都和主键列直接相关，而不是间接相关 Hadoop/Spark/Flink</description></item><item><title>测试陷阱6- 测试很容易</title><link>https://qdriven.github.io/blog/qa-traps/6-testing-is-hard/</link><pubDate>Mon, 26 Apr 2021 09:25:03 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-traps/6-testing-is-hard/</guid><description>最近一段时间经常听见有人说测试就是点点点，或者带着鄙视的声调说测试就是不就是点点点吗，一般情况下我不会回应，因为我知道就算回应也很难改变外面人的看法。不回应不代表我不去思考，测试真的就是点点点吗？我只想举个例子，大家都知道股票只要低买高卖就可以挣钱，但是有几个人靠股票人生开挂了？人们总是低估了做好看得懂的事情的难度，又高估了看不懂的事情的难度。
测试真的就是点点吗？ 测试真的就是点点点吗？很明显不是，就算你看到的是点点点，其实有些要比点点点难多了，至少为什么点这个而不是那个，为什么先点这个而不是那个，为什么点过了还要去继续再点？为什么要是很多种不同的情况，每种情况又是代表什么含义呢？ 你看到的点点点的背后都是有不同逻辑的思考，而不同逻辑的思考会是一件简单的事情吗？ 只是高估了看的懂的事情，但是完全没有了解过他的背后，但是点点点真的只是表象。我自己的经验来说，测试需要的逻辑可能比写代码更多，为什么？因为测试本生有两种意图，一种是验证正确性，一种是去找到可能会造成不正确的情况来验证正确性；后一种是巨大的难度，首选你的选择面很多，其次你如何挑选异常情况，理论上异常情况是无穷多的，你为什么能确信你在大海里面捞到的东西就是你想要的？再次，选择的一些情况实际上是有些是非常难以模仿的，那么如何去模拟这些情况又变得很难，这样一来你还会觉得简单吗？
测试就是一种实验，而实验是花大量时间和人力的地方，没有实验就不会有什么好的产品. 但是有一点是需要说明的，测试不代表就是专职测试人去做，这是一个非常重要的点，也是现在很多误区的来源.
测试难度的分类和难点 这边不去总结测试有什么样的类型，这些类型如何去做，换个简单从进行测试难度的角度思考测试的工作，大致可以分为：
确定性的测试，如同大众相关的各种互联网服务，这些功能一般人都可以理解，主要是验证功能是否实现， 这些工作难度不高，但是工作量大，需要的人员多，但是每个人的工资上限低 和底层技术结合的测试，主要验证关键技术在EdgeCase上面的表现，这块要求高，测试能力代表工程能力，这块更多的是实验， 基本可以认为测试者就应该是开发者，或者比简单的开发人员更加高级的技术专家，极高的专业性 专业领域知识门槛高，领域知识一般人不懂，如化工，金融，航空等等，这些专业知识的积累绝不比通用技术难度低，极高的专业度 从领域角度我觉得大体分为三大类，那么这些从业人员的优缺点来看：
第一类，可替代性高，有上限，如果希望寻求有提升，我觉得就两个方向，一个是比其他人知道的多，在多个内容里面比其他人熟悉， 另外一个就是可以和技术结合，可以用技术手段解决确定性问题，比如通过代码能够自动化整个确定性的内容 第二类，技术性强但是问题是就业面窄，同时一般赢家通吃，刚好你做的内容是其他家强，或者被新事物淘汰，那么会遇到很大的挑战 这一类需要把原理搞的很懂，同时有一块比别人深入很多，那么在特定领域有很好的用途 第三类，大部分人忽律了专业领域的知识本质上也是技术的一种，和编程一样也是专业领域知识，这类人同时如果懂专业知识和编程，那么是高手中的高手，独当一面是自然而然的；但是大部分人是做不到的，一旦这个领域知识是一个高迭代或者非常偏门，那么和第二类一样也是面临直接淘汰 实际上从优缺点来看，大部分从事测试的人要么就是有很明显的上限，要么就是一个牛的不能再牛的人才，而在中间地带，实际上没有太多空间的.</description></item><item><title>测试陷阱5 - 测试就是找Bug</title><link>https://qdriven.github.io/blog/qa-traps/5-qa-bugs/</link><pubDate>Sun, 10 Jan 2021 20:43:24 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-traps/5-qa-bugs/</guid><description>在我工作过的公司中，大部分的开发和测试工程师对于测试工程师的定位就是找Bug的人.这个认识我觉得没有什么问题，因为确实测试功能师大部分的工作就是找Bug. 一开始我自己也从来没有怀疑过，感觉这个定义偏差不是太大，但是随着工作年限的增加，我觉得这个定位越来越不那么正确了.
为什么这样子说呢？我分两个方面来说明：
测试的目的只是保证质量吗？ 测试过程中发现的Bug到底能代表什么？ 测试的目的只是保证质量吗？ 测试的目的只是保证质量吗？我觉得说是，没有什么问题的；但是保证质量了它又是为了什么呢？为了让产品更有竞争力！ 所以测试的最根本的目的是为了产品更有竞争力！有了这一个目的，作为测试人员也许需要把眼界放的更开阔一些，需要更多平衡的思维.
从产品的角度看，质量是其中一个维度，其他还有很多维度，比如成本等等. 如果测试工程师把自己局限在找Bug的人，那么有时真的变成 只找Bug的人了，有些场景可能大家很熟悉，为了一个Bug进行了无休止的讨论，辩论，面红耳赤，但是如果仔细想想，你会发现这样讨论的目的是什么？ 想达到什么结果？这些其实是成本意识，在一场无休止的讨论之后到底有什么产出？有时产出无非就是：
是不是Bug 需不需要修复 是不是需要马上修复 这些问题其实是关于产品的问题，是不是Bug有时比起后面两个来说根本不是问题。 如果我们局限在找Bug的人的时候，有时容易为了是不是Bug争论了太多时间，而没有对两条更重要的点提出自己意见，达成任何对产品有帮助的共识进行行动，是不是有一些没有把握到重点？</description></item><item><title>测试陷阱4-跳出舒适区</title><link>https://qdriven.github.io/blog/qa-traps/4-comfortable-zone/</link><pubDate>Thu, 07 Jan 2021 11:40:11 +0200</pubDate><guid>https://qdriven.github.io/blog/qa-traps/4-comfortable-zone/</guid><description>最近几年陆陆续续也面试了不少测试的同学，好多同学也都提到了跳出舒适区的概念，好多人因为觉得需要跳出舒适区所以觉得需要换一个工作环境； 就测试而言好多同学都是觉得一直在做类似的事情，没有外部刺激，没有提高；同时又相信没有实际的项目锻炼，技能很难得到提高；甚至有些同学很明显 在自己公司做的还是不错的，升职也有，加薪也有，可是就是觉得自己在舒适区里面，觉得一定要跳出来才能很快提高。大体上套用美国总统的话就是keep me great.
因为听多了,跳出舒适区貌似是这几年很流行的词语，也能在各个媒体上能看到听到，所以我有时想想貌似挺有道理的，跳出舒适区，接受挑战；可是有时又觉得总有些不对劲，为什么要跳出舒适区呢？舒适区有什么不好呢？最终最终跳出舒适区的目的是什么呢？
跳出舒适区的最终目的是什么？ 因为年纪大了，现在习惯性的会问自己最终的目的是什么？最终想达到什么样的状态？ 对于跳出舒适区这种史诗般问题，我感觉是几乎等同于你活着为了什么这种宏大的哲学问题时，可是我跳出来的答案是难道我不是为了自己过的舒服点过日子吗？舒服点的日子不在舒适区里面过，在哪里过呢？所以我明白了我觉得不对劲的问题点在哪里了。无论你跳的动还是跳不动，最终不是应该去找到舒序区才对吗？ 至于跳出这种，不过是听上去有点叛逆，无非就是让你显得有点酷有点得瑟吗？所以问题变成了如何寻找舒适区，跳出和寻找其实还是又很大不一样的，跳出很多时候变成了非理性，变成了我非要脱离现在的环境，不管我下面的环境是什么，更重要的一点是跳出其实是没有说明目的地的，只说要跳，没说要跳哪里还是可怕的，下面是万丈深渊呢？；而寻找最大的不同就是想要一个目的地，归根到底还是会有目标的，想想你的目标是什么？难道目前的环境真的一点实现的机会都没有吗？ 我不觉得跳出舒适区不对，但是在准备跳出去，还是需要再想一次.
还有一个叫能力圈的说法 无论愿不愿意承认，大多数的情况下，跳出舒适区钱还是会起到点作用的，至少认为跳出去了，会有挣更多钱的机会,这也没什么不对。但是按照前首富巴菲特的说法投资最主要原则是能力圈原则，挣钱其实基本上认为就是投资，你投资自己，利用自己的劳动获取最可观的收益，那么很显然这个原则很重要。然而这个原则 听起来和跳出舒适区有冲突，他说如果你找到自己的能力圈了，那么就不要出去了，稳稳妥妥的挣钱就是了，你并需要什么跳出这跳出那，你找到你的优势,好好想想你在当前环境里面的优势是什么，你的能力圈的边界是哪里，稳稳妥妥的把钱挣了没什么不好，超过了你的能力圈的边界可能更多的是亏损。无论钱听上去多么庸俗，但是它确实是可以改善你生活，帮助你达到你要的目标的最好最直接的东西。
下面是一段查理·芒格说的话，我更愿意相信真的挣到钱的人，而不是相信那些看起来高大上公司(说不定明天就倒闭了)的CTO/CEO.
So, the simple takeaway here is clear.</description></item><item><title>测试陷阱3-自动化测试就是测试的技术</title><link>https://qdriven.github.io/blog/qa-traps/3-tech-is-all/</link><pubDate>Fri, 27 Nov 2020 23:49:47 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-traps/3-tech-is-all/</guid><description>随着自动化测试的风靡，测试同学们越来越觉得自动化就是全部，自动化就是自己的方向。 这些本身没有太大问题，但是如果认为自动化测试就是终极技术，那么我觉得这是一个很大的陷阱。 为什么？个人觉得大部分的测试把自动化和技术都定义的太狭小了,技术和自动化都是非常宽泛的定义,下面是我自己问自己的两个问题:
什么是自动化？测试讨论的自动化难道就是接口自动化，UI自动化测试吗？ 什么是技术？技术难道就是写代码吗？把测试用例代码化吗？ 什么是自动化？测试讨论的自动化难道就是接口自动化，UI自动化测试吗？ 为什么先问这个问题，因为很多同学一开始没有接触过自动化，后来写了一些自动化用例之后，要么觉得高人一等，要么觉得一会就觉得没意思了，原因何在？因为写过自动化测试用例之后，要么觉得我技术很厉害了，基本可以把所有问题都解决了；要么马上一个疑问是这有技术含量吗？ 大量重复的代码，差不多的验证点，没有比设计测试用例和执行用例高级到多少,然后就有一种深深的幻灭的感觉？路在何方的问题又来了.
其实什么都可以是自动化,把原来重复做的事情用代码实现是自动化的一种；把类似的事情用代码实现也是自动化的一种；把 日常工作用代码实现也是自动化；这些自动化都是在做了一次之后再用代码去实现，如果用时髦一点的时候machine learning/ai去把 没做过的事情自动实现了,也是自动化. 我甚至可以说，社会生产力的进步都是每一个自动化的结果。 如果从这个角度看的，那么自动化能做的事情太多了，自动化测试也好，测试自动化也好，你可以做的事情有很多很多，多到你无法想像，问题是你有 能力做吗？ 那些写接口自动化，web ui自动化的技能足够你去做更多的自动化吗？
自动化的目的大致就是为了不让人去做差不多的事情，减少重复劳动。用一样的方法做一样的事情是重复劳动，用不一样的方法重新再做一遍一样的事情也是重复劳动；如果目标是减少重复劳动，那么自动化测试就不能停在把测试自动化这一步，还有很多很多的事情可以做。但是坦白说，有哪些事情，我也说不出来，但是我觉得用代码再去实现一遍测试过用例，也是一种重复劳动，只是还没有能力把这件事情不重复做，但是相信一定有一些办法，有一些方面是可以解决的。</description></item><item><title>测试陷阱2-永远都在忙碌重要紧急的事情</title><link>https://qdriven.github.io/blog/qa-traps/2-things-matter/</link><pubDate>Sat, 31 Oct 2020 13:22:54 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-traps/2-things-matter/</guid><description>测试永远都很忙，忙着回归测试，忙着各种各样的测试，各种各样的交付，但是这样忙碌了3年左右之后， 你发现你在确实是进步了，进步的主要方面我想大部分就是以下几个方面:
沟通能力增强了 业务熟悉了非常多，开发测试流程熟悉了很多 处理紧急事情能力提高了很多 这已经很不错，可能有些测试同样的过了三年这些进步都没有，更多的在听指令，别人说测试就是做测试。
但是又过了三年，那些快速进步的测试，发现貌似和前面三年的进步比起来，这三年的进步幅度没有那么明显了, 以前你没有办法参与决策，现在还是一样没有办法参与决策，这三年做的事情貌似没有太多变化，可能可以带 1，2个人进行测试，做的事情和以前又本质的区别吗？于是反思自己，到底哪方面还有欠缺，造成了这几年进步不大？ 答案往往就是可能是技术方面还不够，那么就想加强技术吧。于是越来越焦虑，主要发现看了1个月一门语法，结果1个星期没有用， 都忘了；忙碌的工作让三个月一转眼就过了，回顾一下，发现貌似什么变化的没有发生？怎么办？再过三年还是和现在一样？怎么办， 一会就过30了，外面35岁的人就不要了，我怎么办？ 焦虑自然就越来越多了。
这个问题我觉得没有答案，但是我只想说，说到底，技术提高是需要资源的，而时间是一个重要的资源，如果你在最初的三年提高很快， 那么我想学习能力这个资源你是不缺的，但是所有的提高都需要你的时间资源，而你自己的时间资源管理起来了吗？你把它用到一些你认为非常重要，但是可能又不是马上要做的事情上吗？你如果这么回头一看，我相信你可能1天1个小时时间都没有花到你认为很重要的事情上面。
焦虑每个人都有，但是怎么应对，怎么解决自己的问题才是关键。
如何应对焦虑 焦虑是要克服的，往往自我要求高的人越焦虑，对于如果应对焦虑，我觉得可以从下面两个方面想：</description></item><item><title>测试陷阱1 - 放弃怀疑</title><link>https://qdriven.github.io/blog/qa-traps/1-no-doubt/</link><pubDate>Thu, 29 Oct 2020 20:43:24 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-traps/1-no-doubt/</guid><description>对于大部分的初级测试人员来说，有时放弃怀疑可能在工作中陷入一些被动，甚至让自己的生活有时也会搞得一团乱. 下面我从一个加班事件说起，看看我们如果应对一些突发的情况.
从一个加班事件说起 事情的由来是这样的,由于某种原因，一个功能只能在生产环境测试，于是测试同学自己觉得这个功能简单，就预估半天时间就可以测试完成。结果呢？由于各种配置问题，上了生产主流程都不通，然后一通检查，最后从上午一直到到晚上10点的时候发现需要的一个第三方账户权限设置错误，造成功能不同，然后在配置修改完了之后，再进行测试，结果弄到凌晨结束。从这个事情来看，完全从功能角度看，其实可能确实只要半天时间，但是这个功能又有很多依赖关系，而这些依赖关系确花了比实际测试更长的时间，而真正造成这些时间的问题确从来没有去怀疑过。于是班加了，结果其实还不太好，对外看来为什么会到最后才发现这些问题？为什么事前没有计划，为什么到最后主流程还不通？为什么从来没有人提出过这个里面可能的风险？
怀疑不等于不相信，怀疑是想确认 我事后分析了一下，有一点就是测试同学早早的放弃了怀疑，放弃怀疑了两个地方:
这些配置问题在开发过程中就会被发现？ 因为开发承诺会测试 这些功能很简单，就没有去深究这里面的依赖关系，这些总会有人去搞定的 首先我想明确的一点是，怀疑不等于不相信，这个共识是需要团队达成的. 怀疑是想对事情本身的确认，而不是对开发人员的怀疑，有了这个基本共识，我觉得测试人员就应该多提问题，多怀疑，把怀疑的点变成实际放生的事实，把要做确没有做的事情落实，这样才能减少突发情况，才可以少加点班。遗憾的事，即使发生了这样的事情，大多数的测试人员还是会轻而易举的接受这样的事实，听开发人员一解释说是运营人没有告诉他账户设置，造成了此次问题，这样就过去了，我想这样的事情以后还是会发生。因为再一次的放弃了怀疑，根据发生的事情，一定程度上是可以推导将来发生的事情的，比如很明显，这么一件事情看出来:
开发没有做任何自测，因为如果自测，那么一定可以老早就发现这个问题了 开发喜欢推卸了一定的责任，这个事情的关键点不是谁没有把账号告诉别人，而是为什么这样的事情到最后才发现 事实上做这个功能基本上没有做任何的调研，如果做了调研就一定会知道需要什么账户的，不是吗？那以后怎么做调研？ 真的只能生产了才可以测试吗？实际情况不是多申请一个第三方账户就可以在测试环境测试了吗？如果测试了不是应该老早就发现账户配置的问题了吗？就算只有一个账户，产生的测试数据可以删除吗？ 如果测试不通过事实去怀疑一些，有了怀疑又去确认一些事情，那么处在开发环节的最下游，太多的不确定性都变成自己来承担，种种压力，种种加班就会都来；到最后没有太多人会帮到你，因为到了最后一旦出了点问题，就可能变成了大问题，就可能被老板追责了。</description></item><item><title>QE-Meetup： TDD 小结</title><link>https://qdriven.github.io/blog/qa-thoughts/1-tdd-way/</link><pubDate>Wed, 07 Oct 2020 11:40:11 +0200</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/1-tdd-way/</guid><description> 以下是关于TDD的小结，我个人的感受是：
如果这个实践做的事情只是想知道那些接口出现了变动，那么可能通过代码review或者沟通是更好的方式，为了得到这个目的感觉要做的事情有点多 技术自然是很厉害，但是团队是不是沟通上面出现问题了？难道都不愿意到连改了什么，影响什么都不想说了</description></item><item><title>放养式开发管理</title><link>https://qdriven.github.io/blog/qa-thoughts/3-let-it-be/</link><pubDate>Tue, 11 Aug 2020 08:58:55 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/3-let-it-be/</guid><description>或许是在充满巨大不确定性的情况下，或许是在敏捷开发的情况下，放养开发管理变得越来越多.陆陆续续经历了一些公司，项目，发现几乎是一个共性.
我相信放养式开发管理是个中性词，没有好和坏，更多的是适合不适合. 一个词在不同的环境下，反应的情况是不一样的。
放养式开发管理 - 一个成功的例子 如果在一个开发个人能力突出，严谨，负责，功能能力强的团队，放养式开发管理可以介绍很多不太需要的沟通成本，大家相互信任，对于共同的期望值有足够的默契，这是没有什么问题的， 这样的团队我也在其中过，那是一个非常棒的体验， 理性，克制，坦诚，一个目标，各司其职，而且都能完成的很好。但是如果我回头看看以前的这个团队的成员，每个人5年后发展，总共4个人，一个P8，一个高级经理了，一个资深架构了，一个创业当老板了。有时会感慨，这是一个什么团队.
这其实是个放养的团队，这个团队的事情现在回想起来还是如此的生动。苦活脏活也干，比如手动对比上千份PDF文档；技术难度高的活也做，比如修改apache 开源代码替换商业软件，提升很高的性能. 但是这些都是因为这个团队足够自驱，足够成熟，并且也并没有把KPI想的那么严重，只是相信比原来好，KPI就不会差.
放养式开发管理 - 不那么成功的大多数 从这个团队出来之后，陆陆续续遇到的一些放养式开发管理，遇到的问题，其实大体一样，就是不可控的实现方式。
什么叫不可控的实现方式？ 其实就是实现某个功能，你完全不能控制具体实现的方式，这些实现方式往往和技术Leader的想法差别很大，以为是这样的，往往变成不知道的一个什么情况；时间久了，技术债务越堆越多,以后变成难以维护.
也想过这些原因，个人觉得原因可能如下:
现在公司中的项目很多都是具有巨大不确定性，所以开发人员对他的预期其实是很模糊的，那么做到什么程度大家其实是没有一致的共识的 团队成员结构，很多其实很奇怪，一个Leader级别非常高，然后其他人很多可能都是1，2年的新手，这些新手完成功能可能还可以，但是如果说的实现的好坏，视野和品味就不够了，都觉的自己的实现好，但是其实还没有办法进行全面客观的评价了 团队对于项目技术和工程实现上没有预期，就是没有要求；所以自然做到哪里算哪里，怎么做当然也就无所谓了；但是问题是，团队需要锻炼，成员需要培养，如果不从一点一点的小项目的实战中锻炼，哪里来的提高呢？ 从哪里去选拔中间层呢？ 团队成员自驱和自我学习的能力并没有那么强，其实这才是普通团队的情况，你能遇到一个团队里面每个人都自驱，自省，自我学习能力强，这个其实也是基本非常难的；所以如果都是放养式管理，很显然是不合适的 管理能力，不是所有leader有管理能力，所以放养式是一个好办法，所谓结果导向吧，但是结果呢？当然怎么看待这个结果的事情，从我的角度看，技术团队业务贡献产出和技术工程能力都需要看，但是大部分主要还是看业务产出了，那么很明显，放养式管理是个好选择，因为管理人员不需要耗费很大的精力去培养，锻炼，只需要下个命令就可以了，但是技术和工程方面呢？ 如果一个技术团队对于技术和工程上没有期望值，大体上，慢慢的，项目和团队就会变得越来越难。</description></item><item><title>做决定，负责任</title><link>https://qdriven.github.io/blog/qa-thoughts/2-decision-making/</link><pubDate>Mon, 10 Aug 2020 21:50:47 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/2-decision-making/</guid><description>做决定，负责任,并不容易.
测试工作，决定，负责任 为什么突然想起这个做决定，负责任的话题？因为日常工作中，我慢慢发现很多很多的开发同学不喜欢做决定，明明很多事情再我看来可以下决定，却非要请示上级，而每一次的请示有时会有很长一个等待时间，而有时这个等待时间往往在下班前后，叫人下班也不是，不下班也不是，只能单纯的等待请示结果.
举个实际的例子来说，下班前的我们测试说测试完成了，可以上线了。然后负责这个功能的开发就是准备上线，问运维什么是否可以今天上线？运维回答说明天可以上线吗？开发马上把问题给了他老板，让他老板同不同意？而他的老板由于出差，等了三个多小时才回复可以介绍今天不上线。
这个只是一件事情，但是我遇到过不少类似的事情。 我不能说这样的事情有什么大的不对，但是有时细细想想，十分不是滋味。
为什么呢？首先这个时候支持开发上线的测试和运维中间这三个小时是下班好还是不下班好？第二个问题，为什么开发不知道老板对这个事情的期望，事实上老板的期望的时间并不是当天晚上就一定要上线.
那么对于这件事情来说，我对我们测试人员的要求就是:
计划: 确定和同步所有人对于上线时间点的预期，让所有人都知道什么时候上线，什么时候开始做准备，如果需要在非工作时间上线，那么提前说明，兄弟部门不是不愿意加班，而是不愿意莫名其妙的加班 应对变化: 如果上线出现了点意料之外的情况，那么首先判断的是是不是非要今天上线这个时间点上线，匆忙中有没有额外的风险；如果不是，那就换到明天稳妥的时间段上线，生产的稳定一定是比其他东西更重要的；不管是从KPI的角度来说，你上线一个充满着不确定的新功能而造成生产事故，这是丢了西瓜捡了芝麻的事情 一定要有决定，无论上线还是不上线，一定要下决定，判断的依据其实就是，是不是事先已经计划好了，是不是重要的非要带着重大的风险上线，是不是需要所有部门都要加班支持你的程度？每个部门都有自己重要的事情，凡事不能到滥用的地步</description></item><item><title>lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项</title><link>https://qdriven.github.io/blog/bugs/lagou/</link><pubDate>Mon, 07 Oct 2019 21:32:43 +0000</pubDate><guid>https://qdriven.github.io/blog/bugs/lagou/</guid><description>Bug 描述 lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项 步骤:
进入首页，选择地区上海，关键字输入软件测试 待搜索结果显示之后，工作经验选择为应届毕业生 所有结果出现后，取消应届的选择，不能再回退到工作经验的选项 期望结果: 取消应届选择后，回退到有工作经验的所有选项 疑问: 这是一个Bug吗？还是产品经理的一个设计? 有方便的地方，也有不方便的地方，如果测试人员不知道这个需求,你要怎么处理这个事情?</description></item><item><title>软件质量文化建设</title><link>https://qdriven.github.io/blog/qa-thoughts/0-build-in-q/</link><pubDate>Mon, 07 Oct 2019 11:40:11 +0200</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/0-build-in-q/</guid><description>什么是质量文化 测试/QA质量文化建设 内建质量 质量外延 测试过程中的常见问题 这些都是测试过程中的常见问题，但是其实都不容易解决.为什么不容易解决，主要问题：
测试中发现的问题往往比较零散,不容易总结 这些问题的解决往往短期内看不到直接效果，是一个系统工程 项目可能都是短期的，谁会在意长期的事情？ 出现问题方可以把所有的问题都指向测试，而自身的压力会不自觉的减轻，但是无论如何转移责任并不会解决问题 测试压力很大，但是有时问题大到测试没有能力解决了 关于质量的建设有以下几个需要事先了解的:
没有数据根本无从说起 没有对比就没有改进 质量是个长期工作,长期艰苦枯燥的工作 没太多人愿意做长期枯燥的工作，但是公司实际上是需要的 质量是系统工程，需要系统参与不是只有QA一个部门 质量不止靠 QA 角色兜底的意识/工作方式，只靠测试QA是可以转移责任，但是不能解决问题 发现问题同样重要，QA虽然不能直接解决问题，但是他能让更高层对于工程能力,产品能力有更全面的认识；只听到好话的公司，也是危险的，更高层如果只听到好话，并且真的认为很好，那会造成很多的误判，是不负责任的轻信 没有经过验证的进度，可能都是虚假的进度，会造成资源的错误估计 内建质量 研发，产品，QA，设计，数据分析师,市场每个角色都会对最终产品形态有直接影响。</description></item><item><title>Xmind,Test Cases,and Allure templates for TDD</title><link>https://qdriven.github.io/blog/en/1-junit5casetesttemplate/</link><pubDate>Wed, 07 Aug 2019 21:34:04 +0000</pubDate><guid>https://qdriven.github.io/blog/en/1-junit5casetesttemplate/</guid><description>Xmind,TestCases and JUnit5 Allure Template Learn from the requirements and write test cases are the common daily work of a tester.</description></item><item><title>Implement A Integration Testing Libs in two days</title><link>https://qdriven.github.io/blog/en/api-testing/0-start-from-the-end/</link><pubDate>Sun, 28 Jul 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/0-start-from-the-end/</guid><description>There is a question over my head several times. is it real hard for tester to write test codes? I don&amp;rsquo;t know, but I just want to do a task to evaluate this conclusion.</description></item><item><title>Integration-Runner Test Case Demo</title><link>https://qdriven.github.io/blog/en/api-testing/1-demo-testcase/</link><pubDate>Sun, 28 Jul 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/1-demo-testcase/</guid><description>Last chapter introduce how to build a test framework in two days, In this chapter, let&amp;rsquo;s do demos:
A Api TestCase Api Chain Test Case Pre-Condition And Verification Render to use context data A Api TestCase Here are two cases:</description></item><item><title>Using IntelljIdea For Code Coverage</title><link>https://qdriven.github.io/blog/en/3-inteljidea-codecoverage/</link><pubDate>Sun, 28 Jul 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/3-inteljidea-codecoverage/</guid><description>Two Steps:
Run Test Code with code coverage - Right click the test class, select run *** with code coverage Check the Code Coverage in intelli idea Line Code Covearge/Method Coverage Read marked as not covered lines, green as covered lines</description></item><item><title>The Easiest Mock, The highest ROI</title><link>https://qdriven.github.io/blog/en/4-productivity-simplemock/</link><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/blog/en/4-productivity-simplemock/</guid><description>Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.</description></item><item><title>The Easiest Mock, The highest ROI</title><link>https://qdriven.github.io/blog/en/api-testing/4-productivity-simplemock/</link><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/4-productivity-simplemock/</guid><description>Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.</description></item><item><title>Rule Based Risk Engine Part 3 - The Easiest Mock, The highest ROI</title><link>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-3/</link><pubDate>Sun, 28 Apr 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-3/</guid><description>Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.</description></item><item><title>Think in Testing 1-Be Tough</title><link>https://qdriven.github.io/blog/qa-thoughts/4-be-tough/</link><pubDate>Sun, 28 Apr 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/4-be-tough/</guid><description>Think in Testing 1: Be Tough If someone tell you that software testing or quality assurance is an easy job to do, he/she might not understand what a tester or qa do.</description></item><item><title>Rule Based Risk Engine Part 2 - Write Code to Test</title><link>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-2/</link><pubDate>Thu, 25 Apr 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-2/</guid><description>What to do is quite obvious:
Compose input data - Test Case Input Fundamental Data Third Party And in-house data Mock the third party and in-house data according test cases Call the Evaluation API to checkout if meet the expectation And how to write code?</description></item><item><title>Rule Based Risk Engine Testing Part 1- Background</title><link>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-1/</link><pubDate>Tue, 23 Apr 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-1/</guid><description>This article introduces a real world case for testing a rule based risk engine. Let me separate it into several parts:</description></item><item><title>Build API Testing Framework-1 - Learn Http Api</title><link>https://qdriven.github.io/blog/en/api-testing/apitesting-intro/</link><pubDate>Sat, 20 Apr 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/apitesting-intro/</guid><description>Build API Testing Framework-1 - Learn Http Api API now, in most cases, it is a HTTP API which over http protocol.</description></item><item><title>Build API Testing Framework-1 - Learn Http Api</title><link>https://qdriven.github.io/blog/en/apitesting-intro/</link><pubDate>Sat, 20 Apr 2019 23:58:45 +0000</pubDate><guid>https://qdriven.github.io/blog/en/apitesting-intro/</guid><description>Build API Testing Framework-1 - Learn Http Api API now, in most cases, it is a HTTP API which over http protocol.</description></item><item><title>Be Tough as a QA</title><link>https://qdriven.github.io/blog/qa-thoughts/thoughts-be-a-touch-tester/</link><pubDate>Tue, 20 Nov 2018 09:25:03 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/thoughts-be-a-touch-tester/</guid><description>Think in Testing 1: Be Tough If someone tell you that software testing or quality assurance is an easy job to do, he/she might not understand what a tester or qa do.</description></item><item><title>Loan Calculation Testing</title><link>https://qdriven.github.io/blog/en/api-testing/loan-calculation/</link><pubDate>Mon, 13 Aug 2018 22:35:32 +0000</pubDate><guid>https://qdriven.github.io/blog/en/api-testing/loan-calculation/</guid><description>Loan Calculation Example Loan Rule Defintion Installment Calculation Overdue Calculation IRR Calculation Loan Rule Definition Installments Calculation repayment-Principal: ROUND(10000/3,2) repayment-interest: ROUND(10000*2%,2) Advanced Repayment calculation Overall Payment = Current Term Repayment + Remain Principal+ default penalty(10000*1%)</description></item><item><title>使用JunitPerf进行性能测试</title><link>https://qdriven.github.io/blog/automation/junit-perf/</link><pubDate>Tue, 24 Jul 2018 22:11:05 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/junit-perf/</guid><description>以下简单介绍一下如何使用JunitPerf进行性能测试，JunitPerf是基于JUnit4的一个单元性能测试插件，对于会远程调用API测试比较合适，如果想要比较nanosecond 延迟的则需要使用JMH.
JunitPerf 依赖声明 此例子假设使用MAVEN管理项目，所以在POM文件中添加：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.github.noconnor&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junitperf&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 构建压力测试类 假设你想衡量DemoPerfService 类中的getServiceId方法：</description></item><item><title>Rest API Security</title><link>https://qdriven.github.io/blog/api-testing/rest-api_security/</link><pubDate>Tue, 12 Apr 2016 13:26:07 +0000</pubDate><guid>https://qdriven.github.io/blog/api-testing/rest-api_security/</guid><description>REST: Representational State Transfer REST 提倡无需Session，每次请求都带上身份认证，同样 REST基于HTTP的也是无状态的.不过REST API的安全性都需要自己实现.REST WEB SERVICE 的核心是RESOURCE(资源).资源可以使用URI来表示，一般REST风格的请求对应关系如下：
HTTP 方法 行为 实例 GET 获取资源信息 http://example.</description></item><item><title>Ansible 60分钟入门</title><link>https://qdriven.github.io/blog/ansible/</link><pubDate>Wed, 30 Mar 2016 13:15:11 +0800</pubDate><guid>https://qdriven.github.io/blog/ansible/</guid><description>Ansible 介绍 Ansible可以用来帮助IT自动化，关于ansible的一点说明:
Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain.</description></item><item><title>Jenkins API的简单介绍</title><link>https://qdriven.github.io/blog/automation/2016-03-30-jenkins_basic/</link><pubDate>Wed, 30 Mar 2016 13:15:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2016-03-30-jenkins_basic/</guid><description>Jenkins 介绍 Jenkins是一个非常有用的持续集成的工具，可以通过它完成代码的build，测试，发布等一系列的事情.
From Jenkins Home Page
Jenkins is an automation engine with an unparalleled plugin ecosystem to support all of your favorite tools in your delivery pipelines, whether your goal is continuous integration, automated testing, or continuous delivery.</description></item><item><title>assertions</title><link>https://qdriven.github.io/blog/automation/2016-02-01-assertions/</link><pubDate>Mon, 01 Feb 2016 23:48:35 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/2016-02-01-assertions/</guid><description>由于一直都在进行测试的工作，所以会关注Assertion的工具，发现两个不错的Assertion 第三方包，准备在实践中使用. 这两个分别是：
Google Truth(http://google.github.io/truth/usage/) assertj 这个里面有很多自己想实现的比较的功能。一下是一些简单的试用的代码。
Google Truth 基础的验证：
@Test public void test_basic_truth(){ Set&amp;lt;String&amp;gt; foo = Sets.</description></item><item><title>WEB 开发的几个重点</title><link>https://qdriven.github.io/blog/automation/2016-01-27-web-dev/</link><pubDate>Wed, 27 Jan 2016 22:47:28 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/2016-01-27-web-dev/</guid><description>再试用了Web 开发的框架之后，归纳一下大致的一个基础Web 开发需要的那些元素:
URL Router，如何定义URL的访问 Request Handler/Response Handler， HTTP请求/返回的处理 如果组织这些Request Handler/Response Handler 如何定义全局/局部的URL拦截器 如何处理特殊的HTTP Header 如何处理Session/Cookie Database Access Layer/ORM， 数据操作CRUD 如何CRUD 如何进行分页，排序，filterByCriteria&amp;hellip;.</description></item><item><title>为什么自动化，如何自动化</title><link>https://qdriven.github.io/blog/opinons/2016-01-10-why_how_automation/</link><pubDate>Sun, 10 Jan 2016 19:14:11 +0000</pubDate><guid>https://qdriven.github.io/blog/opinons/2016-01-10-why_how_automation/</guid><description>在做一件事情之前，问一句为什么是必要的.做自动化测试之前也是一样，不管如何总是要有一个理由的吗，哪怕是所有的人都做，我也要做这样的理由. 以下说说我觉得要做自动化的理由.
为什么自动化(Why Automation Testing) 为什么自动化,对于测试的而言的理由 VS 实际情况
自动化可以减少重复的回归测试(实际中的我问题:那么回归测试在你日常的测试中比例是多少) 自动化测试可以提高自己的编码能力(这个原因无论如何是成立的) 自动化测试可以进行更快的迭代（实际中的问题：自动化测试的不稳定可能不一定起到预想的作用） 自动化测试可以做更多的回归测试内容，减少风险(实际中的问题：不稳定的测试可能不一定能够达到目的) 不同的测试环境可以运行相同的测试(实际的问题： 可能没有那么多的环境，一般情况下都有测试环境，集成环境，预发布环境，生产环境，其实不是没个公司都需要这样做的&amp;hellip;&amp;hellip;) 对于被测系统有更深刻的理解.由于需要编写代码，有时需要更深刻的理解内部的代码实现原理(实际中因人而异&amp;hellip;&amp;hellip;) 自动化测试不仅仅包括进行测试，还包括一切去提高交付产品效率质量的东西，对于测试而言提出了新要求(always true if QA really does this) 功能测试的业务知识可能在这家公司有用，到别家就没用了，但是会写代码可以积累自己(always true) 无论是性能测试和安全测试都需要代码能力，通过自动化代码的编写可以更好的了解，掌握性能测试或者安全测试(实际情况：不是没个人都对编码感兴趣的) 为什么自动化,对于公司的而言的理由 VS 实际情况</description></item><item><title>下一步的技术了解</title><link>https://qdriven.github.io/blog/qa-thoughts/2015-12-28-next-reading/</link><pubDate>Mon, 28 Dec 2015 19:49:29 +0000</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/2015-12-28-next-reading/</guid><description>Thoughtworks 发布了2015年技术雷达，看看他提到的东西可以长长见识。
技术篇 这里提到了几篇Martin Flower的文章，抽时间一定要看看。
Test Double nonDeterminism microservice 基本上他写的文章确实有必要看看的。 安全 －Thread Modeling
工具,语言，观念 graphiz hoodie couchdb Flux git as cms phoneix server functional reactive programing （FRP） Spark kylin.</description></item><item><title>http status code HTTP 状态码</title><link>https://qdriven.github.io/blog/automation/2015-12-23-http_status_code/</link><pubDate>Wed, 23 Dec 2015 22:59:16 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/2015-12-23-http_status_code/</guid><description>HTTP Status Codes This page is created from HTTP status code information found at ietf.org and Wikipedia. Click on the category heading or the status code link to read more.</description></item><item><title>自动化测试－接口测试</title><link>https://qdriven.github.io/blog/api-testing/2015-11-27-webservice-automation/</link><pubDate>Fri, 27 Nov 2015 11:10:00 +0000</pubDate><guid>https://qdriven.github.io/blog/api-testing/2015-11-27-webservice-automation/</guid><description>在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。
下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：
如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法 如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：
通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试 我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:
发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们 总体上我自己的总结是如下图:</description></item><item><title>自动化测试－接口测试</title><link>https://qdriven.github.io/blog/opinons/2015-11-27-webservice-automation/</link><pubDate>Fri, 27 Nov 2015 11:10:00 +0000</pubDate><guid>https://qdriven.github.io/blog/opinons/2015-11-27-webservice-automation/</guid><description>在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。
下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：
如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法 如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：
通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试 我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:
发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们 总体上我自己的总结是如下图:</description></item><item><title>Phantomjs Tutorial</title><link>https://qdriven.github.io/blog/automation/2015-10-24-phantomjs-usage/</link><pubDate>Sat, 24 Oct 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2015-10-24-phantomjs-usage/</guid><description>自己学习Phatomjs的教程,分享之.
Quick Start 首先phantomjs是个什么? 以下是官方网站的解释:
PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.</description></item><item><title>测试用例设计- 随机指定一个产品的测试</title><link>https://qdriven.github.io/blog/qa-thoughts/2015-10-22-random-testcasedesign/</link><pubDate>Thu, 22 Oct 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/2015-10-22-random-testcasedesign/</guid><description>有时面试的时候会随机指定一个产品进行测试,比如一个电梯,你会如何设计测试用例？这个问题很发散,更多的是看应聘者的条理 和分析能力.
本质上一个电梯是一个太大的范畴，实际测试的过程中很少一下子会有这么巨大的功能让你测试的。 与其说让你设计测试用例，其实好不如说让你想一个电梯有什么功能,然后根据功能再来考虑测试用例,所以更多的 是考察思路,在实际的测试工作中,如果突然有个人说我今天完成了一个电梯的功能,找个人给我测一下吧。 那么多半这个项目就是个让测试欲哭无泪的项目。
不过既然面试有人问这样的问题，那么就分析分析吧，以下我是把电梯转化为类似互联网产品来做的分析， 完全是个人想法,一定有非常多欠缺。
后端服务组件和客户端分离(Client-Server/MVC) 首先其实对把一个电梯分成不同的组件：
驱动服务: 可以使电梯上下行(后台服务) 门: 开门关门(后台服务) 电梯操作面板: 人机界面,担当用户和电梯的一个中间人作用,将用户操作转化为指令来控制电梯 (app/web page) (如果简单的话可能操作命令转换就都在这个地方了，如果复杂可能还有一个控制系统层) 指令控制系统(调度系统,监听器或者Queue) 呼叫监控系统:(可以暂时不考虑) 这里就先考虑简单的情况，电梯操作面板模块之内将操作转换成指令给电梯的驱动和门服务</description></item><item><title>Page Factory in Selenium</title><link>https://qdriven.github.io/blog/automation/2015-09-24-page-factory/</link><pubDate>Thu, 24 Sep 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2015-09-24-page-factory/</guid><description>本文主要用来分析Page Factory实现的原理以及一些扩展的可能性。
Page Factory 的例子 Selenium Page Factory Wiki
首先解释一下这个例子：
使用注解描述元素定位 使用 PageFactory.initElements(driver, page); public class GoogleSearchPage { // The element is now looked up using the name attribute @FindBy(how = How.</description></item><item><title>TestNG 报告定制最简单的原理</title><link>https://qdriven.github.io/blog/automation/2015-09-24-testng-simple-report/</link><pubDate>Thu, 24 Sep 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2015-09-24-testng-simple-report/</guid><description>如果需要定制TestNG的测试报告,可以先想一下首先需要什么的数据,其实最简单的数据就是测试用例成功失败的数据, 那么实际上TestNG提供了ITestListener的接口可以让你获取这些测试数据. 同时IReporter 接口可以让用户在调用最后自己生成测试报告.
所以其实只要用一个类实现ITestListener,IReporter就可以了.
ITestListener,IReporter实现 一下是我一个最简单的实现, 实际上TestNG开放出来的这些监听器,主要是让你可以获取TestNG 测试容器中运行测试的数据,上下文. 关于代码里面的ITestResult, xmlSuites,suites 可以自行查找
public class TestNGSimpleReport implements ITestListener, IReporter { private List&amp;lt;String&amp;gt; testPassed = Lists.</description></item><item><title>关于测试职业疑惑的一点想法</title><link>https://qdriven.github.io/blog/qa-thoughts/2013-09-24-thoughts_on_testing/</link><pubDate>Tue, 24 Sep 2013 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/qa-thoughts/2013-09-24-thoughts_on_testing/</guid><description>引子 作为全职测试大概有8年时间了，总体来说整个这8年不是一个愉快的过程。其中辛苦可能没有做过测试的人未必能理解。对于一个职场人来说不够愉快的点个人认为大概可能是以下几点：
成就感不多 个人技术积累不多 可供选择的机会相对较少，转型难度大 问题分析 1. 成就感不多 1.1.决定产品好坏的不是测试 大体可以罗列一下一个好的产品的几个要素：
解决了其他人没有解决的重要问题 易用，好用 扩展性好，定制能力强 稳定，bug少 性能出色 交付快，成本低 个人认为以上几点中测试几乎都无法起到决定因素。测试人可能看到某些新的需求，但是很难从更高层面上来看待产品；可用性上面同样也是一样的问题，可以提出优化的点，但是可能只是点到为止了；扩展性，定制能力，基本上看架构设计和开发的质量；至于稳定，bug少，性能好这个也要看团队了，大体上个人认为还是开发权重高；交付快，成本低，个人认为这块测试有一些权重，而且我认为测试需要投入更多的东西在这个层面</description></item><item><title>About The Author</title><link>https://qdriven.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/about/</guid><description/></item><item><title>Let's, Talk About You</title><link>https://qdriven.github.io/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/contact/</guid><description/></item><item><title>Privacy Policy</title><link>https://qdriven.github.io/privacy-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/privacy-policy/</guid><description/></item><item><title>Search Result</title><link>https://qdriven.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/search/</guid><description/></item></channel></rss>