<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fluent QA Blog</title><link>https://qdriven.github.io/</link><description>Recent content on Fluent QA Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 30 Mar 2016 13:15:11 +0800</lastBuildDate><atom:link href="https://qdriven.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Ansible 60分钟入门</title><link>https://qdriven.github.io/blog/ansible/</link><pubDate>Wed, 30 Mar 2016 13:15:11 +0800</pubDate><guid>https://qdriven.github.io/blog/ansible/</guid><description>Ansible 介绍 Ansible可以用来帮助IT自动化，关于ansible的一点说明:
Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain.</description></item><item><title>Jenkins API的简单介绍</title><link>https://qdriven.github.io/blog/automation/2016-03-30-jenkins_basic/</link><pubDate>Wed, 30 Mar 2016 13:15:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2016-03-30-jenkins_basic/</guid><description>Jenkins 介绍 Jenkins是一个非常有用的持续集成的工具，可以通过它完成代码的build，测试，发布等一系列的事情.
From Jenkins Home Page
Jenkins is an automation engine with an unparalleled plugin ecosystem to support all of your favorite tools in your delivery pipelines, whether your goal is continuous integration, automated testing, or continuous delivery.</description></item><item><title>assertions</title><link>https://qdriven.github.io/blog/automation/2016-02-01-assertions/</link><pubDate>Mon, 01 Feb 2016 23:48:35 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/2016-02-01-assertions/</guid><description>由于一直都在进行测试的工作，所以会关注Assertion的工具，发现两个不错的Assertion 第三方包，准备在实践中使用. 这两个分别是：
Google Truth(http://google.github.io/truth/usage/) assertj 这个里面有很多自己想实现的比较的功能。一下是一些简单的试用的代码。
Google Truth 基础的验证：
@Test public void test_basic_truth(){ Set&amp;lt;String&amp;gt; foo = Sets.</description></item><item><title>WEB 开发的几个重点</title><link>https://qdriven.github.io/blog/automation/2016-01-27-web-dev/</link><pubDate>Wed, 27 Jan 2016 22:47:28 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/2016-01-27-web-dev/</guid><description>再试用了Web 开发的框架之后，归纳一下大致的一个基础Web 开发需要的那些元素:
URL Router，如何定义URL的访问 Request Handler/Response Handler， HTTP请求/返回的处理 如果组织这些Request Handler/Response Handler 如何定义全局/局部的URL拦截器 如何处理特殊的HTTP Header 如何处理Session/Cookie Database Access Layer/ORM， 数据操作CRUD 如何CRUD 如何进行分页，排序，filterByCriteria&amp;hellip;.</description></item><item><title>为什么自动化，如何自动化</title><link>https://qdriven.github.io/blog/opinons/2016-01-10-why_how_automation/</link><pubDate>Sun, 10 Jan 2016 19:14:11 +0000</pubDate><guid>https://qdriven.github.io/blog/opinons/2016-01-10-why_how_automation/</guid><description>在做一件事情之前，问一句为什么是必要的.做自动化测试之前也是一样，不管如何总是要有一个理由的吗，哪怕是所有的人都做，我也要做这样的理由. 以下说说我觉得要做自动化的理由.
为什么自动化(Why Automation Testing) 为什么自动化,对于测试的而言的理由 VS 实际情况
自动化可以减少重复的回归测试(实际中的我问题:那么回归测试在你日常的测试中比例是多少) 自动化测试可以提高自己的编码能力(这个原因无论如何是成立的) 自动化测试可以进行更快的迭代（实际中的问题：自动化测试的不稳定可能不一定起到预想的作用） 自动化测试可以做更多的回归测试内容，减少风险(实际中的问题：不稳定的测试可能不一定能够达到目的) 不同的测试环境可以运行相同的测试(实际的问题： 可能没有那么多的环境，一般情况下都有测试环境，集成环境，预发布环境，生产环境，其实不是没个公司都需要这样做的&amp;hellip;&amp;hellip;) 对于被测系统有更深刻的理解.由于需要编写代码，有时需要更深刻的理解内部的代码实现原理(实际中因人而异&amp;hellip;&amp;hellip;) 自动化测试不仅仅包括进行测试，还包括一切去提高交付产品效率质量的东西，对于测试而言提出了新要求(always true if QA really does this) 功能测试的业务知识可能在这家公司有用，到别家就没用了，但是会写代码可以积累自己(always true) 无论是性能测试和安全测试都需要代码能力，通过自动化代码的编写可以更好的了解，掌握性能测试或者安全测试(实际情况：不是没个人都对编码感兴趣的) 为什么自动化,对于公司的而言的理由 VS 实际情况</description></item><item><title>http status code HTTP 状态码</title><link>https://qdriven.github.io/blog/automation/2015-12-23-http_status_code/</link><pubDate>Wed, 23 Dec 2015 22:59:16 +0000</pubDate><guid>https://qdriven.github.io/blog/automation/2015-12-23-http_status_code/</guid><description>HTTP Status Codes This page is created from HTTP status code information found at ietf.org and Wikipedia. Click on the category heading or the status code link to read more.</description></item><item><title>自动化测试－接口测试</title><link>https://qdriven.github.io/blog/opinons/2015-11-27-webservice-automation/</link><pubDate>Fri, 27 Nov 2015 11:10:00 +0000</pubDate><guid>https://qdriven.github.io/blog/opinons/2015-11-27-webservice-automation/</guid><description>在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。
下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：
如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法 如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：
通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试 我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:
发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们 总体上我自己的总结是如下图:</description></item><item><title>Phantomjs Tutorial</title><link>https://qdriven.github.io/blog/automation/2015-10-24-phantomjs-usage/</link><pubDate>Sat, 24 Oct 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2015-10-24-phantomjs-usage/</guid><description>自己学习Phatomjs的教程,分享之.
Quick Start 首先phantomjs是个什么? 以下是官方网站的解释:
PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.</description></item><item><title>Page Factory in Selenium</title><link>https://qdriven.github.io/blog/automation/2015-09-24-page-factory/</link><pubDate>Thu, 24 Sep 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2015-09-24-page-factory/</guid><description>本文主要用来分析Page Factory实现的原理以及一些扩展的可能性。
Page Factory 的例子 Selenium Page Factory Wiki
首先解释一下这个例子：
使用注解描述元素定位 使用 PageFactory.initElements(driver, page); public class GoogleSearchPage { // The element is now looked up using the name attribute @FindBy(how = How.</description></item><item><title>TestNG 报告定制最简单的原理</title><link>https://qdriven.github.io/blog/automation/2015-09-24-testng-simple-report/</link><pubDate>Thu, 24 Sep 2015 10:31:11 +0800</pubDate><guid>https://qdriven.github.io/blog/automation/2015-09-24-testng-simple-report/</guid><description>如果需要定制TestNG的测试报告,可以先想一下首先需要什么的数据,其实最简单的数据就是测试用例成功失败的数据, 那么实际上TestNG提供了ITestListener的接口可以让你获取这些测试数据. 同时IReporter 接口可以让用户在调用最后自己生成测试报告.
所以其实只要用一个类实现ITestListener,IReporter就可以了.
ITestListener,IReporter实现 一下是我一个最简单的实现, 实际上TestNG开放出来的这些监听器,主要是让你可以获取TestNG 测试容器中运行测试的数据,上下文. 关于代码里面的ITestResult, xmlSuites,suites 可以自行查找
public class TestNGSimpleReport implements ITestListener, IReporter { private List&amp;lt;String&amp;gt; testPassed = Lists.</description></item><item><title>About The Author</title><link>https://qdriven.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/about/</guid><description/></item><item><title>Let's, Talk About You</title><link>https://qdriven.github.io/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/contact/</guid><description/></item><item><title>Privacy Policy</title><link>https://qdriven.github.io/privacy-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/privacy-policy/</guid><description/></item><item><title>Search Result</title><link>https://qdriven.github.io/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://qdriven.github.io/search/</guid><description/></item></channel></rss>