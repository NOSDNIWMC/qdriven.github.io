<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fluent-QA Blog on Fluent QA Blog</title>
    <link>https://qdriven.github.io/blog/</link>
    <description>Recent content in Fluent-QA Blog on Fluent QA Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 May 2021 21:34:04 +0000</lastBuildDate><atom:link href="https://qdriven.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android 命令Cheetsheet</title>
      <link>https://qdriven.github.io/blog/cheetsheet/android_tips-1/</link>
      <pubDate>Thu, 27 May 2021 21:34:04 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/cheetsheet/android_tips-1/</guid>
      <description>Android截图命令screencap 查看帮助命令 adb shell screencap -v screencap: invalid option -- v usage: screencap [-hp] [-d display-id] [FILENAME] -h: this message -p: save the file as a png.</description>
    </item>
    
    <item>
      <title>数据中台研究-1</title>
      <link>https://qdriven.github.io/blog/data-platform/1-intro/</link>
      <pubDate>Thu, 27 May 2021 21:34:04 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/data-platform/1-intro/</guid>
      <description>关于所以中台的研究，我的第一个问题总是为什么有中台这个东西？所以对应到数据中台就是为什么有数据中台这个概念？ 他解决什么问题？和原来的不是中台的情况下有什么优势？有什么不同点？
为什么有数据中台 我自己的理解是从三方面看:
 数据量和多样性的指数式增长，必然造成数据相关技术的快速迭代，以及沿用旧技术越来越难以跟上新的发展，技术能力直接会影响到企业的业务和产品能力 单独业务团队负责自身数据的技术在原有的基础上变得越来越困难，面临的选择是：  扩张自身团队，跟上技术发展 把这部分数据业务交给专门人来做，自己专注使用和自身业务而不是基础技术   公司层面，自然看到了数据能力的重要性，但是在业务团队有两种不同的选择时，个人认为为倾向选择业务团队2的选项，为什么？因为1选项自然会出现重复建设， 大数据成本还是相当高的，公司从自身出发自然会选择看起来成本有优势的选择；同时数据的关联性变得越来越重要也支持公司建立数据中台的决策  以上是我认为公司会选择数据中台的原因。 同样我相信公司也了解数据中台之后，面临的问题是沟通成本上升，但是公司一定认为自己的组织能力是有办法解决这个问题的.
数据中台做什么事情和需要的能力 数据中台分层  ODS： Operation Data Store： 数据仓库源头系统的数据表通常会原封不动的存储一份，这称为ODS层，是后续数据仓库加工数据的来源 数据仓库：  DWD: Datawarehouse Detail DWB: Datawarehouse Base DWS: Data warehouse service ADS: Application Data Service DWM: Data warehouse Detail DIM: dimension   ETL: Extract-Transform-Load 范式：  第一范式：字段值不可分理 第二范式：确保表的每列都和主键相关 第三范式：确保每列都和主键列直接相关，而不是间接相关    Hadoop/Spark/Flink </description>
    </item>
    
    <item>
      <title>QE-Meetup： TDD 小结</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/1-tdd-way/</link>
      <pubDate>Wed, 07 Oct 2020 11:40:11 +0200</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/1-tdd-way/</guid>
      <description> 以下是关于TDD的小结，我个人的感受是：
 如果这个实践做的事情只是想知道那些接口出现了变动，那么可能通过代码review或者沟通是更好的方式，为了得到这个目的感觉要做的事情有点多 技术自然是很厉害，但是团队是不是沟通上面出现问题了？难道都不愿意到连改了什么，影响什么都不想说了   </description>
    </item>
    
    <item>
      <title>放养式开发管理</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/3-let-it-be/</link>
      <pubDate>Tue, 11 Aug 2020 08:58:55 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/3-let-it-be/</guid>
      <description>或许是在充满巨大不确定性的情况下，或许是在敏捷开发的情况下，放养开发管理变得越来越多.陆陆续续经历了一些公司，项目，发现几乎是一个共性.
我相信放养式开发管理是个中性词，没有好和坏，更多的是适合不适合. 一个词在不同的环境下，反应的情况是不一样的。
放养式开发管理 - 一个成功的例子 如果在一个开发个人能力突出，严谨，负责，功能能力强的团队，放养式开发管理可以介绍很多不太需要的沟通成本，大家相互信任，对于共同的期望值有足够的默契，这是没有什么问题的， 这样的团队我也在其中过，那是一个非常棒的体验， 理性，克制，坦诚，一个目标，各司其职，而且都能完成的很好。但是如果我回头看看以前的这个团队的成员，每个人5年后发展，总共4个人，一个P8，一个高级经理了，一个资深架构了，一个创业当老板了。有时会感慨，这是一个什么团队.
这其实是个放养的团队，这个团队的事情现在回想起来还是如此的生动。苦活脏活也干，比如手动对比上千份PDF文档；技术难度高的活也做，比如修改apache 开源代码替换商业软件，提升很高的性能. 但是这些都是因为这个团队足够自驱，足够成熟，并且也并没有把KPI想的那么严重，只是相信比原来好，KPI就不会差.
放养式开发管理 - 不那么成功的大多数 从这个团队出来之后，陆陆续续遇到的一些放养式开发管理，遇到的问题，其实大体一样，就是不可控的实现方式。
什么叫不可控的实现方式？ 其实就是实现某个功能，你完全不能控制具体实现的方式，这些实现方式往往和技术Leader的想法差别很大，以为是这样的，往往变成不知道的一个什么情况；时间久了，技术债务越堆越多,以后变成难以维护.
也想过这些原因，个人觉得原因可能如下:
 现在公司中的项目很多都是具有巨大不确定性，所以开发人员对他的预期其实是很模糊的，那么做到什么程度大家其实是没有一致的共识的 团队成员结构，很多其实很奇怪，一个Leader级别非常高，然后其他人很多可能都是1，2年的新手，这些新手完成功能可能还可以，但是如果说的实现的好坏，视野和品味就不够了，都觉的自己的实现好，但是其实还没有办法进行全面客观的评价了 团队对于项目技术和工程实现上没有预期，就是没有要求；所以自然做到哪里算哪里，怎么做当然也就无所谓了；但是问题是，团队需要锻炼，成员需要培养，如果不从一点一点的小项目的实战中锻炼，哪里来的提高呢？ 从哪里去选拔中间层呢？ 团队成员自驱和自我学习的能力并没有那么强，其实这才是普通团队的情况，你能遇到一个团队里面每个人都自驱，自省，自我学习能力强，这个其实也是基本非常难的；所以如果都是放养式管理，很显然是不合适的 管理能力，不是所有leader有管理能力，所以放养式是一个好办法，所谓结果导向吧，但是结果呢？当然怎么看待这个结果的事情，从我的角度看，技术团队业务贡献产出和技术工程能力都需要看，但是大部分主要还是看业务产出了，那么很明显，放养式管理是个好选择，因为管理人员不需要耗费很大的精力去培养，锻炼，只需要下个命令就可以了，但是技术和工程方面呢？  如果一个技术团队对于技术和工程上没有期望值，大体上，慢慢的，项目和团队就会变得越来越难。</description>
    </item>
    
    <item>
      <title>做决定，负责任</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/2-decision-making/</link>
      <pubDate>Mon, 10 Aug 2020 21:50:47 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/2-decision-making/</guid>
      <description>做决定，负责任,并不容易.
测试工作，决定，负责任 为什么突然想起这个做决定，负责任的话题？因为日常工作中，我慢慢发现很多很多的开发同学不喜欢做决定，明明很多事情再我看来可以下决定，却非要请示上级，而每一次的请示有时会有很长一个等待时间，而有时这个等待时间往往在下班前后，叫人下班也不是，不下班也不是，只能单纯的等待请示结果.
举个实际的例子来说，下班前的我们测试说测试完成了，可以上线了。然后负责这个功能的开发就是准备上线，问运维什么是否可以今天上线？运维回答说明天可以上线吗？开发马上把问题给了他老板，让他老板同不同意？而他的老板由于出差，等了三个多小时才回复可以介绍今天不上线。
这个只是一件事情，但是我遇到过不少类似的事情。 我不能说这样的事情有什么大的不对，但是有时细细想想，十分不是滋味。
为什么呢？首先这个时候支持开发上线的测试和运维中间这三个小时是下班好还是不下班好？第二个问题，为什么开发不知道老板对这个事情的期望，事实上老板的期望的时间并不是当天晚上就一定要上线.
那么对于这件事情来说，我对我们测试人员的要求就是:
 计划: 确定和同步所有人对于上线时间点的预期，让所有人都知道什么时候上线，什么时候开始做准备，如果需要在非工作时间上线，那么提前说明，兄弟部门不是不愿意加班，而是不愿意莫名其妙的加班 应对变化: 如果上线出现了点意料之外的情况，那么首先判断的是是不是非要今天上线这个时间点上线，匆忙中有没有额外的风险；如果不是，那就换到明天稳妥的时间段上线，生产的稳定一定是比其他东西更重要的；不管是从KPI的角度来说，你上线一个充满着不确定的新功能而造成生产事故，这是丢了西瓜捡了芝麻的事情 一定要有决定，无论上线还是不上线，一定要下决定，判断的依据其实就是，是不是事先已经计划好了，是不是重要的非要带着重大的风险上线，是不是需要所有部门都要加班支持你的程度？每个部门都有自己重要的事情，凡事不能到滥用的地步  </description>
    </item>
    
    <item>
      <title>lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项</title>
      <link>https://qdriven.github.io/blog/bugs/lagou/</link>
      <pubDate>Mon, 07 Oct 2019 21:32:43 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/bugs/lagou/</guid>
      <description>Bug 描述 lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项 步骤:
 进入首页，选择地区上海，关键字输入软件测试 待搜索结果显示之后，工作经验选择为应届毕业生 所有结果出现后，取消应届的选择，不能再回退到工作经验的选项   期望结果: 取消应届选择后，回退到有工作经验的所有选项 疑问: 这是一个Bug吗？还是产品经理的一个设计? 有方便的地方，也有不方便的地方，如果测试人员不知道这个需求,你要怎么处理这个事情?  </description>
    </item>
    
    <item>
      <title>软件质量文化建设</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/0-build-in-q/</link>
      <pubDate>Mon, 07 Oct 2019 11:40:11 +0200</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/0-build-in-q/</guid>
      <description>什么是质量文化 测试/QA质量文化建设  内建质量 质量外延    测试过程中的常见问题 这些都是测试过程中的常见问题，但是其实都不容易解决.为什么不容易解决，主要问题：
 测试中发现的问题往往比较零散,不容易总结 这些问题的解决往往短期内看不到直接效果，是一个系统工程 项目可能都是短期的，谁会在意长期的事情？ 出现问题方可以把所有的问题都指向测试，而自身的压力会不自觉的减轻，但是无论如何转移责任并不会解决问题 测试压力很大，但是有时问题大到测试没有能力解决了  关于质量的建设有以下几个需要事先了解的:
 没有数据根本无从说起 没有对比就没有改进 质量是个长期工作,长期艰苦枯燥的工作 没太多人愿意做长期枯燥的工作，但是公司实际上是需要的 质量是系统工程，需要系统参与不是只有QA一个部门 质量不止靠 QA 角色兜底的意识/工作方式，只靠测试QA是可以转移责任，但是不能解决问题 发现问题同样重要，QA虽然不能直接解决问题，但是他能让更高层对于工程能力,产品能力有更全面的认识；只听到好话的公司，也是危险的，更高层如果只听到好话，并且真的认为很好，那会造成很多的误判，是不负责任的轻信 没有经过验证的进度，可能都是虚假的进度，会造成资源的错误估计  内建质量 研发，产品，QA，设计，数据分析师,市场每个角色都会对最终产品形态有直接影响。</description>
    </item>
    
    <item>
      <title>Xmind,Test Cases,and Allure templates for TDD</title>
      <link>https://qdriven.github.io/blog/en/1-junit5casetesttemplate/</link>
      <pubDate>Wed, 07 Aug 2019 21:34:04 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/1-junit5casetesttemplate/</guid>
      <description>Xmind,TestCases and JUnit5 Allure Template Learn from the requirements and write test cases are the common daily work of a tester.</description>
    </item>
    
    <item>
      <title>Implement A Integration Testing Libs in two days</title>
      <link>https://qdriven.github.io/blog/en/api-testing/0-start-from-the-end/</link>
      <pubDate>Sun, 28 Jul 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/0-start-from-the-end/</guid>
      <description>There is a question over my head several times. is it real hard for tester to write test codes? I don&amp;rsquo;t know, but I just want to do a task to evaluate this conclusion.</description>
    </item>
    
    <item>
      <title>Integration-Runner Test Case Demo</title>
      <link>https://qdriven.github.io/blog/en/api-testing/1-demo-testcase/</link>
      <pubDate>Sun, 28 Jul 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/1-demo-testcase/</guid>
      <description>Last chapter introduce how to build a test framework in two days, In this chapter, let&amp;rsquo;s do demos:
 A Api TestCase Api Chain Test Case Pre-Condition And Verification Render to use context data  A Api TestCase Here are two cases:</description>
    </item>
    
    <item>
      <title>Using IntelljIdea For Code Coverage</title>
      <link>https://qdriven.github.io/blog/en/3-inteljidea-codecoverage/</link>
      <pubDate>Sun, 28 Jul 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/3-inteljidea-codecoverage/</guid>
      <description>Two Steps:
 Run Test Code with code coverage - Right click the test class, select run *** with code coverage  Check the Code Coverage in intelli idea    Line Code Covearge/Method Coverage   Read marked as not covered lines, green as covered lines   </description>
    </item>
    
    <item>
      <title>The Easiest Mock, The highest ROI</title>
      <link>https://qdriven.github.io/blog/en/4-productivity-simplemock/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/4-productivity-simplemock/</guid>
      <description>Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.</description>
    </item>
    
    <item>
      <title>The Easiest Mock, The highest ROI</title>
      <link>https://qdriven.github.io/blog/en/api-testing/4-productivity-simplemock/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/4-productivity-simplemock/</guid>
      <description>Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.</description>
    </item>
    
    <item>
      <title>Rule Based Risk Engine Part 3 - The Easiest Mock, The highest ROI</title>
      <link>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-3/</link>
      <pubDate>Sun, 28 Apr 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-3/</guid>
      <description>Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.</description>
    </item>
    
    <item>
      <title>Think in Testing 1-Be Tough</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/4-be-tough/</link>
      <pubDate>Sun, 28 Apr 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/4-be-tough/</guid>
      <description>Think in Testing 1: Be Tough If someone tell you that software testing or quality assurance is an easy job to do, he/she might not understand what a tester or qa do.</description>
    </item>
    
    <item>
      <title>Rule Based Risk Engine Part 2 - Write Code to Test</title>
      <link>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-2/</link>
      <pubDate>Thu, 25 Apr 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-2/</guid>
      <description>What to do is quite obvious:
 Compose input data - Test Case Input  Fundamental Data Third Party And in-house data   Mock the third party and in-house data according test cases Call the Evaluation API to checkout if meet the expectation  And how to write code?</description>
    </item>
    
    <item>
      <title>Rule Based Risk Engine Testing Part 1- Background</title>
      <link>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-1/</link>
      <pubDate>Tue, 23 Apr 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/creditrisk-testing-1/</guid>
      <description>This article introduces a real world case for testing a rule based risk engine. Let me separate it into several parts:</description>
    </item>
    
    <item>
      <title>Build API Testing Framework-1 - Learn Http Api</title>
      <link>https://qdriven.github.io/blog/en/api-testing/apitesting-intro/</link>
      <pubDate>Sat, 20 Apr 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/apitesting-intro/</guid>
      <description>Build API Testing Framework-1 - Learn Http Api API now, in most cases, it is a HTTP API which over http protocol.</description>
    </item>
    
    <item>
      <title>Build API Testing Framework-1 - Learn Http Api</title>
      <link>https://qdriven.github.io/blog/en/apitesting-intro/</link>
      <pubDate>Sat, 20 Apr 2019 23:58:45 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/apitesting-intro/</guid>
      <description>Build API Testing Framework-1 - Learn Http Api API now, in most cases, it is a HTTP API which over http protocol.</description>
    </item>
    
    <item>
      <title>Be Tough as a QA</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/thoughts-be-a-touch-tester/</link>
      <pubDate>Tue, 20 Nov 2018 09:25:03 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/thoughts-be-a-touch-tester/</guid>
      <description>Think in Testing 1: Be Tough If someone tell you that software testing or quality assurance is an easy job to do, he/she might not understand what a tester or qa do.</description>
    </item>
    
    <item>
      <title>Loan Calculation Testing</title>
      <link>https://qdriven.github.io/blog/en/api-testing/loan-calculation/</link>
      <pubDate>Mon, 13 Aug 2018 22:35:32 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/en/api-testing/loan-calculation/</guid>
      <description>Loan Calculation Example  Loan Rule Defintion Installment Calculation Overdue Calculation IRR Calculation  Loan Rule Definition Installments Calculation  repayment-Principal: ROUND(10000/3,2) repayment-interest: ROUND(10000*2%,2)  Advanced Repayment calculation Overall Payment = Current Term Repayment + Remain Principal+ default penalty(10000*1%)</description>
    </item>
    
    <item>
      <title>使用JunitPerf进行性能测试</title>
      <link>https://qdriven.github.io/blog/automation/junit-perf/</link>
      <pubDate>Tue, 24 Jul 2018 22:11:05 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/junit-perf/</guid>
      <description>以下简单介绍一下如何使用JunitPerf进行性能测试，JunitPerf是基于JUnit4的一个单元性能测试插件，对于会远程调用API测试比较合适，如果想要比较nanosecond 延迟的则需要使用JMH.
JunitPerf 依赖声明 此例子假设使用MAVEN管理项目，所以在POM文件中添加：
&amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;com.github.noconnor&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;junitperf&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;1.9.1&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 构建压力测试类 假设你想衡量DemoPerfService 类中的getServiceId方法：</description>
    </item>
    
    <item>
      <title>Rest API Security</title>
      <link>https://qdriven.github.io/blog/api-testing/rest-api_security/</link>
      <pubDate>Tue, 12 Apr 2016 13:26:07 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/api-testing/rest-api_security/</guid>
      <description>REST: Representational State Transfer REST 提倡无需Session，每次请求都带上身份认证，同样 REST基于HTTP的也是无状态的.不过REST API的安全性都需要自己实现.REST WEB SERVICE 的核心是RESOURCE(资源).资源可以使用URI来表示，一般REST风格的请求对应关系如下：
   HTTP 方法 行为 实例     GET 获取资源信息 http://example.</description>
    </item>
    
    <item>
      <title>Ansible 60分钟入门</title>
      <link>https://qdriven.github.io/blog/ansible/</link>
      <pubDate>Wed, 30 Mar 2016 13:15:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/ansible/</guid>
      <description>Ansible 介绍 Ansible可以用来帮助IT自动化，关于ansible的一点说明:
Ansible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain.</description>
    </item>
    
    <item>
      <title>Jenkins API的简单介绍</title>
      <link>https://qdriven.github.io/blog/automation/2016-03-30-jenkins_basic/</link>
      <pubDate>Wed, 30 Mar 2016 13:15:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2016-03-30-jenkins_basic/</guid>
      <description>Jenkins 介绍 Jenkins是一个非常有用的持续集成的工具，可以通过它完成代码的build，测试，发布等一系列的事情.
From Jenkins Home Page
Jenkins is an automation engine with an unparalleled plugin ecosystem to support all of your favorite tools in your delivery pipelines, whether your goal is continuous integration, automated testing, or continuous delivery.</description>
    </item>
    
    <item>
      <title>assertions</title>
      <link>https://qdriven.github.io/blog/automation/2016-02-01-assertions/</link>
      <pubDate>Mon, 01 Feb 2016 23:48:35 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2016-02-01-assertions/</guid>
      <description>由于一直都在进行测试的工作，所以会关注Assertion的工具，发现两个不错的Assertion 第三方包，准备在实践中使用. 这两个分别是：
 Google Truth(http://google.github.io/truth/usage/) assertj  这个里面有很多自己想实现的比较的功能。一下是一些简单的试用的代码。
Google Truth 基础的验证：
@Test  public void test_basic_truth(){  Set&amp;lt;String&amp;gt; foo = Sets.</description>
    </item>
    
    <item>
      <title>WEB 开发的几个重点</title>
      <link>https://qdriven.github.io/blog/automation/2016-01-27-web-dev/</link>
      <pubDate>Wed, 27 Jan 2016 22:47:28 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2016-01-27-web-dev/</guid>
      <description>再试用了Web 开发的框架之后，归纳一下大致的一个基础Web 开发需要的那些元素:
 URL Router，如何定义URL的访问 Request Handler/Response Handler， HTTP请求/返回的处理  如果组织这些Request Handler/Response Handler 如何定义全局/局部的URL拦截器 如何处理特殊的HTTP Header 如何处理Session/Cookie   Database Access Layer/ORM， 数据操作CRUD  如何CRUD 如何进行分页，排序，filterByCriteria&amp;hellip;.</description>
    </item>
    
    <item>
      <title>为什么自动化，如何自动化</title>
      <link>https://qdriven.github.io/blog/opinons/2016-01-10-why_how_automation/</link>
      <pubDate>Sun, 10 Jan 2016 19:14:11 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/opinons/2016-01-10-why_how_automation/</guid>
      <description>在做一件事情之前，问一句为什么是必要的.做自动化测试之前也是一样，不管如何总是要有一个理由的吗，哪怕是所有的人都做，我也要做这样的理由. 以下说说我觉得要做自动化的理由.
为什么自动化(Why Automation Testing) 为什么自动化,对于测试的而言的理由 VS 实际情况
 自动化可以减少重复的回归测试(实际中的我问题:那么回归测试在你日常的测试中比例是多少) 自动化测试可以提高自己的编码能力(这个原因无论如何是成立的) 自动化测试可以进行更快的迭代（实际中的问题：自动化测试的不稳定可能不一定起到预想的作用） 自动化测试可以做更多的回归测试内容，减少风险(实际中的问题：不稳定的测试可能不一定能够达到目的) 不同的测试环境可以运行相同的测试(实际的问题： 可能没有那么多的环境，一般情况下都有测试环境，集成环境，预发布环境，生产环境，其实不是没个公司都需要这样做的&amp;hellip;&amp;hellip;) 对于被测系统有更深刻的理解.由于需要编写代码，有时需要更深刻的理解内部的代码实现原理(实际中因人而异&amp;hellip;&amp;hellip;) 自动化测试不仅仅包括进行测试，还包括一切去提高交付产品效率质量的东西，对于测试而言提出了新要求(always true if QA really does this) 功能测试的业务知识可能在这家公司有用，到别家就没用了，但是会写代码可以积累自己(always true) 无论是性能测试和安全测试都需要代码能力，通过自动化代码的编写可以更好的了解，掌握性能测试或者安全测试(实际情况：不是没个人都对编码感兴趣的)  为什么自动化,对于公司的而言的理由 VS 实际情况</description>
    </item>
    
    <item>
      <title>下一步的技术了解</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/2015-12-28-next-reading/</link>
      <pubDate>Mon, 28 Dec 2015 19:49:29 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/2015-12-28-next-reading/</guid>
      <description>Thoughtworks 发布了2015年技术雷达，看看他提到的东西可以长长见识。
技术篇 这里提到了几篇Martin Flower的文章，抽时间一定要看看。
 Test Double nonDeterminism microservice 基本上他写的文章确实有必要看看的。  安全 －Thread Modeling
工具,语言，观念  graphiz hoodie couchdb Flux git as cms phoneix server functional reactive programing （FRP） Spark kylin.</description>
    </item>
    
    <item>
      <title>http status code HTTP 状态码</title>
      <link>https://qdriven.github.io/blog/automation/2015-12-23-http_status_code/</link>
      <pubDate>Wed, 23 Dec 2015 22:59:16 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2015-12-23-http_status_code/</guid>
      <description>HTTP Status Codes This page is created from HTTP status code information found at ietf.org and Wikipedia. Click on the category heading or the status code link to read more.</description>
    </item>
    
    <item>
      <title>自动化测试－接口测试</title>
      <link>https://qdriven.github.io/blog/api-testing/2015-11-27-webservice-automation/</link>
      <pubDate>Fri, 27 Nov 2015 11:10:00 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/api-testing/2015-11-27-webservice-automation/</guid>
      <description>在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。
下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：
 如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法  如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：
 通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试  我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:
 发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们  总体上我自己的总结是如下图:</description>
    </item>
    
    <item>
      <title>自动化测试－接口测试</title>
      <link>https://qdriven.github.io/blog/opinons/2015-11-27-webservice-automation/</link>
      <pubDate>Fri, 27 Nov 2015 11:10:00 +0000</pubDate>
      
      <guid>https://qdriven.github.io/blog/opinons/2015-11-27-webservice-automation/</guid>
      <description>在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。
下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：
 如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法  如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：
 通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试  我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:
 发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们  总体上我自己的总结是如下图:</description>
    </item>
    
    <item>
      <title>Phantomjs Tutorial</title>
      <link>https://qdriven.github.io/blog/automation/2015-10-24-phantomjs-usage/</link>
      <pubDate>Sat, 24 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2015-10-24-phantomjs-usage/</guid>
      <description>自己学习Phatomjs的教程,分享之.
Quick Start 首先phantomjs是个什么? 以下是官方网站的解释:
PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.</description>
    </item>
    
    <item>
      <title>测试用例设计- 随机指定一个产品的测试</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/2015-10-22-random-testcasedesign/</link>
      <pubDate>Thu, 22 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/2015-10-22-random-testcasedesign/</guid>
      <description>有时面试的时候会随机指定一个产品进行测试,比如一个电梯,你会如何设计测试用例？这个问题很发散,更多的是看应聘者的条理 和分析能力.
本质上一个电梯是一个太大的范畴，实际测试的过程中很少一下子会有这么巨大的功能让你测试的。 与其说让你设计测试用例，其实好不如说让你想一个电梯有什么功能,然后根据功能再来考虑测试用例,所以更多的 是考察思路,在实际的测试工作中,如果突然有个人说我今天完成了一个电梯的功能,找个人给我测一下吧。 那么多半这个项目就是个让测试欲哭无泪的项目。
不过既然面试有人问这样的问题，那么就分析分析吧，以下我是把电梯转化为类似互联网产品来做的分析， 完全是个人想法,一定有非常多欠缺。
后端服务组件和客户端分离(Client-Server/MVC) 首先其实对把一个电梯分成不同的组件：
 驱动服务: 可以使电梯上下行(后台服务) 门: 开门关门(后台服务) 电梯操作面板: 人机界面,担当用户和电梯的一个中间人作用,将用户操作转化为指令来控制电梯 (app/web page) (如果简单的话可能操作命令转换就都在这个地方了，如果复杂可能还有一个控制系统层) 指令控制系统(调度系统,监听器或者Queue) 呼叫监控系统:(可以暂时不考虑)  这里就先考虑简单的情况，电梯操作面板模块之内将操作转换成指令给电梯的驱动和门服务</description>
    </item>
    
    <item>
      <title>Page Factory in Selenium</title>
      <link>https://qdriven.github.io/blog/automation/2015-09-24-page-factory/</link>
      <pubDate>Thu, 24 Sep 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2015-09-24-page-factory/</guid>
      <description>本文主要用来分析Page Factory实现的原理以及一些扩展的可能性。
Page Factory 的例子 Selenium Page Factory Wiki
首先解释一下这个例子：
 使用注解描述元素定位 使用 PageFactory.initElements(driver, page);   public class GoogleSearchPage {  // The element is now looked up using the name attribute  @FindBy(how = How.</description>
    </item>
    
    <item>
      <title>TestNG 报告定制最简单的原理</title>
      <link>https://qdriven.github.io/blog/automation/2015-09-24-testng-simple-report/</link>
      <pubDate>Thu, 24 Sep 2015 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/automation/2015-09-24-testng-simple-report/</guid>
      <description>如果需要定制TestNG的测试报告,可以先想一下首先需要什么的数据,其实最简单的数据就是测试用例成功失败的数据, 那么实际上TestNG提供了ITestListener的接口可以让你获取这些测试数据. 同时IReporter 接口可以让用户在调用最后自己生成测试报告.
所以其实只要用一个类实现ITestListener,IReporter就可以了.
ITestListener,IReporter实现 一下是我一个最简单的实现, 实际上TestNG开放出来的这些监听器,主要是让你可以获取TestNG 测试容器中运行测试的数据,上下文. 关于代码里面的ITestResult, xmlSuites,suites 可以自行查找
public class TestNGSimpleReport implements ITestListener, IReporter {  private List&amp;lt;String&amp;gt; testPassed = Lists.</description>
    </item>
    
    <item>
      <title>关于测试职业疑惑的一点想法</title>
      <link>https://qdriven.github.io/blog/qa-thoughts/2013-09-24-thoughts_on_testing/</link>
      <pubDate>Tue, 24 Sep 2013 10:31:11 +0800</pubDate>
      
      <guid>https://qdriven.github.io/blog/qa-thoughts/2013-09-24-thoughts_on_testing/</guid>
      <description>引子 作为全职测试大概有8年时间了，总体来说整个这8年不是一个愉快的过程。其中辛苦可能没有做过测试的人未必能理解。对于一个职场人来说不够愉快的点个人认为大概可能是以下几点：
 成就感不多 个人技术积累不多 可供选择的机会相对较少，转型难度大  问题分析 1. 成就感不多 1.1.决定产品好坏的不是测试 大体可以罗列一下一个好的产品的几个要素：
 解决了其他人没有解决的重要问题 易用，好用 扩展性好，定制能力强 稳定，bug少 性能出色 交付快，成本低  个人认为以上几点中测试几乎都无法起到决定因素。测试人可能看到某些新的需求，但是很难从更高层面上来看待产品；可用性上面同样也是一样的问题，可以提出优化的点，但是可能只是点到为止了；扩展性，定制能力，基本上看架构设计和开发的质量；至于稳定，bug少，性能好这个也要看团队了，大体上个人认为还是开发权重高；交付快，成本低，个人认为这块测试有一些权重，而且我认为测试需要投入更多的东西在这个层面</description>
    </item>
    
  </channel>
</rss>
