























































































































































































































































































































































































































































































[{"categories":["programming"],"contents":"github个人网站自建规划：\n hugo-theme icon : https://www.iconfont.cn/ 海报设计： WPS svg: https://convertio.co/ banner VSCODE： markdown past 视频制作  ","date":"April 28, 2022","image":"https://qdriven.github.io/images/post/post-1_hu9af054623b436d0bd3986b31b7bc6cd9_4158512_650x0_resize_box_3.png","permalink":"/handson/website/1-build-personal-site-theme/","title":"个人网站搭建-主题篇"},{"categories":["programming"],"contents":"github个人网站自建规划：\n hugo-theme icon : https://www.iconfont.cn/ 海报设计： WPS svg: https://convertio.co/ banner VSCODE： markdown past 视频制作  ","date":"April 28, 2022","image":"https://qdriven.github.io/images/post/post-2_hued73e14e63118e19fad39e39968d7cc7_2441315_650x0_resize_box_3.png","permalink":"/handson/website/2-build-personal-website-tools-copy/","title":"个人网站搭建-工具篇"},{"categories":["programming"],"contents":"github个人网站自建规划：\n hugo-theme icon : https://www.iconfont.cn/ 海报设计： WPS svg: https://convertio.co/ banner VSCODE： markdown past 视频制作  ","date":"April 28, 2022","image":"https://qdriven.github.io/images/post/post-3_hu4cc21e7a863615a92cd0655f577c12f3_800270_650x0_resize_box_3.png","permalink":"/handson/website/3-build-personal-website-deploy/","title":"个人网站搭建-部署篇"},{"categories":null,"contents":"Android截图命令screencap 查看帮助命令 adb shell screencap -v screencap: invalid option -- v usage: screencap [-hp] [-d display-id] [FILENAME] -h: this message -p: save the file as a png. -d: specify the display id to capture, default 0. If FILENAME ends with .png it will be saved as a png. If FILENAME is not given, the results will be printed to stdout. 注意:\n如果文件名以.png结尾时，它将保存为png文件\n如果文件名没有给出,则结果被会被输出到stdout\n截图保存到SD卡里再导出 $ adb shell screencap -p /sdcard/screen.png $ adb pull /sdcard/screen.png $ adb shell rm /sdcard/screen.png 这种方法比较麻烦，需要3步：1. 截图保存到sdcard 2.将图片导出 3.删除sdcard中的图片\n截图直接保存到电脑 $ adb shell screencap -p | sed \u0026#39;s/\\r$//\u0026#39; \u0026gt; screen.png 执行adb shell 将\\n转换\\r\\n, 因此需要用sed删除多余的\\r\n如果直接当命令用还可以用 alias 包裝装起來： $ alias and-screencap=\u0026#34;adb shell screencap -p | sed \u0026#39;s/\\r$//\u0026#39;\u0026#34; $ and-screencap \u0026gt; screen.png 以后就可以方便的用and-screencap \u0026gt; 直接将截图保存到电脑上了\nAndroid内存限制 java虚拟机有内存使用上限的限制  **adb shell进入手机，这此参数被纪录在/system/build.prop中,如果想直接查看可以使用adb shell getprop** 单个应用程序最大内存限制,超过这个值会产生OOM dalvik.vm.heapgrowthlimit 应用启动后分配的初始内存 dalvik.vm.heapstartsize 单个java虚拟机最大的内存限制,超过这个值会产生OOM dalvik.vm.heapsize 小米2S的一些内存限制  #查看单个应用程序最大内存限制 adb shell getprop|grep heapgrowthlimit |[dalvik.vm.heapgrowthlimit]: [96m] #应用启动后分配的初始内存 adb shell getprop|grep dalvik.vm.heapstartsize |[dalvik.vm.heapstartsize]: [8m] #单个java虚拟机最大的内存限制 adb shell getprop|grep dalvik.vm.heapsize |[dalvik.vm.heapsize]: [384m] Android内存使用 android程序内存一般限制在16M，当然也有24M的，而android程序内存被分为2部分：\nnative和dalvik，dalvik就是我们平常说的java堆，我们创建的对象是在这里面分配的，而bitmap是直接在native上分配的，对于内存的限制是 native+dalvik 不能超过最大限制。\n用以下命令可以查看程序的内存使用情况：\nadb shell dumpsys meminfo $package_name or $pid //使用程序的包名或者进程id 查看虾米音乐app的内存占用情况\n adb shell dumpsys meminfo fm.xiami.main Applications Memory Usage (kB): Uptime: 71696500 Realtime: 98283758 ** MEMINFO in pid 17340 [fm.xiami.main] ** Shared Private Heap Heap Heap Pss Dirty Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ Native 0 0 0 1976 1577 226 Dalvik 2973 13956 2712 18691 10825 7866 Cursor 0 0 0 Ashmem 0 0 0 Other dev 4 44 0 .so mmap 894 2320 604 .jar mmap 0 0 0 .apk mmap 123 0 0 .ttf mmap 0 0 0 .dex mmap 2716 0 16 Other mmap 204 120 96 Unknown 808 540 804 TOTAL 7722 16980 4232 20667 12402 8092 Objects Views: 0 ViewRootImpl: 0 AppContexts: 5 Activities: 0 Assets: 3 AssetManagers: 3 Local Binders: 5 Proxy Binders: 13 Death Recipients: 0 OpenSSL Sockets: 0 SQL MEMORY_USED: 0 PAGECACHE_OVERFLOW: 0 MALLOC_SIZE: 0 其中size是需要的内存，而allocated是分配了的内存，对应的2列分别是native和dalvik，当总数也就是total这一列超过单个程序内存的最大限制时，OOM就很有可能会出现了。\n Shared Private Heap Heap Heap Pss Dirty Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ Native 0 0 0 1976 1577 226 Dalvik 2973 13956 2712 18691 10825 7866 TOTAL 7722 16980 4232 20667 12402 8092  Cpu使用情况 top命令如下： adb shell $ top -h top -h Usage: top [-m max_procs] [-n iterations] [-d delay] [-s sort_column] [-t] [-h] -m num Maximum number of processes to display. // 最多显示多少个进程 -n num Updates to show before exiting. // 刷新次数 -d num Seconds to wait between updates. // 刷新间隔时间（默认5秒） -s col Column to sort by \u0026lt;cpu,vss,rss,thr\u0026gt; // 按哪列排序 -t Show threads instead of processes. // 显示线程信息而不是进程 -h Display this help screen. // 显示帮助文档 $ top -n 1 top -n 1 举个例子： 查看前5个进程cup的使用情况\n adb shell top -m 5 -s cpu\nUser 33%, System 8%, IOW 0%, IRQ 0% User 340 + Nice 2 + Sys 83 + Idle 596 + IOW 6 + IRQ 0 + SIRQ 2 = 1029 PID PR CPU% S #THR VSS RSS PCY UID Name 27256 1 12% S 37 852340K 220296K fg u0_a25 fm.xiami.main 517 0 6% S 100 842940K 118832K fg system system_server 174 0 4% S 13 66532K 14000K fg media /system/bin/mediaserver 27767 0 2% S 11 673928K 50516K bg u0_a58 com.moji.mjweather 171 0 1% S 13 97904K 51964K fg system /system/bin/surfaceflinger 日志说明： User 35%, System 13%, IOW 0%, IRQ 0% // CPU占用率 User 109 + Nice 0 + Sys 40 + Idle 156 + IOW 0 + IRQ 0 + SIRQ 1 = 306 // CPU使用情况 PID CPU% S #THR VSS RSS PCY UID Name // 进程属性 xx xx% x xx xx xx xx xx xx CPU占用率： User 用户进程 System 系统进程 IOW IO等待时间 IRQ 硬中断时间 CPU使用情况（指一个最小时间片内所占时间，单位jiffies。或者指所占进程数）： User 处于用户态的运行时间，不包含优先值为负进程 Nice 优先值为负的进程所占用的CPU时间 Sys 处于核心态的运行时间 Idle 除IO等待时间以外的其它等待时间 IOW IO等待时间 IRQ 硬中断时间 SIRQ 软中断时间 进程属性： PID 进程在系统中的ID CPU% 当前瞬时所以使用CPU占用率 S 进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。 #THR 程序当前所用的线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY OOXX，不知道什么东东 UID 运行当前进程的用户id Name 程序名称android.process.media // ps：内存占用大小有如下规律：VSS \u0026gt;= RSS \u0026gt;= PSS \u0026gt;= USS // PSS Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存） // USS Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） 温馨提示：\n我们一般观察Uss来反映一个Process的内存使用情况，Uss 的大小代表了只属于本进程正在使用的内存大小,这些内存在此Process被杀掉之后，会被完整的回收掉，\nVss和Rss对查看某一Process自身内存状况没有什么价值，因为他们包含了共享库的内存使用，而往往共享库的资源占用比重是很大的，这样就稀释了对Process自身创建内存波动。 而Pss是按照比例将共享内存分割，某一Process对共享内存的占用情况。\nso\n查看USS和PSS可以使用adb shell procrank,前提是手机需要root\n adb shell procrank |grep xiami 如果只是查看PSS也可以使用adb shell dumpsys meminfo\n adb shell dumpsys meminfo fm.xiami.main|grep TOTAL TOTAL 143070 15312 130020 135179 122279 12667 温馨提示：\n在取内存数据前可以前判断一下手机是否root, 如果root了取USS比较好一些，如果没有root取PSS也是可以的。\n一. Android打包流程图 二. 打包步骤说明 第一步：打包资源文件，生成R.java文件    输入 输出 工具     Resource文件（就是工程中res中的文件）\n2. Assets文件（相当于另外一种资源，这种资源Android系统并不像对res中的文件那样优化它）\n3. AndroidManifest.xml文件（包名就是从这里读取的，因为生成R.java文件需要包名）\n4. Android基础类库（Android.jar文件）| 1. 打包好的资源（一般在Android工程的bin目录可以看到一个叫resources.ap_的文件就是它了）\n2. R.java文件（在gen目录中）|aapt  第二步：处理AIDL文件，生成对应的.java文件    输入 输出 工具     源码文件、aidl文件、framework.aidl文件 对应的.java文件 aidl    说明:有很多工程没有用到AIDL，那这个过程就可以省了\n第三步：编译Java文件，生成对应的.class文件    输入 输出 工具     源码文件（包括R.java和AIDL生成的.java文件）、库文件（.jar文件） .class文件 javac    第四步：把.class文件转化成Davik VM支持的.dex文件    输入 输出 工具     .class文件（包括Aidl生成.class文件，R生成的.class文件，源文件生成的.class文件），库文件（.jar文件） .dex文件 javac    第五步：打包生成未签名的.apk文件    输入 输出 工具     1.打包后的资源文件\n2.打包后类文件（.dex文件）\n3.libs文件（包括.so文件，当然很多工程都没有这样的文件，如果你不使用C/C++开发的话） 未签名的.apk文件 apkbuilder    第六步：对未签名.apk文件进行签名    输入 输出 工具     未签名的.apk文件 签名的.apk文件 jarsigner    第七步：对签名后的.apk文件进行对齐处理    输入 输出 工具     签名后的.apk文件 对齐后的.apk文件 zipalign工具    说明:不进行对齐处理是不能发布到Google Market的\n三. 打包过程中用到的工具:    名称 功能介绍 在操作系统中的路径     aapt Android资源打包工具 ${ANDROID_SDK_HOME}/platform-tools/appt   aidl Android接口描述语言转化为.java文件的工具 ${ANDROID_SDK_HOME}/platform-tools/aidl   javac Java Compiler ${JDK_HOME}/javac或/usr/bin/javac   dex 转化.class文件为Davik VM能识别的.dex文件 ${ANDROID_SDK_HOME}/platform-tools/dx   apkbuilder 生成apk包 ${ANDROID_SDK_HOME}/tools/opkbuilder   jarsigner .jar文件的签名工具 ${JDK_HOME}/jarsigner或/usr/bin/jarsigner   zipalign 字节码对齐工具 ${ANDROID_SDK_HOME}/tools/zipalign    ","date":"May 27, 2021","image":"https://qdriven.github.io/images/post/post-3_hu4cc21e7a863615a92cd0655f577c12f3_800270_650x0_resize_box_3.png","permalink":"/blog/cheetsheet/android_tips-1/","title":"Android 命令Cheetsheet"},{"categories":null,"contents":"关于所以中台的研究，我的第一个问题总是为什么有中台这个东西？所以对应到数据中台就是为什么有数据中台这个概念？ 他解决什么问题？和原来的不是中台的情况下有什么优势？有什么不同点？\n为什么有数据中台 我自己的理解是从三方面看:\n 数据量和多样性的指数式增长，必然造成数据相关技术的快速迭代，以及沿用旧技术越来越难以跟上新的发展，技术能力直接会影响到企业的业务和产品能力 单独业务团队负责自身数据的技术在原有的基础上变得越来越困难，面临的选择是：  扩张自身团队，跟上技术发展 把这部分数据业务交给专门人来做，自己专注使用和自身业务而不是基础技术   公司层面，自然看到了数据能力的重要性，但是在业务团队有两种不同的选择时，个人认为为倾向选择业务团队2的选项，为什么？因为1选项自然会出现重复建设， 大数据成本还是相当高的，公司从自身出发自然会选择看起来成本有优势的选择；同时数据的关联性变得越来越重要也支持公司建立数据中台的决策  以上是我认为公司会选择数据中台的原因。 同样我相信公司也了解数据中台之后，面临的问题是沟通成本上升，但是公司一定认为自己的组织能力是有办法解决这个问题的.\n数据中台做什么事情和需要的能力 数据中台分层  ODS： Operation Data Store： 数据仓库源头系统的数据表通常会原封不动的存储一份，这称为ODS层，是后续数据仓库加工数据的来源 数据仓库：  DWD: Datawarehouse Detail DWB: Datawarehouse Base DWS: Data warehouse service ADS: Application Data Service DWM: Data warehouse Detail DIM: dimension   ETL: Extract-Transform-Load 范式：  第一范式：字段值不可分理 第二范式：确保表的每列都和主键相关 第三范式：确保每列都和主键列直接相关，而不是间接相关    Hadoop/Spark/Flink ","date":"May 27, 2021","image":"https://qdriven.github.io/images/post/post-3_hu4cc21e7a863615a92cd0655f577c12f3_800270_650x0_resize_box_3.png","permalink":"/blog/data-platform/1-intro/","title":"数据中台研究-1"},{"categories":null,"contents":"最近一段时间经常听见有人说测试就是点点点，或者带着鄙视的声调说测试就是不就是点点点吗，一般情况下我不会回应，因为我知道就算回应也很难改变外面人的看法。不回应不代表我不去思考，测试真的就是点点点吗？我只想举个例子，大家都知道股票只要低买高卖就可以挣钱，但是有几个人靠股票人生开挂了？人们总是低估了做好看得懂的事情的难度，又高估了看不懂的事情的难度。\n测试真的就是点点吗？ 测试真的就是点点点吗？很明显不是，就算你看到的是点点点，其实有些要比点点点难多了，至少为什么点这个而不是那个，为什么先点这个而不是那个，为什么点过了还要去继续再点？为什么要是很多种不同的情况，每种情况又是代表什么含义呢？ 你看到的点点点的背后都是有不同逻辑的思考，而不同逻辑的思考会是一件简单的事情吗？ 只是高估了看的懂的事情，但是完全没有了解过他的背后，但是点点点真的只是表象。我自己的经验来说，测试需要的逻辑可能比写代码更多，为什么？因为测试本生有两种意图，一种是验证正确性，一种是去找到可能会造成不正确的情况来验证正确性；后一种是巨大的难度，首选你的选择面很多，其次你如何挑选异常情况，理论上异常情况是无穷多的，你为什么能确信你在大海里面捞到的东西就是你想要的？再次，选择的一些情况实际上是有些是非常难以模仿的，那么如何去模拟这些情况又变得很难，这样一来你还会觉得简单吗？\n测试就是一种实验，而实验是花大量时间和人力的地方，没有实验就不会有什么好的产品. 但是有一点是需要说明的，测试不代表就是专职测试人去做，这是一个非常重要的点，也是现在很多误区的来源.\n测试难度的分类和难点 这边不去总结测试有什么样的类型，这些类型如何去做，换个简单从进行测试难度的角度思考测试的工作，大致可以分为：\n 确定性的测试，如同大众相关的各种互联网服务，这些功能一般人都可以理解，主要是验证功能是否实现， 这些工作难度不高，但是工作量大，需要的人员多，但是每个人的工资上限低 和底层技术结合的测试，主要验证关键技术在EdgeCase上面的表现，这块要求高，测试能力代表工程能力，这块更多的是实验， 基本可以认为测试者就应该是开发者，或者比简单的开发人员更加高级的技术专家，极高的专业性 专业领域知识门槛高，领域知识一般人不懂，如化工，金融，航空等等，这些专业知识的积累绝不比通用技术难度低，极高的专业度  从领域角度我觉得大体分为三大类，那么这些从业人员的优缺点来看：\n 第一类，可替代性高，有上限，如果希望寻求有提升，我觉得就两个方向，一个是比其他人知道的多，在多个内容里面比其他人熟悉， 另外一个就是可以和技术结合，可以用技术手段解决确定性问题，比如通过代码能够自动化整个确定性的内容 第二类，技术性强但是问题是就业面窄，同时一般赢家通吃，刚好你做的内容是其他家强，或者被新事物淘汰，那么会遇到很大的挑战 这一类需要把原理搞的很懂，同时有一块比别人深入很多，那么在特定领域有很好的用途 第三类，大部分人忽律了专业领域的知识本质上也是技术的一种，和编程一样也是专业领域知识，这类人同时如果懂专业知识和编程，那么是高手中的高手，独当一面是自然而然的；但是大部分人是做不到的，一旦这个领域知识是一个高迭代或者非常偏门，那么和第二类一样也是面临直接淘汰  实际上从优缺点来看，大部分从事测试的人要么就是有很明显的上限，要么就是一个牛的不能再牛的人才，而在中间地带，实际上没有太多空间的.也就是要么在一个相对低的层次，要们就是一个明显高出其他类似人员很多很多的存在。其实这也是测试的一个难点，就是成为大牛的机会很少，大部分人就是最多能达到的高度很有限。从三类来说，第一类本质是什么人多可以做，第二类大部分是同一个人做，第三类有很好的互补，开发和测试有很好的互补，同时大家都容易被人认可。\n所以写到这里，职业的选择而言，其实大体比较清楚了。测试想要做的久，最好的还是可以专注一个行业；或者开发技能基本达到架构师水平。然后平时都被业务逼的没有时间学习了，达到一定深度是件很难的事情。\n已股市为例子，股票规则很简单，挣钱就一条，就是高卖低买；但是股票上挣钱的可能只有1%不到，这些就是陷阱，看起来很容易的事情，做好真的很难，而且会比想的还要难。\n","date":"April 26, 2021","image":"https://qdriven.github.io/images/thoughts/6_hu3d03a01dcc18bc5be0e67db3d8d209a6_4796558_650x0_resize_q90_box.jpg","permalink":"/blog/qa-traps/6-testing-is-hard/","title":"测试陷阱6- 测试很容易"},{"categories":null,"contents":"在我工作过的公司中，大部分的开发和测试工程师对于测试工程师的定位就是找Bug的人.这个认识我觉得没有什么问题，因为确实测试功能师大部分的工作就是找Bug. 一开始我自己也从来没有怀疑过，感觉这个定义偏差不是太大，但是随着工作年限的增加，我觉得这个定位越来越不那么正确了.\n为什么这样子说呢？我分两个方面来说明：\n 测试的目的只是保证质量吗？ 测试过程中发现的Bug到底能代表什么？  测试的目的只是保证质量吗？ 测试的目的只是保证质量吗？我觉得说是，没有什么问题的；但是保证质量了它又是为了什么呢？为了让产品更有竞争力！ 所以测试的最根本的目的是为了产品更有竞争力！有了这一个目的，作为测试人员也许需要把眼界放的更开阔一些，需要更多平衡的思维.\n从产品的角度看，质量是其中一个维度，其他还有很多维度，比如成本等等. 如果测试工程师把自己局限在找Bug的人，那么有时真的变成 只找Bug的人了，有些场景可能大家很熟悉，为了一个Bug进行了无休止的讨论，辩论，面红耳赤，但是如果仔细想想，你会发现这样讨论的目的是什么？ 想达到什么结果？这些其实是成本意识，在一场无休止的讨论之后到底有什么产出？有时产出无非就是：\n 是不是Bug 需不需要修复 是不是需要马上修复  这些问题其实是关于产品的问题，是不是Bug有时比起后面两个来说根本不是问题。 如果我们局限在找Bug的人的时候，有时容易为了是不是Bug争论了太多时间，而没有对两条更重要的点提出自己意见，达成任何对产品有帮助的共识进行行动，是不是有一些没有把握到重点？\n有些朋友和我说，我提的问题开发老是说这不是Bug，这些是需求，于是为了是不是Bug挣的面红耳赤。我一般问，这个有重要影响吗？是不是马上要改代码？如果这两个问题都是都得到的回答是，那么是不是Bug有那么重要吗？如果非要说是Bug，那你就说是需求的Bug好了. Bug本身不是什么问题，只有对业务/产品有重大影响时才会觉得是很大的问题；如果这两个问题答案都是否，我说那你费这么大力气干什么，这不是你的重点。\n以上的例子其实提醒测试工程师，我们要从产品的角度看Bug，来给Bug(或许是需求)定义严重程度，用事实来证明严重程度和优先级，而不是一味的认为这就是Bug。就算Bug很少，没人用产品也没有意义，就算Bug很多，没人用也没有意义.\n测试过程中发现的Bug到底能代表什么？ Bug到底能代表什么？我自己是很难说清楚，你说发现的多了好呢，还是发现少了好？根本说不清楚. 质量的好坏需要通过真正的客户就检验。 测试中发现了100个Bug和发现了50个Bug，如果交付给客户的产品都是客户满意的，那么发现100个Bug比50个Bug多这个没有任何意义。 但是Bug真的就没有任何意义了吗？如果测试只是定位在找Bug这个事情上面，那么可能会忽律很多对团队更有价值的事情上面，Bug数量不能代表质量情况， 但是某种程度上还是能代表团队的合作情况，比如团队沟通上面有没有问题，需求是不是很多不理解的，但是从来没有问问题；修复Bug的时候，是不是老是无休止的辩论；这些本质也是产品的成本的问题，团队的效率就是成本的问题，那么这些问题如果反馈，如果给予团队建议呢？ 这些测试工程师有没有想过？如果定位是找Bug的人，这些可能就不会考虑了，但是如果为了产品更有竞争力，那么你有第一手的资料，你可以总结，你可以反馈，你可以为产品更有竞争力作出更多贡献。\n综合以上,只是定位在找Bug对测试工程师的局限,很可能就把自己完成放在一个执行者的角色上面，如果仔细想想有很明显的如下几个不好的地方：\n 过于被动，要做的事情只能等别人通知，因为有了做好的东西你才可以测试呀，你才可以找Bug呀，但是没有做好的东西难道真的没有一点事情了吗？ 没有对团队进化有直接的反馈，如果只是找Bug，而没有提反馈，那么你浪费了大好的一手资料去给产品开发反馈，建立一个反馈闭环是非常之难，如果 测试工程师有机会去反馈，一定要做，这些对团队有实际改进的作用 视野不够开阔，如果只是考虑bug而不去考虑产品，那么一些有意义的妥协的建议你就不会参与，而是听人下命令 你永远被人下命令要去执行，但是不能提出解决方案 专注于找Bug是必须的，但是如果不去关注Bug的意义，Bug的影响，Bug背后代表的改善空间，那么就是浪费了改善业务的机会  ","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/5_hu3d03a01dcc18bc5be0e67db3d8d209a6_1199236_650x0_resize_q90_box.jpeg","permalink":"/blog/qa-traps/5-qa-bugs/","title":"测试陷阱5 - 测试就是找Bug"},{"categories":null,"contents":"最近几年陆陆续续也面试了不少测试的同学，好多同学也都提到了跳出舒适区的概念，好多人因为觉得需要跳出舒适区所以觉得需要换一个工作环境； 就测试而言好多同学都是觉得一直在做类似的事情，没有外部刺激，没有提高；同时又相信没有实际的项目锻炼，技能很难得到提高；甚至有些同学很明显 在自己公司做的还是不错的，升职也有，加薪也有，可是就是觉得自己在舒适区里面，觉得一定要跳出来才能很快提高。大体上套用美国总统的话就是keep me great.\n因为听多了,跳出舒适区貌似是这几年很流行的词语，也能在各个媒体上能看到听到，所以我有时想想貌似挺有道理的，跳出舒适区，接受挑战；可是有时又觉得总有些不对劲，为什么要跳出舒适区呢？舒适区有什么不好呢？最终最终跳出舒适区的目的是什么呢？\n跳出舒适区的最终目的是什么？ 因为年纪大了，现在习惯性的会问自己最终的目的是什么？最终想达到什么样的状态？ 对于跳出舒适区这种史诗般问题，我感觉是几乎等同于你活着为了什么这种宏大的哲学问题时，可是我跳出来的答案是难道我不是为了自己过的舒服点过日子吗？舒服点的日子不在舒适区里面过，在哪里过呢？所以我明白了我觉得不对劲的问题点在哪里了。无论你跳的动还是跳不动，最终不是应该去找到舒序区才对吗？ 至于跳出这种，不过是听上去有点叛逆，无非就是让你显得有点酷有点得瑟吗？所以问题变成了如何寻找舒适区，跳出和寻找其实还是又很大不一样的，跳出很多时候变成了非理性，变成了我非要脱离现在的环境，不管我下面的环境是什么，更重要的一点是跳出其实是没有说明目的地的，只说要跳，没说要跳哪里还是可怕的，下面是万丈深渊呢？；而寻找最大的不同就是想要一个目的地，归根到底还是会有目标的，想想你的目标是什么？难道目前的环境真的一点实现的机会都没有吗？ 我不觉得跳出舒适区不对，但是在准备跳出去，还是需要再想一次.\n还有一个叫能力圈的说法 无论愿不愿意承认，大多数的情况下，跳出舒适区钱还是会起到点作用的，至少认为跳出去了，会有挣更多钱的机会,这也没什么不对。但是按照前首富巴菲特的说法投资最主要原则是能力圈原则，挣钱其实基本上认为就是投资，你投资自己，利用自己的劳动获取最可观的收益，那么很显然这个原则很重要。然而这个原则 听起来和跳出舒适区有冲突，他说如果你找到自己的能力圈了，那么就不要出去了，稳稳妥妥的挣钱就是了，你并需要什么跳出这跳出那，你找到你的优势,好好想想你在当前环境里面的优势是什么，你的能力圈的边界是哪里，稳稳妥妥的把钱挣了没什么不好，超过了你的能力圈的边界可能更多的是亏损。无论钱听上去多么庸俗，但是它确实是可以改善你生活，帮助你达到你要的目标的最好最直接的东西。\n下面是一段查理·芒格说的话，我更愿意相信真的挣到钱的人，而不是相信那些看起来高大上公司(说不定明天就倒闭了)的CTO/CEO.\nSo, the simple takeaway here is clear. If you want to improve your odds of success in life and business then define the perimeter of your circle of competence, and operate inside. Over time, work to expand that circle but never fool yourself about where it stands today, and never be afraid to say “I don’t know.” 高大上的外面的世界 现在测试其实交流可能越来越多，也出现了很多各种各样的新词汇，于是很多喜欢学习的同学觉得外面的世界好美好，自己公司怎么啥也没有，什么也学不到；但是你怎么知道这些东西，其实可能就像美国总统常用的词 Fake News呢？ 他们说的那些理念实践，你动手做过吗？不要听他叫什么名字，看看他到底做了什么,听上去很厉害的账户体系说不定只有一个登录功能呢？Who Knows。\n或许先不要想跳出，或许先寻找你的优势，你在这个公司的优势，就足够满足你过上好生活了呢？既然你都感到你在舒适区了，那么你一定有你的优势，先找到它是什么吧\n","date":"October 7, 2019","image":"https://qdriven.github.io/images/thoughts/3_hu3d03a01dcc18bc5be0e67db3d8d209a6_2036528_650x0_resize_q90_box.jpeg","permalink":"/blog/qa-traps/4-comfortable-zone/","title":"测试陷阱4-跳出舒适区"},{"categories":null,"contents":"随着自动化测试的风靡，测试同学们越来越觉得自动化就是全部，自动化就是自己的方向。 这些本身没有太大问题，但是如果认为自动化测试就是终极技术，那么我觉得这是一个很大的陷阱。 为什么？个人觉得大部分的测试把自动化和技术都定义的太狭小了,技术和自动化都是非常宽泛的定义,下面是我自己问自己的两个问题:\n 什么是自动化？测试讨论的自动化难道就是接口自动化，UI自动化测试吗？ 什么是技术？技术难道就是写代码吗？把测试用例代码化吗？  什么是自动化？测试讨论的自动化难道就是接口自动化，UI自动化测试吗？ 为什么先问这个问题，因为很多同学一开始没有接触过自动化，后来写了一些自动化用例之后，要么觉得高人一等，要么觉得一会就觉得没意思了，原因何在？因为写过自动化测试用例之后，要么觉得我技术很厉害了，基本可以把所有问题都解决了；要么马上一个疑问是这有技术含量吗？ 大量重复的代码，差不多的验证点，没有比设计测试用例和执行用例高级到多少,然后就有一种深深的幻灭的感觉？路在何方的问题又来了.\n其实什么都可以是自动化,把原来重复做的事情用代码实现是自动化的一种；把类似的事情用代码实现也是自动化的一种；把 日常工作用代码实现也是自动化；这些自动化都是在做了一次之后再用代码去实现，如果用时髦一点的时候machine learning/ai去把 没做过的事情自动实现了,也是自动化. 我甚至可以说，社会生产力的进步都是每一个自动化的结果。 如果从这个角度看的，那么自动化能做的事情太多了，自动化测试也好，测试自动化也好，你可以做的事情有很多很多，多到你无法想像，问题是你有 能力做吗？ 那些写接口自动化，web ui自动化的技能足够你去做更多的自动化吗？\n自动化的目的大致就是为了不让人去做差不多的事情，减少重复劳动。用一样的方法做一样的事情是重复劳动，用不一样的方法重新再做一遍一样的事情也是重复劳动；如果目标是减少重复劳动，那么自动化测试就不能停在把测试自动化这一步，还有很多很多的事情可以做。但是坦白说，有哪些事情，我也说不出来，但是我觉得用代码再去实现一遍测试过用例，也是一种重复劳动，只是还没有能力把这件事情不重复做，但是相信一定有一些办法，有一些方面是可以解决的。\n如果从上面的角度说，自动化的范围太广了，能做的事情太多了，会了接口自动化，UI自动化算什么呢？\n什么是技术？技术难道就是写代码吗？把测试用例代码化吗？ 个人觉得技术包括的范围也很广，不止是写代码，不仅仅是测试用例代码化，这些都只是技术的一块。讨论起代码来兴致很高，觉得技术含量很高，讨论起业务来，没有一点情绪。但是如果仔细想想，像一个会计问题，一个交易问题，一个合规问题，这些是业务，但是不也是技术吗？这些只要是专业问题，这些就也是技术的一种，就像你专业写代码，这些不能理解为计算机科学的业务吗？如果是这样的话，那有什么非要区分业务和技术的？放在现实中来说，业务就是处理实际问题的技术，代码就是解决计算机如何运行的技术，不是吗？既然是这样的化，那么问问自己业务了解的透彻了，各个流程节点了解透彻了吗？技术实现和业务的匹配对应关系了解透彻了？代码说到底只是一个产品成功的一部分，还有很多很多其他问题需要解决,如果非要说代码能占到产品上线或者成功的多少比例？或许50%都不到. 代码本身不是目的，实际业务问题才是。不用非要拘泥与代码，各种方式解决了业务问题，也是很有技术含量的。\n自动化测试就是测试的技术？ 自动化测试只是测试的一种技术, 决定你有没有价值的不是你用了什么技术手段，是你解决了什么问题。代码，自动化测试也只是测试的一个侧面，想想日常工作中有多少事情要处理，如果眼里只有自动化测试，那么是不是失去了很多其他方面的锻炼和成长。问问自己把问题说清楚了吗，问问自己 做到了有效沟通吗，问问自己了解业务吗，问问自己能快速了解需求吗？自动化测试只是那么一小块，需要做的事情还有很多。\n不过自动化测试如果你完全不会，那么现在的行情你肯定是不容易拿到高工资的；但是如果认为只有自动化测试，那么天花板也放在那边,也算给自己的一个提醒吧。\n","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/3_hu3d03a01dcc18bc5be0e67db3d8d209a6_2036528_650x0_resize_q90_box.jpeg","permalink":"/blog/qa-traps/3-tech-is-all/","title":"测试陷阱3-自动化测试就是测试的技术"},{"categories":null,"contents":"测试永远都很忙，忙着回归测试，忙着各种各样的测试，各种各样的交付，但是这样忙碌了3年左右之后， 你发现你在确实是进步了，进步的主要方面我想大部分就是以下几个方面:\n 沟通能力增强了 业务熟悉了非常多，开发测试流程熟悉了很多 处理紧急事情能力提高了很多  这已经很不错，可能有些测试同样的过了三年这些进步都没有，更多的在听指令，别人说测试就是做测试。\n但是又过了三年，那些快速进步的测试，发现貌似和前面三年的进步比起来，这三年的进步幅度没有那么明显了, 以前你没有办法参与决策，现在还是一样没有办法参与决策，这三年做的事情貌似没有太多变化，可能可以带 1，2个人进行测试，做的事情和以前又本质的区别吗？于是反思自己，到底哪方面还有欠缺，造成了这几年进步不大？ 答案往往就是可能是技术方面还不够，那么就想加强技术吧。于是越来越焦虑，主要发现看了1个月一门语法，结果1个星期没有用， 都忘了；忙碌的工作让三个月一转眼就过了，回顾一下，发现貌似什么变化的没有发生？怎么办？再过三年还是和现在一样？怎么办， 一会就过30了，外面35岁的人就不要了，我怎么办？ 焦虑自然就越来越多了。\n这个问题我觉得没有答案，但是我只想说，说到底，技术提高是需要资源的，而时间是一个重要的资源，如果你在最初的三年提高很快， 那么我想学习能力这个资源你是不缺的，但是所有的提高都需要你的时间资源，而你自己的时间资源管理起来了吗？你把它用到一些你认为非常重要，但是可能又不是马上要做的事情上吗？你如果这么回头一看，我相信你可能1天1个小时时间都没有花到你认为很重要的事情上面。\n焦虑每个人都有，但是怎么应对，怎么解决自己的问题才是关键。\n如何应对焦虑 焦虑是要克服的，往往自我要求高的人越焦虑，对于如果应对焦虑，我觉得可以从下面两个方面想：\n 努力会有结果，我假设这个是对的，但是可能短期(2-3)年有时不对的。 我觉得可以举一个很好的例子来说明,下面是巴菲特投资收益曲线  如果只看这个曲线的1-2年，我觉得一定有人比他的投资收益更高的，但是如果你放到40年这个维度，那么很明显每人比他高。 这我觉得就是一个很好的例子来说明，可能短期进步没有自己预期高。放到生活工作中，如果1年你比别人多进步20%，那么你就一定比别人多20%的工资吗？我觉得未必，但是如果你连续5年都比别人进步了20%，那么我想你一定比其他人的工资高的，也许没有2倍，但是高20-30%我觉得还是非常大机会的，如果以后5年持续高30%，那么你收益也不错。\n 每个人不放弃追求自己的极限，但也要明白自己一定有上限的  每个人一定都有自己的上限，无论你相不相信，他都在那里，所以不如问问自己尽力了吗？不问自己最终会在什么位置，问问现在想要做点什么可能会化解一定的焦虑，焦虑是越想越焦虑，但是越做会越少点。一方面做事情会减少一些想的时间，另外一方面焦虑的解决办法不在你想了多少，而是你做了什么，解决了那些你焦虑的地方。\n有些一时解决不了，那么想想每个人都有上限这半句话，如果有些能解决，那么多想想，多认可一下不放弃追求自己极限这句话。\n重要而不紧急的事情可能决定了你的上限 回到测试人员焦虑，没有时间提高自己想要提高的东西，时间是你想要提高的重要的资源，那么时间管理上面有一个重要的4象限： 如果你自己把你实际的事情填到这个象限里面，你发现你要提高的东西都是在重要不紧急这块，但是如果你统计一下你的时间，你 发现其实一天1个小时都做不到？这就是你觉得没有提高的很重要的原因，你想提高，但是没有去做，所以越来越焦虑。\n这个四个象限里面其实最重要的是花在重要不紧急上面的时间，你投入了，你就有回报，你就比一般人厉害些，就像上学时候有种书到用时方恨少的感觉，这个感觉就是你没有在重要不紧急的上面没有投入时间，没有积累，你的上限就是那么多，这个是毫无疑问的！\n说起来自然容易，但是做起来确实难，时间从哪里来，比如每天1个小时？对于测试人员来说，所谓技术，最短期的一个目标可能就是编程代码能力，当然21天可以熟练使用一门语言，但是你一年下来合计有21天时间投入在这个上面吗？每天1小时，一年365个小时，365/24其实都没有21天。一天1小时都不够21天，那更不要说你没有花这么多时间了。所以事情其实很清楚了，焦虑的原因不是你笨，而是你没做，不是吗？学习一门语言，不算很难，但也不是没有难度，熟练使用，21天是不够的(很多人骂21天精通XXXX，就是这个道理).能够坚持每天1个小时是最大的难度之一，遇到问题自己想办法解决，坚持遇到一个解决一个，坚持3个多月，我觉得你一定会觉得有些不一样的。\n很多人也会说学了又会怎么样呢？你马上涨工资吗？这个问题我觉得你可以回头看看巴菲特收益曲线。 很多说我学不下去，主要没有地方练手？那么就找地方练手 很多说我不想学这个，这个不是我的方向？那么就不做了\n如果想要做，那么我觉得，练手我觉得对于测试来说有大量大量的机会做，小到如果有python处理insert语句自动生成，合并一些 excel，或者批量修改文件名等等，这些都可以练手，所以简单又重复的事情都可以练，只是你没有想到.\nThere is a will, there is a way! 不过是不是学会了编程技能了，就一定就是提高了呢？这是个问题，但是每一个阶段都有每一个阶段的问题，多一门技能，你可能看到更多的东西，看的更远一些，这个我觉得是一定的！\n","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/2_hu5d7f2b2bd715738a59a7e1a524ceeb2c_26295_650x0_resize_q90_box.jpeg","permalink":"/blog/qa-traps/2-things-matter/","title":"测试陷阱2-永远都在忙碌重要紧急的事情"},{"categories":null,"contents":"对于大部分的初级测试人员来说，有时放弃怀疑可能在工作中陷入一些被动，甚至让自己的生活有时也会搞得一团乱. 下面我从一个加班事件说起，看看我们如果应对一些突发的情况.\n从一个加班事件说起 事情的由来是这样的,由于某种原因，一个功能只能在生产环境测试，于是测试同学自己觉得这个功能简单，就预估半天时间就可以测试完成。结果呢？由于各种配置问题，上了生产主流程都不通，然后一通检查，最后从上午一直到到晚上10点的时候发现需要的一个第三方账户权限设置错误，造成功能不同，然后在配置修改完了之后，再进行测试，结果弄到凌晨结束。从这个事情来看，完全从功能角度看，其实可能确实只要半天时间，但是这个功能又有很多依赖关系，而这些依赖关系确花了比实际测试更长的时间，而真正造成这些时间的问题确从来没有去怀疑过。于是班加了，结果其实还不太好，对外看来为什么会到最后才发现这些问题？为什么事前没有计划，为什么到最后主流程还不通？为什么从来没有人提出过这个里面可能的风险？\n怀疑不等于不相信，怀疑是想确认 我事后分析了一下，有一点就是测试同学早早的放弃了怀疑，放弃怀疑了两个地方:\n 这些配置问题在开发过程中就会被发现？ 因为开发承诺会测试 这些功能很简单，就没有去深究这里面的依赖关系，这些总会有人去搞定的  首先我想明确的一点是，怀疑不等于不相信，这个共识是需要团队达成的. 怀疑是想对事情本身的确认，而不是对开发人员的怀疑，有了这个基本共识，我觉得测试人员就应该多提问题，多怀疑，把怀疑的点变成实际放生的事实，把要做确没有做的事情落实，这样才能减少突发情况，才可以少加点班。遗憾的事，即使发生了这样的事情，大多数的测试人员还是会轻而易举的接受这样的事实，听开发人员一解释说是运营人没有告诉他账户设置，造成了此次问题，这样就过去了，我想这样的事情以后还是会发生。因为再一次的放弃了怀疑，根据发生的事情，一定程度上是可以推导将来发生的事情的，比如很明显，这么一件事情看出来:\n 开发没有做任何自测，因为如果自测，那么一定可以老早就发现这个问题了 开发喜欢推卸了一定的责任，这个事情的关键点不是谁没有把账号告诉别人，而是为什么这样的事情到最后才发现 事实上做这个功能基本上没有做任何的调研，如果做了调研就一定会知道需要什么账户的，不是吗？那以后怎么做调研？ 真的只能生产了才可以测试吗？实际情况不是多申请一个第三方账户就可以在测试环境测试了吗？如果测试了不是应该老早就发现账户配置的问题了吗？就算只有一个账户，产生的测试数据可以删除吗？  如果测试不通过事实去怀疑一些，有了怀疑又去确认一些事情，那么处在开发环节的最下游，太多的不确定性都变成自己来承担，种种压力，种种加班就会都来；到最后没有太多人会帮到你，因为到了最后一旦出了点问题，就可能变成了大问题，就可能被老板追责了。\n事后还是要把怀疑的点落实 事情既然已经发生了，还好没有出现延期之类的事情，但是如果就这么过了，可能以后还是一样会发生这样的情况。 所以测试人员还应该把你认为出现这次情况的怀疑点提炼出来，比如：\n 开发你自测了？是一个人没有自测还是所有人没有自测？ 为什么只能在生产环境测试？这个调研工作真的做的彻底了吗？ 为什么一开始不知道会是账号的问题？为什么定位这个问题要这么就？调研工作做的彻底了吗？ 下次调研要这么做呢？调研了什么东西，什么结论要让相关人员知道吗？ 测试估算时间的时候，真的了解了这些功能的依赖了吗？真的知道如果才能在生产环境把功能全部跑通的所有条件了吗？  这些问题什么时候解决呢？会解决吗？如果没有解决是不是后面我可以直接想老板反馈呢？这些都是合理的怀疑，不是去怀疑个人，而是有了事实之后，测试要去确认的点，过程是很辛苦，但是如果真能做到，那么这个测试在团队里面不会变得可有可无；你做的事情变成了对完全对发布负责，那么你有理由获得更多的信任。但是如果你就让这样的事情轻易通过，那么后面会有更多离奇事发生。\n行千里路，半900 行千里路，半900；所以如果没有把很多的事情落实，没有去怀疑去确认实际落实的情况，那么预估的时间往往都过于乐观了。过于乐观的估计，往往造成时间紧张，时间紧张又意味出现容易出错。所以不妨把事情放到台面说\n","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-traps/1-no-doubt/","title":"测试陷阱1 - 放弃怀疑"},{"categories":null,"contents":" 以下是关于TDD的小结，我个人的感受是：\n 如果这个实践做的事情只是想知道那些接口出现了变动，那么可能通过代码review或者沟通是更好的方式，为了得到这个目的感觉要做的事情有点多 技术自然是很厉害，但是团队是不是沟通上面出现问题了？难道都不愿意到连改了什么，影响什么都不想说了   ","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/1-tdd-way/","title":"QE-Meetup： TDD 小结"},{"categories":null,"contents":"或许是在充满巨大不确定性的情况下，或许是在敏捷开发的情况下，放养开发管理变得越来越多.陆陆续续经历了一些公司，项目，发现几乎是一个共性.\n我相信放养式开发管理是个中性词，没有好和坏，更多的是适合不适合. 一个词在不同的环境下，反应的情况是不一样的。\n放养式开发管理 - 一个成功的例子 如果在一个开发个人能力突出，严谨，负责，功能能力强的团队，放养式开发管理可以介绍很多不太需要的沟通成本，大家相互信任，对于共同的期望值有足够的默契，这是没有什么问题的， 这样的团队我也在其中过，那是一个非常棒的体验， 理性，克制，坦诚，一个目标，各司其职，而且都能完成的很好。但是如果我回头看看以前的这个团队的成员，每个人5年后发展，总共4个人，一个P8，一个高级经理了，一个资深架构了，一个创业当老板了。有时会感慨，这是一个什么团队.\n这其实是个放养的团队，这个团队的事情现在回想起来还是如此的生动。苦活脏活也干，比如手动对比上千份PDF文档；技术难度高的活也做，比如修改apache 开源代码替换商业软件，提升很高的性能. 但是这些都是因为这个团队足够自驱，足够成熟，并且也并没有把KPI想的那么严重，只是相信比原来好，KPI就不会差.\n放养式开发管理 - 不那么成功的大多数 从这个团队出来之后，陆陆续续遇到的一些放养式开发管理，遇到的问题，其实大体一样，就是不可控的实现方式。\n什么叫不可控的实现方式？ 其实就是实现某个功能，你完全不能控制具体实现的方式，这些实现方式往往和技术Leader的想法差别很大，以为是这样的，往往变成不知道的一个什么情况；时间久了，技术债务越堆越多,以后变成难以维护.\n也想过这些原因，个人觉得原因可能如下:\n 现在公司中的项目很多都是具有巨大不确定性，所以开发人员对他的预期其实是很模糊的，那么做到什么程度大家其实是没有一致的共识的 团队成员结构，很多其实很奇怪，一个Leader级别非常高，然后其他人很多可能都是1，2年的新手，这些新手完成功能可能还可以，但是如果说的实现的好坏，视野和品味就不够了，都觉的自己的实现好，但是其实还没有办法进行全面客观的评价了 团队对于项目技术和工程实现上没有预期，就是没有要求；所以自然做到哪里算哪里，怎么做当然也就无所谓了；但是问题是，团队需要锻炼，成员需要培养，如果不从一点一点的小项目的实战中锻炼，哪里来的提高呢？ 从哪里去选拔中间层呢？ 团队成员自驱和自我学习的能力并没有那么强，其实这才是普通团队的情况，你能遇到一个团队里面每个人都自驱，自省，自我学习能力强，这个其实也是基本非常难的；所以如果都是放养式管理，很显然是不合适的 管理能力，不是所有leader有管理能力，所以放养式是一个好办法，所谓结果导向吧，但是结果呢？当然怎么看待这个结果的事情，从我的角度看，技术团队业务贡献产出和技术工程能力都需要看，但是大部分主要还是看业务产出了，那么很明显，放养式管理是个好选择，因为管理人员不需要耗费很大的精力去培养，锻炼，只需要下个命令就可以了，但是技术和工程方面呢？  如果一个技术团队对于技术和工程上没有期望值，大体上，慢慢的，项目和团队就会变得越来越难。\n","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/3-let-it-be/","title":"放养式开发管理"},{"categories":null,"contents":"做决定，负责任,并不容易.\n测试工作，决定，负责任 为什么突然想起这个做决定，负责任的话题？因为日常工作中，我慢慢发现很多很多的开发同学不喜欢做决定，明明很多事情再我看来可以下决定，却非要请示上级，而每一次的请示有时会有很长一个等待时间，而有时这个等待时间往往在下班前后，叫人下班也不是，不下班也不是，只能单纯的等待请示结果.\n举个实际的例子来说，下班前的我们测试说测试完成了，可以上线了。然后负责这个功能的开发就是准备上线，问运维什么是否可以今天上线？运维回答说明天可以上线吗？开发马上把问题给了他老板，让他老板同不同意？而他的老板由于出差，等了三个多小时才回复可以介绍今天不上线。\n这个只是一件事情，但是我遇到过不少类似的事情。 我不能说这样的事情有什么大的不对，但是有时细细想想，十分不是滋味。\n为什么呢？首先这个时候支持开发上线的测试和运维中间这三个小时是下班好还是不下班好？第二个问题，为什么开发不知道老板对这个事情的期望，事实上老板的期望的时间并不是当天晚上就一定要上线.\n那么对于这件事情来说，我对我们测试人员的要求就是:\n 计划: 确定和同步所有人对于上线时间点的预期，让所有人都知道什么时候上线，什么时候开始做准备，如果需要在非工作时间上线，那么提前说明，兄弟部门不是不愿意加班，而是不愿意莫名其妙的加班 应对变化: 如果上线出现了点意料之外的情况，那么首先判断的是是不是非要今天上线这个时间点上线，匆忙中有没有额外的风险；如果不是，那就换到明天稳妥的时间段上线，生产的稳定一定是比其他东西更重要的；不管是从KPI的角度来说，你上线一个充满着不确定的新功能而造成生产事故，这是丢了西瓜捡了芝麻的事情 一定要有决定，无论上线还是不上线，一定要下决定，判断的依据其实就是，是不是事先已经计划好了，是不是重要的非要带着重大的风险上线，是不是需要所有部门都要加班支持你的程度？每个部门都有自己重要的事情，凡事不能到滥用的地步  ","date":"October 7, 2020","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/2-decision-making/","title":"做决定，负责任"},{"categories":["Bug"],"contents":"Bug 描述 lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项 步骤:\n 进入首页，选择地区上海，关键字输入软件测试 待搜索结果显示之后，工作经验选择为应届毕业生 所有结果出现后，取消应届的选择，不能再回退到工作经验的选项   期望结果: 取消应届选择后，回退到有工作经验的所有选项 疑问: 这是一个Bug吗？还是产品经理的一个设计? 有方便的地方，也有不方便的地方，如果测试人员不知道这个需求,你要怎么处理这个事情?  ","date":"October 7, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/bugs/lagou/","title":"lagou PC版搜索选项工作经验选择应届后，取消应届后，不能返回原来的工作经验选项"},{"categories":null,"contents":" 什么是质量文化 测试/QA质量文化建设  内建质量 质量外延    测试过程中的常见问题 这些都是测试过程中的常见问题，但是其实都不容易解决.为什么不容易解决，主要问题：\n 测试中发现的问题往往比较零散,不容易总结 这些问题的解决往往短期内看不到直接效果，是一个系统工程 项目可能都是短期的，谁会在意长期的事情？ 出现问题方可以把所有的问题都指向测试，而自身的压力会不自觉的减轻，但是无论如何转移责任并不会解决问题 测试压力很大，但是有时问题大到测试没有能力解决了  关于质量的建设有以下几个需要事先了解的:\n 没有数据根本无从说起 没有对比就没有改进 质量是个长期工作,长期艰苦枯燥的工作 没太多人愿意做长期枯燥的工作，但是公司实际上是需要的 质量是系统工程，需要系统参与不是只有QA一个部门 质量不止靠 QA 角色兜底的意识/工作方式，只靠测试QA是可以转移责任，但是不能解决问题 发现问题同样重要，QA虽然不能直接解决问题，但是他能让更高层对于工程能力,产品能力有更全面的认识；只听到好话的公司，也是危险的，更高层如果只听到好话，并且真的认为很好，那会造成很多的误判，是不负责任的轻信 没有经过验证的进度，可能都是虚假的进度，会造成资源的错误估计  内建质量 研发，产品，QA，设计，数据分析师,市场每个角色都会对最终产品形态有直接影响。\n流程: 没有检查点的内建质量流程都是虚假的:\n软件开发中的检查点:\n 编译通过打包，静态代码扫等基准能力 单元测试通过 单元测试覆盖率通过 功能测试通过 需求验收通过(UAT通过)  软件开发总体的评估：\n 线上问题故障 线上问题解决时间SLA 提测准入测试通过率 提测后严重Bug比例 工程能力评估: 环境构建能力/CI/CD能力 工程能力评估: Bug重复修复比例 UAT测试通过率  质量外延 质量的外延是指不是专职质量团队对于产品问题，体验的参与. 这部分包括:\n 外部提出的产品问题是否有闭环来追踪？ 是否会灰度发布环境a/b testing 用户问题解决是否有闭环来追踪？  质量平台建设 质量对于一个公司来说自然是很重要的，但是公司的资源，所处的阶段有不同，对于质量的要求也会不一样，对于质量平台建设自己肤浅的认识主要方向有以下几点:\n 数字化质量，数字化开发过程 让上下游工作的团队对于要求和质量有一个一致的信息 让很多零散的事情聚合在一起，从全局角度看质量问题 发现问题，给问题找到如何闭环的路径 统一质量数据，集成常用采集数据的工具，又能对于特殊采集质量数据的方法开放 尊重不同领域的差异，提供其他领域的经验和建议  ","date":"October 7, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/0-build-in-q/","title":"软件质量文化建设"},{"categories":null,"contents":"Xmind,TestCases and JUnit5 Allure Template Learn from the requirements and write test cases are the common daily work of a tester. Normally write the mind map as a guide of test cases(in internet it is enough), then execute the test cases or write testing codes based on the xmind file(mind map). But do you ever question about this process? It is productive enough? Is there any improvement?\nLet me give an example: I want to test a DateUtil functionality, it has several features, the mindmap like this:\n  DateUtil Test Cases Mindmap:   Then write test codes(your boss required you to write automation codes) using junit and allure:\n  @Epic(\u0026#34;Hutool DateUtil Usage\u0026#34;) @Feature(\u0026#34;Hutool DateUtil Simple Usage\u0026#34;) public class HutoolDateUtilsTest {    @Test  @DisplayName(\u0026#34;DateUtil-Formatter-From Date\u0026#34;)  @Story(value =\u0026#34;Formatter-From Date\u0026#34; )  public void testFrom_Date(){  //write testing codes  }   @Test  @DisplayName(\u0026#34;DateUtil-Formatter-From DateTime\u0026#34;)  @Story(value =\u0026#34;Formatter-From DateTime\u0026#34; )  public void testFrom_DateTime(){  //write testing codes  } } allure is a tool for unified test report. It is worth to use. Two conceptions in allure mapping to requirments:\n EPIC: A big functionality,usally have several small featuers Feature: A relative small functionality, which might have one or more user stories User Story: a small/independent functionality  Writing code is actually transforming the test cases into codes, and labeling the test codes by different test cases names.\nRunning the tests, the report is like:  It is perfect! But don\u0026rsquo;t you think you write test cases twice? In xmind, and in code like @Story bla bla bla \u0026hellip;..\nWhy do I write the annotations like @Story,@Epic or @Feature? The answer is that I want to make a fancy report,but I actually did duplicated work, didn\u0026rsquo;t I? Duplicate work have bad smell. In this case, it looks like you sacrifice your productivity to make report fancy. What if I want both fancy report and productivity? Is it possible to write once? Scripting Boy thought there should be a way.\nBecome a scripting boy to connect these dots Actaully It is not that hard to find a way to achieve the goal: fancy report and productivity both. Let me figure it out:\n Export to test cases in markdown format through xmind(xmind has java/python sdk to manupilate the xmind file, but it is too complex), export is in xmind menu file\u0026gt;export\u0026gt;text:  BTW: importing md file to xmind is in ``file\u0026gt;import\u0026gt;text```\nThe exported markdown file content:\n# DateUtil ## Functions ### isSameDate ### CurrentYear ### CurrentMonth ### CurrentDay Parse the markdown test cases, and render parsed test cases into testing code template It is not hard, there are only three files, and less than 50 lines of codes:   pom.xml for leveraging existing libs   \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.jtwig\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jtwig-core\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;5.87.0.RELEASE\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt;  a junit test code template file in class path(resources folder),named junit_allure_template.twig  import io.qameta.allure.Epic; import io.qameta.allure.Story; import io.qameta.allure.Feature; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.DisplayName; import org.junit.jupiter.api.Test;  @Epic(\u0026#34;{{context.epic}}\u0026#34;) @Feature(\u0026#34;{{context.epic}}\u0026#34;) public class {{context.epic}}Test {   {% for entry in context.features.entrySet() %}  {% for feature in entry.value() %}  @Test  @DisplayName(\u0026#34;{{context.epic}}-{{feature.desc}}\u0026#34;)  @Story(value =\u0026#34;{{feature.desc}}\u0026#34; )  public void test{{feature.name}}(){  //write testing codes  }  {% endfor %}  {% endfor %} }  50 lines of codes, to read the exported markdown file, and render the template junit_allure_template.twig  public class Junit5TestTemplateGenerator {   public static void generateJunit5TC(String mdFile,String fileName) throws IOException {  AllureTestModel allureTestModel = new AllureTestModel();  List\u0026lt;String\u0026gt; mdContent= Resources.readLines(Resources.getResource(mdFile),Charsets.UTF_8);   String currentFeature=\u0026#34;\u0026#34;;  for (String line : mdContent) {  if(line.startsWith(\u0026#34;###\u0026#34;)){  AllureFeature feature = new AllureFeature();  feature.setDesc(currentFeature+\u0026#34;-\u0026#34;+line.replace(\u0026#34;###\u0026#34;,\u0026#34;\u0026#34;).trim());  feature.setName(line.replace(\u0026#34;###\u0026#34;,\u0026#34;\u0026#34;).trim().replace(\u0026#34; \u0026#34;,\u0026#34;_\u0026#34;));  allureTestModel.features.get(currentFeature).add(feature);  }else if(line.startsWith(\u0026#34;##\u0026#34;)){  currentFeature = line.replace(\u0026#34;##\u0026#34;,\u0026#34;\u0026#34;).trim();  allureTestModel.features.putIfAbsent(currentFeature,new ArrayList\u0026lt;\u0026gt;());  }else if(line.startsWith(\u0026#34;#\u0026#34;)){  allureTestModel.setEpic(line.replace(\u0026#34;#\u0026#34;,\u0026#34;\u0026#34;).trim());  }  }   JtwigTemplate template = JtwigTemplate.classpathTemplate(\u0026#34;junit_allure_template.twig\u0026#34;);  JtwigModel model = JtwigModel.newModel().with(\u0026#34;context\u0026#34;,allureTestModel);  template.render(model,new FileOutputStream(new File(fileName+\u0026#34;.java\u0026#34;)));  }   @Data  public static class AllureTestModel{  private String epic;  private Map\u0026lt;String,List\u0026lt;AllureFeature\u0026gt;\u0026gt; features = new HashMap\u0026lt;\u0026gt;();  }   @Data  public static class AllureFeature{  private String name;  private String desc;  }  public static void main(String[] args) throws IOException {  Junit5TestTemplateGenerator.generateJunit5TC(\u0026#34;DateUtil.md\u0026#34;,\u0026#34;HutoolDateUtilTest.java\u0026#34;);   } } And the result is:\n@Epic(\u0026#34;Hutool DateUtil Usage\u0026#34;) @Feature(\u0026#34;Hutool DateUtil Simple Usage\u0026#34;) public class HutoolDateUtilsTest {  @Test  @DisplayName(\u0026#34;DateUtil-Formatter-From Date\u0026#34;)  @Story(value =\u0026#34;Formatter-From Date\u0026#34; )  public void testFrom_Date(){  //write testing codes  }   @Test  @DisplayName(\u0026#34;DateUtil-Formatter-From DateTime\u0026#34;)  @Story(value =\u0026#34;Formatter-From DateTime\u0026#34; )  public void testFrom_DateTime(){  //write testing codes  }  ...... } which is same as your writing before.\nScripting boy is not kidding you, use a JAVA template lib to make both fancy report and test cases real without duplicated work.\nIt is not perfect solution which I need to admit. But it works somehow, and save my time anyway. It also demostrated that there are plenty opportunities to tester to practice coding skills, to know a little bit more about other libaries. It is not about rocket science, not about make a fancy product, it is just about practicing day in and day out to make life a little bit easier than before.\nWhat\u0026rsquo;s next? It looks good, not why not write it as a plugin of a modern ide like intellj IDEA. Wait, Wait, I am a scripting boy, try to make a product? But Why not? And why not support more templates like testng or other testing framework? See you next time!\nReference Code  github  ","date":"August 7, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/1-junit5casetesttemplate/","title":"Xmind,Test Cases,and Allure templates for TDD"},{"categories":null,"contents":"There is a question over my head several times. is it real hard for tester to write test codes? I don\u0026rsquo;t know, but I just want to do a task to evaluate this conclusion.\nStart From The End I don\u0026rsquo;t prefer the term automation testing, but like the term write testing codes. Automation testing is almost defined as failure in most of testers\u0026rsquo;s mind(not company, company still think it is valuable). As I known, many testers(a big portion actually) just think automation testing is a political job which actually has no value at all in reality. Most of the automation cases are never used after it passed one time. Almost in every testing meet-up, there is always someone talked about test platform,how good it is,how easy to use. But in reality,almost every test platform user complained the test platform is to hard to use. Why? and what\u0026rsquo;s the gap between those platform and their users.\nI don\u0026rsquo;t know. But I just believe automation testing will never happen if you never write codes, only doing configuration like coding. Write scripts should be a basic skill for tester, like eating or drinking.\nAnd in other hands, setting a high expectation in a short period of time which is way beyond the average tester\u0026rsquo;s coding skill. There are too much legacy debit out there. High expectation meets even high debit, it can easily crash you. The delayed schedule, the unreachable target, and voices like automation testing doesn\u0026rsquo;t work is just around you. Finally, you will find out automation never from nowhere, it happened when you write codes line by line just. And if you re-think about automation, it is quite reasonable. It is just like a product which want to automate business flow. The product is built by tons of codes. So does automation testing. And also to pay back the debit, accumulate codes in daily basis in the key. Don\u0026rsquo;t expected to pay back it in a short time, just focus accumulating the tests day in and day out, then someday, you will feel a little easy.\nBack to the topic, What the task is given to myself is that:\n Write A Simple Integration Libs as a tiny testing framework(just work) in 2-3 days Leverage Existing Libs as more as possible, and don\u0026rsquo;t write too much complex codes Integration library, not a http library. It is open for different component client The test codes could be used in any other place,but not only for testing Not strict, different coding level can use and ramp up  Let\u0026rsquo;s getting start Think about integration testing(not consider UI), it is actually calling different service or api, then get a result to verify. And if in more complex workflow, it looks like a workflow or api call chain So I need to abstract these into following conception:\n Executor: execute the who process no matter how many steps the test case should have Client: every api/service invoker is a client, no matter http,redis,database or whatever tester used in daily basis for send a request to get a response Validator: verify the result TestCase: test cases with test case data and steps  Executor - Integration Executor Integration Executor is used to run the whole test case, and it is the core of this tiny lib, it targets to connect all the things used when testing.\nLet\u0026rsquo;s do following things to implement it:\n define the test case data structure implement a generic client implement a extractor to extract data from response implement a validator to validate result implement a context to store and calculate runtime data when execute test cases  Client The client implement is for generic purpose, so I just define a callable object or with a invoke method:\nclass Client:   def __init__(self, params, env):  self.params = params  self.env = env   def invoke(self):  \u0026#34;\u0026#34;\u0026#34; what ever :return: ClientResponse \u0026#34;\u0026#34;\u0026#34;  raise NotImplementedError(\u0026#34;abstract class, need an implementation\u0026#34;)   def __call__(self, *args, **kwargs):  print(\u0026#34;client should a callable object or with a invoke method\u0026#34;)  return self.invoke()  and the response for a client also need to be unified and generic:  class ClientResponse():   def __init__(self, response):  pass  So basically I defined a generic client which the input is :   params: input test data env: target environment   Output is:  ClientReponse: Generic Output Object, which have a status code and response data, data should be in json or dict which is easy to handle\nA http client is implement based on python requests lib:\nhttp_methods = {   \u0026#34;get\u0026#34;: requests.get,  \u0026#34;post\u0026#34;: requests.post,  \u0026#34;delete\u0026#34;: requests.delete,  \u0026#34;put\u0026#34;: requests.put,  \u0026#34;option\u0026#34;: requests.options }  class HttpClient(Client):  req_url = \u0026#34;\u0026#34;  domain = \u0026#34;\u0026#34;  headers = {  \u0026#34;accept\u0026#34;: \u0026#34;application/json\u0026#34;,  \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;  }  req_body = {} ## make sure the some variables with default values  query_params = []  method = \u0026#34;post\u0026#34;   def __init__(self, params, env):  super().__init__(params, env)   def invoke(self):  real_req_url = self.__build_request_url()  self.__build_header()  self.__build_body()  http_method = http_methods.get(self.method.lower(), requests.get)  response = http_method(url=real_req_url, headers=self.headers, data=self.req_body)  return make_client_response(response)   def __build_request_url(self):  if self.env.get_config_by_key(self.domain) is None:  raise ClientException(\u0026#34;domain name should be set in environment or config file\u0026#34;)  else:  url = self.env.get_config_by_key(self.domain)   real_req_url = url + self.__make_request_path() + self.__make_query_url()  return real_req_url   def __build_header(self):  if self.params.get(\u0026#34;headers\u0026#34;, \u0026#34;\u0026#34;) != \u0026#34;\u0026#34;:  for h_name, h_value in self.params.get(\u0026#34;headers\u0026#34;).items():  self.headers.update({h_name: h_value})   def __make_request_path(self):  self.req_url = self.req_url.format(**self.params)  return self.req_url   ## todo: set value in a dict,use path  def __build_body(self):  for param_name, param_value in self.params.items():  kv_util.set_value(self.req_body, param_name, param_value)   def __make_query_url(self):  query_url = \u0026#34;\u0026#34;  if len(self.query_params) \u0026gt; 0:  query_url = query_url + \u0026#34;?\u0026#34;  # query_temp =\u0026#34;%s=%s\u0026amp;\u0026#34;  for query_param in self.query_params:  if self.params.get(query_param, \u0026#34;\u0026#34;) != \u0026#34;\u0026#34;:  query_url = query_url + query_param + \u0026#34;=\u0026#34; + self.params.get(query_param, \u0026#34;\u0026#34;) + \u0026#34;\u0026amp;\u0026#34;  return query_url Don\u0026rsquo;t invent any new thing, just use requests\nExtractor First of all, why I need an extractor? The extractor is used to get a value from a json or dict by an expression like jsonpath. So that we can leverage this tiny tool to get any value in response.\nThe demo:\nsimple_dict_json = {  \u0026#34;characters\u0026#34;: {  \u0026#34;Lonestar\u0026#34;: {  \u0026#34;id\u0026#34;: 55923,  \u0026#34;role\u0026#34;: \u0026#34;renegade\u0026#34;,  \u0026#34;items\u0026#34;: [  \u0026#34;space winnebago\u0026#34;,  \u0026#34;leather jacket\u0026#34;  ]  },  \u0026#34;Barfolomew\u0026#34;: {  \u0026#34;id\u0026#34;: 55924,  \u0026#34;role\u0026#34;: \u0026#34;mawg\u0026#34;,  \u0026#34;items\u0026#34;: [  \u0026#34;peanut butter jar\u0026#34;,  \u0026#34;waggy tail\u0026#34;  ]  },  \u0026#34;Dark Helmet\u0026#34;: {  \u0026#34;id\u0026#34;: 99999,  \u0026#34;role\u0026#34;: \u0026#34;Good is dumb\u0026#34;,  \u0026#34;items\u0026#34;: [  \u0026#34;Shwartz\u0026#34;,  \u0026#34;helmet\u0026#34;  ]  },  \u0026#34;Skroob\u0026#34;: {  \u0026#34;id\u0026#34;: 12345,  \u0026#34;role\u0026#34;: \u0026#34;Spaceballs CEO\u0026#34;,  \u0026#34;items\u0026#34;: [  \u0026#34;luggage\u0026#34;  ]  }  } }  # encoding: utf-8 class TestDataExtractor:  def test_list_get_value_by_exp(self):  result = data_extractor.get_value_by_exp(simple_dict_json, \u0026#34;characters\u0026#34;)  assert len(result) \u0026gt;= 1   def test_get_value_by_exp(self):  result = data_extractor.get_value_by_exp(simple_dict_json, \u0026#34;characters.Lonestar.items[0]\u0026#34;)  assert result == \u0026#34;space winnebago\u0026#34;   def test_get_value_by_exp_not_exist(self):  result = data_extractor.get_value_by_exp(simple_dict_json, \u0026#34;characters.Lonestar323.items[0]\u0026#34;)  assert result == \u0026#34;space winnebago\u0026#34; just give a path expression, then get the value without going to a json level by level.\nDon\u0026rsquo;t invent new thing: the implementation is relied on following lib:\n jmespath dictor  Validator Validator is used to validate if an actually result meets the expected result.\nAlso, refer to the assertPy, I did a function to validate result:\nThe Demo:\nclass TestValidator():   def test_demos(self):  result = validator.validate(\u0026#34;value\u0026#34;,\u0026#34;is_equal_to test\u0026#34;)  assert result[0],\u0026#34;fail\u0026#34;  print(str(result[1])) Test Case Test Case is to connect all these things to feed into Integration Runner\nThe Basic Schema is :\n {  \u0026#34;test_cases\u0026#34;: [{  \u0026#34;name\u0026#34;: \u0026#34;tc description\u0026#34;,  \u0026#34;tc_id\u0026#34;: \u0026#34;testCaseId\u0026#34;,  \u0026#34;steps\u0026#34;: [  {  \u0026#34;name\u0026#34;: \u0026#34;http get api\u0026#34;,  \u0026#34;precondition\u0026#34;: {},  \u0026#34;service\u0026#34;: HttpBinGet,  \u0026#34;params\u0026#34;: {},  \u0026#34;post_action\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;args\u0026#34;: \u0026#34;args\u0026#34;},  \u0026#34;verification\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;is_equal_to http://httpbin.org\u0026#34;}  },  {  \u0026#34;name\u0026#34;: \u0026#34;http post api\u0026#34;,  \u0026#34;precondition\u0026#34;: {},  \u0026#34;service\u0026#34;: HttpBinPOST,  \u0026#34;params\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;{{args}}\u0026#34;},  \u0026#34;post_action\u0026#34;: {},  \u0026#34;verification\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;is_equal_to http://httpbin.org\u0026#34;, \u0026#34;json\u0026#34;: \u0026#34;is_none\u0026#34;}  }  ]  }] } The schema is easy to understand. The service is for a Python Object, here HttpBinGet is an api for call HttpBinGet service, and the service is also easy to implement.\nclass HttpBinGet(HttpClient):  req_url = \u0026#34;/get\u0026#34;  domain = \u0026#34;domain\u0026#34;  headers = {  \u0026#34;accept\u0026#34;: \u0026#34;application/json\u0026#34;,  \u0026#34;content-type\u0026#34;: \u0026#34;application/json\u0026#34;  }  req_body = {} ## make sure the some variables with default values  query_params = []  method = \u0026#34;GET\u0026#34; Context Context is used for store and calculate data. It will be used in executor in process pre-condition and post action to handler.\nWhat data context stored in key-value manner, for example:\nin test case data:\n \u0026#34;post_action\u0026#34;: {\u0026#34;url1\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;args1\u0026#34;: \u0026#34;args\u0026#34;} the post action processor will put url1 as key, the value is the value extracted by the path \u0026ldquo;url\u0026rdquo; from response\nand also, the context will used to render data in process pre-condition, because some input data is in generated in runtime:\n\u0026#34;params\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;{{args}}\u0026#34;} {{args}} will be replaced by a value which is from response before. Use python template lib jinja2 can achieve it.\nRevisit Executor Now every tiny thing is ready for Executor. And everything is ready.\nFor Detail please refer the demo.\n","date":"July 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/0-start-from-the-end/","title":"Implement A Integration Testing Libs in two days"},{"categories":null,"contents":"Last chapter introduce how to build a test framework in two days, In this chapter, let\u0026rsquo;s do demos:\n A Api TestCase Api Chain Test Case Pre-Condition And Verification Render to use context data  A Api TestCase Here are two cases:\n after call HttpBin API, check the url field in response is http://httpbin.org  \u0026#34;verification\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;is_equal_to http://httpbin.org\u0026#34;} after call HttpBin API, check the headers.Accept field in response is application/json1  The overall cases is:\n{  \u0026#34;test_cases\u0026#34;: [{  \u0026#34;name\u0026#34;: \u0026#34;getapi-tc-1\u0026#34;,  \u0026#34;tc_id\u0026#34;: \u0026#34;tc-get-1\u0026#34;,  \u0026#34;steps\u0026#34;: [  {  \u0026#34;name\u0026#34;: \u0026#34;http get api\u0026#34;,  \u0026#34;precondition\u0026#34;: {},  \u0026#34;service\u0026#34;: HttpBinGet,  \u0026#34;params\u0026#34;: {},  \u0026#34;verification\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;is_equal_to http://httpbin.org\u0026#34;}  }  ]}  ,{  \u0026#34;name\u0026#34;: \u0026#34;getapi-tc-21\u0026#34;,  \u0026#34;tc_id\u0026#34;: \u0026#34;tc-get-2\u0026#34;,  \u0026#34;steps\u0026#34;: [  {  \u0026#34;name\u0026#34;: \u0026#34;http get api\u0026#34;,  \u0026#34;precondition\u0026#34;: {},  \u0026#34;service\u0026#34;: HttpBinGet,  \u0026#34;params\u0026#34;: {},  \u0026#34;verification\u0026#34;: {\u0026#34;headers.Accept\u0026#34;: \u0026#34;is_equal_to application/json1\u0026#34;}  }  ]}   ] } and the demo codes are:\n@allure.epic(\u0026#34;testing http bin test cases\u0026#34;) class TestHttpBinTestCase:   @allure.feature(\u0026#34;testing http bin get\u0026#34;)  def test_httpbin_get(self):  runner = IntegrationExecutor(httpbinget_testcases)  result = runner.run()  assert result.get_tc_result() == \u0026#34;pass\u0026#34; Api Chain Test Case test cases:\n{  \u0026#34;test_cases\u0026#34;: [{  \u0026#34;name\u0026#34;: \u0026#34;tc description\u0026#34;,  \u0026#34;tc_id\u0026#34;: \u0026#34;testCaseId\u0026#34;,  \u0026#34;steps\u0026#34;: [  {  \u0026#34;name\u0026#34;: \u0026#34;http get api\u0026#34;,  \u0026#34;precondition\u0026#34;: {},  \u0026#34;service\u0026#34;: HttpBinGet,  \u0026#34;params\u0026#34;: {},  \u0026#34;post_action\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;url\u0026#34;, \u0026#34;args\u0026#34;: \u0026#34;args\u0026#34;},  \u0026#34;verification\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;is_equal_to http://httpbin.org\u0026#34;}  },  {  \u0026#34;name\u0026#34;: \u0026#34;http post api\u0026#34;,  \u0026#34;precondition\u0026#34;: {},  \u0026#34;service\u0026#34;: HttpBinPOST,  \u0026#34;params\u0026#34;: {},  \u0026#34;post_action\u0026#34;: {},  \u0026#34;verification\u0026#34;: {\u0026#34;url\u0026#34;: \u0026#34;is_equal_to http://httpbin.org\u0026#34;}  }  ]  }] } @allure.epic(\u0026#34;testing http bin test cases\u0026#34;) class TestHttpBinTestCase:   @allure.feature(\u0026#34;testing http bin get/post\u0026#34;)  def test_httpbin_tc(self):  runner = IntegrationExecutor(httpbin_testcases)  result = runner.run()  assert result.get_tc_result() == \u0026#34;pass\u0026#34; the test cases code is almost same.\nPre-Condition And Verification Render to use context data This case is more complex, use pre-condition, post-action, and verficiation to checkout how the context processing.\nWe have two Api:\n /json api to get a json, in this api\u0026rsquo;s response, there is a author field, value is \u0026ldquo;Yours Truly\u0026rdquo; /cookies/set api is to query a value by query parameter freeform  So assume there is a workflow in real business:\n call /json to get author then use the author name to query(call /cookie./set) some author properties  The author name might be changed over time in different environment, so I have to call the api first in step 1, then getting the author name as the second api\u0026rsquo;s input, finally call the second api then verify the result .\nSo the example test cases is:\n  Case 1: Use Context and Render Input and Verifications   Case2: Use jinja2 built-in filter to handle parameters in test cases\n  and again, there is no re-invention, just use the exiting jinja2 template\n","date":"July 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/1-demo-testcase/","title":"Integration-Runner Test Case Demo"},{"categories":null,"contents":"Two Steps:\n Run Test Code with code coverage - Right click the test class, select run *** with code coverage  Check the Code Coverage in intelli idea    Line Code Covearge/Method Coverage   Read marked as not covered lines, green as covered lines   ","date":"July 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/3-inteljidea-codecoverage/","title":"Using IntelljIdea For Code Coverage"},{"categories":null,"contents":"Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.\nThe Risk Engine is in the middle of the whole system, The upstream and downstream modules leverage the result of the Risk Engine by API call in their own business flow. When other modules\u0026rsquo;s tester want to execute their test cases, they often wanted to get the different risk engine results on demand. That means I needed to support them for their cases as I am the owner of risk engine. Everyday, I was interrupted serveral times. It really bothered me a lot. I can\u0026rsquo;t refuse, but need to find a solution. Then the easiest mock came.\nMock- Get What You Set! It is quite simple but it is worth to write because it represents the value of codes which a tester can implement. I implemented a new WebService in our repo, and used a Map to store what the client set for mocking purpose. Then next API call against the setting URL, the response is what the client Set even without any deployment or restart.\nHow can I achieve this? The most important thing is that we used the configuration center - Apollo. But does this mean in real case? You never need to restart the server for changing application properties. It makes things easier. The whole process was that:\n Setup Mock by calling: *** http://domain/mock/A/setup *** Change the Risk Engine Url to *** http://domain/mock/A/getMock *** in Apollo Portal Deploy the changes Other modules\u0026rsquo; QA now can control the Risk Engine Response for any cases. And even more, this actually can be applied to any other Http service to decouple modules,free my time, and keep me focusing  Here is the simple codes.It only takes 10 minutes to complete, but it saved me a lot of time in daily basis.\n GenericMockStore for store Mock   @Component @Profile(\u0026#34;test\u0026#34;) public class GenericMockMemStore {   private ConcurrentHashMap\u0026lt;String, Object\u0026gt; mockStore = new ConcurrentHashMap\u0026lt;\u0026gt;();   public void saveMock(String key, Object value) {  this.mockStore.put(key, value);  }   public Object getMock(String key) {  return this.mockStore.get(key);  }  }  GenericMock Service  @RestController @RequestMapping(\u0026#34;/mock\u0026#34;) @Profile(\u0026#34;test\u0026#34;) public class GenericMockController {   @Autowired  private GenericMockMemStore mockMemStore;   @RequestMapping(\u0026#34;/{productName}/setup\u0026#34;)  @PostMapping  public MockSetupResponse setupMock(@RequestBody GenericMockResponse setupResponse,  @PathVariable String productName,  HttpServletRequest request){   mockMemStore.saveMock(productName,setupResponse);  return MockSetupResponse.success();  }   @RequestMapping(value = \u0026#34;/{productName}/getMock\u0026#34;,method = {RequestMethod.GET,  RequestMethod.POST,RequestMethod.PUT})  public Object getMock(@PathVariable String productName,  HttpServletRequest request){   return mockMemStore.getMock(productName);  } } Here is an explaination for these codes:\n Two APIs:  POST /mock/{productName}/setup for setup mock for the productName you set /mock/{productName}/getMock get the mock reponse which set previously   GenericMockMemStore: Store the mocks by key: productName in memory  Like I said before, the automation testing is not about automation, but about writing codes for testing,and productivity. Automation is a conception, not an action. It is too big to accomplish. But Writing codes is actionable, and you can see what you accomplished and what you improved immediately.\nAnd also know the infrastructure more, you will find the solution is in the upstream or low level. This is a tip I used when I tested this project. Luckly it worked. But still it is not a perfect solution, there are qeustions over here:\n Is there any pain point to improve? How to make it happen? Don\u0026rsquo;t write any code, use exisitng tools like YAPI, can we achieve the same?  Maybe you can find your answer, or stay tuned, I will write a post later.\nFinally It is honor to make these codes in the develop official repos.\n","date":"July 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/4-productivity-simplemock/","title":"The Easiest Mock, The highest ROI"},{"categories":null,"contents":"Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.\nThe Risk Engine is in the middle of the whole system, The upstream and downstream modules leverage the result of the Risk Engine by API call in their own business flow. When other modules\u0026rsquo;s tester want to execute their test cases, they often wanted to get the different risk engine results on demand. That means I needed to support them for their cases as I am the owner of risk engine. Everyday, I was interrupted serveral times. It really bothered me a lot. I can\u0026rsquo;t refuse, but need to find a solution. Then the easiest mock came.\nMock- Get What You Set! It is quite simple but it is worth to write because it represents the value of codes which a tester can implement. I implemented a new WebService in our repo, and used a Map to store what the client set for mocking purpose. Then next API call against the setting URL, the response is what the client Set even without any deployment or restart.\nHow can I achieve this? The most important thing is that we used the configuration center - Apollo. But does this mean in real case? You never need to restart the server for changing application properties. It makes things easier. The whole process was that:\n Setup Mock by calling: *** http://domain/mock/A/setup *** Change the Risk Engine Url to *** http://domain/mock/A/getMock *** in Apollo Portal Deploy the changes Other modules\u0026rsquo; QA now can control the Risk Engine Response for any cases. And even more, this actually can be applied to any other Http service to decouple modules,free my time, and keep me focusing  Here is the simple codes.It only takes 10 minutes to complete, but it saved me a lot of time in daily basis.\n GenericMockStore for store Mock   @Component @Profile(\u0026#34;test\u0026#34;) public class GenericMockMemStore {   private ConcurrentHashMap\u0026lt;String, Object\u0026gt; mockStore = new ConcurrentHashMap\u0026lt;\u0026gt;();   public void saveMock(String key, Object value) {  this.mockStore.put(key, value);  }   public Object getMock(String key) {  return this.mockStore.get(key);  }  }  GenericMock Service  @RestController @RequestMapping(\u0026#34;/mock\u0026#34;) @Profile(\u0026#34;test\u0026#34;) public class GenericMockController {   @Autowired  private GenericMockMemStore mockMemStore;   @RequestMapping(\u0026#34;/{productName}/setup\u0026#34;)  @PostMapping  public MockSetupResponse setupMock(@RequestBody GenericMockResponse setupResponse,  @PathVariable String productName,  HttpServletRequest request){   mockMemStore.saveMock(productName,setupResponse);  return MockSetupResponse.success();  }   @RequestMapping(value = \u0026#34;/{productName}/getMock\u0026#34;,method = {RequestMethod.GET,  RequestMethod.POST,RequestMethod.PUT})  public Object getMock(@PathVariable String productName,  HttpServletRequest request){   return mockMemStore.getMock(productName);  } } Here is an explaination for these codes:\n Two APIs:  POST /mock/{productName}/setup for setup mock for the productName you set /mock/{productName}/getMock get the mock reponse which set previously   GenericMockMemStore: Store the mocks by key: productName in memory  Like I said before, the automation testing is not about automation, but about writing codes for testing,and productivity. Automation is a conception, not an action. It is too big to accomplish. But Writing codes is actionable, and you can see what you accomplished and what you improved immediately.\nAnd also know the infrastructure more, you will find the solution is in the upstream or low level. This is a tip I used when I tested this project. Luckly it worked. But still it is not a perfect solution, there are qeustions over here:\n Is there any pain point to improve? How to make it happen? Don\u0026rsquo;t write any code, use exisitng tools like YAPI, can we achieve the same?  Maybe you can find your answer, or stay tuned, I will write a post later.\nFinally It is honor to make these codes in the develop official repos.\n","date":"July 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/4-productivity-simplemock/","title":"The Easiest Mock, The highest ROI"},{"categories":null,"contents":"Actually it is not about how to test Rule Based Risk Engine, it is about how to use simple codes to improve the daily productivities.\nThe Risk Engine is in the middle of the whole system, The upstream and downstream modules leverage the result of the Risk Engine by API call in their own business flow. When other modules\u0026rsquo;s tester want to execute their test cases, they often wanted to get the different risk engine results on demand. That means I needed to support them for their cases as I am the owner of risk engine. Everyday, I was interrupted serveral times. It really bothered me a lot. I can\u0026rsquo;t refuse, but need to find a solution. Then the easiest mock came.\nMock- Get What You Set! It is quite simple but it is worth to write because it represents the value of codes which a tester can implement. I implemented a new WebService in our repo, and used a Map to store what the client set for mocking purpose. Then next API call against the setting URL, the response is what the client Set even without any deployment or restart.\nHow can I achieve this? The most important thing is that we used the configuration center - Apollo. But does this mean in real case? You never need to restart the server for changing application properties. It makes things easier. The whole process was that:\n Setup Mock by calling: http://domain/mock/A/setup Change the Risk Engine Url to http://domain/mock/A/getMock in Apollo Portal Deploy the changes Other modules\u0026rsquo; QA now can control the Risk Engine Response for any cases. And even more, this actually can be applied to any other Http service to decouple modules,free my time, and keep me focusing  Here is the simple codes.It only takes 10 minutes to complete, but it saved me a lot of time in daily basis.\n GenericMockStore for store Mock  @Component @Profile(\u0026#34;test\u0026#34;) public class GenericMockMemStore {   private ConcurrentHashMap\u0026lt;String, Object\u0026gt; mockStore = new ConcurrentHashMap\u0026lt;\u0026gt;();   public void saveMock(String key, Object value) {  this.mockStore.put(key, value);  }   public Object getMock(String key) {  return this.mockStore.get(key);  }  }  GenericMock Service  @RestController @RequestMapping(\u0026#34;/mock\u0026#34;) @Profile(\u0026#34;test\u0026#34;) public class GenericMockController {   @Autowire  private GenericMockMemStore mockMemStore;   @RequestMapping(\u0026#34;/{productName}/setup\u0026#34;)  @PostMapping  public MockSetupResponse setupMock(@RequestBody GenericMockResponse setupResponse,  @PathVariable String productName,  HttpServletRequest request){   mockMemStore.saveMock(productName,setupResponse);  return MockSetupResponse.success();  }   @RequestMapping(value = \u0026#34;/{productName}/getMock\u0026#34;,method = {RequestMethod.GET,  RequestMethod.POST,RequestMethod.PUT})  public Object getMock(@PathVariable String productName,  HttpServletRequest request){   return mockMemStore.getMock(productName);  } } Here is an explaination for these codes:\n Two APIs:  POST /mock/{productName}/setup for setup mock for the productName you set /mock/{productName}/getMock get the mock reponse which set previously   GenericMockMemStore: Store the mocks by key: productName in memory  Like I said before, the automation testing is not about automation, but about writing codes for testing,and productivity. Automation is a conception, not an action. It is too big to accomplish. But Writing codes is actionable, and you can see what you accomplished and what you improved immediately.\nAnd also know the infrastructure more, you will find the solution is in the upstream or low level. This is a tip I used when I tested this project. Luckly it worked. But still it is not a perfect solution, there are qeustions over here:\n Is there any pain point to improve? How to make it happen? Don\u0026rsquo;t write any code, use exisitng tools like YAPI, can we achieve the same?  Maybe you can find your answer, or stay tuned, I will write a post later.\nFinally It is honor to make these codes in the develop official repos.\n","date":"April 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/creditrisk-testing-3/","title":"Rule Based Risk Engine Part 3 - The Easiest Mock, The highest ROI"},{"categories":null,"contents":"Think in Testing 1: Be Tough If someone tell you that software testing or quality assurance is an easy job to do, he/she might not understand what a tester or qa do. There are many perspective a tester or qa involved:\n Testing Requirement Clarification Dev Process/Release Process Planning  Almost every phase QA is involved, it can burn you out easily. Here I just want to talk about some bad thing might happed, and why be tough is a basic charactor of a QA or Tester.\nDon\u0026rsquo;t Be a maid Don\u0026rsquo;t be a maid, and don\u0026rsquo;t spend too much time on other\u0026rsquo;s careless and irresponsibility. Need to fix it.\nIn many Chinese domestic company, Tester and QA is a maid of Developer, everything could be in testing scope. Let me summarize several common cases:\n Some incomplete task, need to test Some codes never work, neet to test Some bug can\u0026rsquo;t be produced, need to test Some performance issues can\u0026rsquo;t be measured, need to test What ever the requirement is, no matter you tester invovled or not, send it to test  And more important thing is that normally a tester/qa might face 5+ developers. If you can not be tough to Dev, your time and career might be spent for taking care of these guys mistakes,careless. Tester/QA is responsible for the product, not for careleass. Yes, your are finding bugs, but what behind these bugs are careless and irresponsibility. You need to fix careless and irresponsibility though it is tough, so be tough.\nWhen a production bug occurred, no one will stand in your side. So you need to exposure the facts, I mean real facts, where these bugs? and Why so many bugs, then you can push to reduce bugs, and push DEV moving forward, otherwise every dirty work will on your shoulder. Does DEV not know Unit test can help quality? They know, Does DEV not know they should tell you a little bit more what a requirement is, because they know you don\u0026rsquo;t invloved at all in first place? They know, explaination is not a techinical work, in their option, it is not worth to do, that\u0026rsquo;s it.\nSo just tell the dev/dev manager what you want, what the result right now, what is good and what is bad, they will learn from that. Dev Manager love to see feedback. Only thing need to pay attention might be the reporting skill, and how to handle conflict.\nBe a maid is no future in tech world, no one really care about what the careless is, they care about the careless issue should be never happened. You can\u0026rsquo;t only spend time for others careless, you need to fix it for the root cause. Good Luck, and we tester have long way to go, be tough!\nShow the Data,Metrics Show the data, metrics is good to be professional, and just focus on the thing your team are talked about, not finger point. It can help you be tough and reasonable. But What kind data you can show? It is a question, and also hard to implement. Based on my experience, data like:\n How many Bugs in a sprint? How the bugs distributed? How a typical bug impact the whole process? What the turn around time for the bug or an iteration?  It is hard to collect data, but it is still worth to collect some of them.\n","date":"April 28, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/4-be-tough/","title":"Think in Testing 1-Be Tough"},{"categories":null,"contents":"What to do is quite obvious:\n Compose input data - Test Case Input  Fundamental Data Third Party And in-house data   Mock the third party and in-house data according test cases Call the Evaluation API to checkout if meet the expectation  And how to write code? I separate into different modules:\n TestCaseLoader: load the whole input parameters DataFactory: Produce different Data as input parameters  RiskInputDataFactory MockDataFactory Some Auto Generated Data Helper for testing purposes   Clients: invoke evaluation api and mock service api  RiskEvaluationClient MockClient   Third Party and In-house Data Feature Manager  Feature Manager   Test Case Runner  TestCase Runner Template    Implement The different Modules - TestCaseLoader TestCaseLoader, levarage easy-poi, it helps you to read/write excel very quickly. For how to use easy-poi, please refer easy-poi\nImplement The different Modules - Datafactory All about handle data, so need some utility class,\n IdCard Generator Generate IDCard through age Generate several ids, like request id Generate Times, such as creditTime  So I just write all these utilities, they are in \nImplement The different Modules - MockDataFactory It is very hard at the beginning, because there is not place to indicate there third party and in-house data name, and also there is big amount of these features.\nFinally I just find out that leverage Dev\u0026rsquo;s codes is the bese option. Do a quick change, and use Spring Class Scanner function do helo me a lot to achieve to mange the third part and in-houce data.\nImplement The different Modules - Clients It is quite simple, just leverage the Okwrap client.\nImplement The different Modules - TestRunner TestRunnerTemplate\n Before Run After  ","date":"April 25, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/creditrisk-testing-2/","title":"Rule Based Risk Engine Part 2 - Write Code to Test"},{"categories":null,"contents":"This article introduces a real world case for testing a rule based risk engine. Let me separate it into several parts:\n System Overview to introduct the rule based risk engine Typical Cases Automate the test cases, and how ?  1. Rule Based Risk Engine System Overview This is my fist risk engine project. I am not sure how other risk engine does,just try to introduce what I experienced, and what I had found.\nLet\u0026rsquo;s start with what this module does. In short, this risk engine provides a capability to rate a loan applicant from whethere he/she is eligible for a loan to how much he/she can borrow. So There are two major results:\n is eligible? And what the score/credit amount/terms for this applicant  And there are different products to apply, so the rule and rating system should be configurable. There are rule engine,scorecard and decision tree components to meet the configuration needs.\nThe whole workflow is like this:\nThe whole system is a decision flow, which includes anti-fraud rules, score-card for rating and decision tree to make a decision. If you wanto unify it, it is a decision flow, which composed by rules and decision trees.\n1.1 A short introduction for Rule Engine Rule Engine article from Martin Flow, it abstracts rule engine into three conceptions:\n Condition Action Chain  Basically A rule includes conditons and actions, and the chain composites these rules\u0026rsquo; conditions and actions by a runtime context.\nAn example in this blog for explaination:\nif car.owner.hasCellPhone then premium += 100; if car.model.theftRating \u0026gt; 4 then premium += 200; if car.owner.livesInDodgyArea \u0026amp;\u0026amp; car.model.theftRating \u0026gt; 2 then premium += 300; if is condition, and then is action, one rule is composed by one if and one then . And the chain is composed by different rules. Obviously the premium should be in the chain context in this case, because it passed through the whole rule sets.\nQuite simple and easy to understand.The single rule is simple enough, so the testing might be undervalued. Think about if there are hundrends rules out there, test and understand the whole picture might be not easy compared with a single rule. This is what Martin Flow claimed, and also he worried about the implicit rule and context in the rule engine module.\nThe Rule Risk Engine I meet was simillar to what mentioned in this blog. The difference is that it has wight point for socre card and decision tree modules. In this system, a rule is A node which contains:\n Expressions for evaluating an input data A Weight for a rule Composite Rule for Weight Point to make different disicion Also this Node points a true or false path to go different evaluation path  What ever these nodes contain, just think about it is a chain or composite rule. Here is a simple case to demostrate how the system works:\nThe output is a score. A score represents how much could be borrowed in a loan system. In this simple case, the age might be a implicit feature which should be fetched by internal api based on fundamental data like IDCard Number or SSN Number. And the rules and score card rules are pre-defined(So it is ruled based system).\nSo you can understand the whole module in this way:\n Featch all relative data for the rules based on the fundamental information, these relative data need to be mocked because I can\u0026rsquo;t control what third party api returned, while tests need to controll what the thrid party api should return as an input variable. Go through all the rule nodes, evaluate the result and the score to get a conclusion which indicates eliable for a loan, and how much could be borrowed.  So the modules should aim at how to fetch the data(facts) , and how to go through the rule engine to calculate a score. And so does this module.\n1.2 Rule Based Risk Engine Components Here are components:\nThere are many different tech stack used, such as elastic search, mongodb, hbase, redis,spring boot, rule engine,etc. It is hard to test in my first impression, not only it is complex, but also I only had one week to understand the whole system, and I am the only person who is responsoible for testing, meanwhile there are actual 7 developers out there.\nLearn it,separate the concerns, and then check out what these components really do:\n Third Party Service : Fetch Data,it calls different third party services to get some risk relative values like what the income level of an applicant, is there any loans, is there any overdue during the past one year,etc. Then provide these data to rule engine as facts(so called risk features) Data Aggeragation Service: Fetch Data from in-house data warehouse,aggeragating in house data to provide to rule engine as facts/risk features Data Collection Service: Fetch Data,simillar too, collect different in house data to provide to rule engin as facts/risk features Rule Engine: Rules Engine,process the risk evaluation to figure out eligable result and risk rating result Rule Tracing: supplement component, tracing every rule evalution result for debug to error diagose Risk Evaluation Store: supplement component,store rule evealution result rule tracing, risk result store, these are supplement components, they may be important later but not now because this is a rule engine system for a startup department, just starting to accomulate the risk data  After dive into these components a little bit, It is easy to find out that the key critical component is the Rule engine in current stage which shoule be absolutely the priority. Other components are more like data collector/feeder or result recorder. They should be important if the volumn of users increased,or more features need to be produced. But on current stage,it is just a MVP product which try to validate if the idea is feasible.\nThe more things need to do, the more I need to focus a critical componet. So I focused the Rule Engine first.\n1.3 Rule Engine Typical Cases The rule engine typical cases is that: The things turn out that, rule engine accepts income risk input, and leverage all the different data from third party/data collection/data aggeragation services, then output the risk rating.\nLet me summary it in a tester point view, rule engine\u0026rsquo;s input is different data, and the output is the data calculated by the rules. If the rule composed by rules,and decision tree, the test cases covered all the node and path, then it is good to go.\n1.4 Test It Let\u0026rsquo;s see a test case first:\nTest Case Input:\n{  \u0026#34;riskFeatures\u0026#34;: {  \u0026#34;idNumber\u0026#34;: \u0026#34;610304199801120878\u0026#34;,  \u0026#34;levelType\u0026#34;: \u0026#34;10\u0026#34;,  \u0026#34;flowNo\u0026#34;: \u0026#34;1506\u0026#34;,  \u0026#34;applicationId\u0026#34;: \u0026#34;ac8e120c-3615-4bdb-a92d-a118e24e33da\u0026#34;  } } I can change the levelType to different value, then send to risk evaluation api to get different result. And this is typical test cases design.\nTesting a Rule steps:\n change the risk input date call risk evaluation api get result and check the result  It looks very easy. The problem is how many these kind of parameters are? In a real case, normally 50+ parameters need to change because the third party data are aslo the input of rule engine which I can\u0026rsquo;t control it only mock it as input implicit parameters. So it is going to be crazy if create and maintain these test cases manually.\nThere third part data is like: The best case for 50 parameters test cases design, every parameters has 3 possible values, then at least there are 150 cases(doesn\u0026rsquo;t consider the combination).\nManual testing is not a option under this condition if the business need to complete all the testing in one day, also it will burn me out if do these testing more than one time.\nSo the only option is to write code to test(I don\u0026rsquo;t like the term automation testing, I prefer the term write codes for testing).\nLet\u0026rsquo;s start coding. Coding is not rocket science, don\u0026rsquo;t be afraid of it especially for testers. In next article, how to implement the test code will be introduced. It is not that hard but improve the productivity significantly. One more point is that it might be more interesting than do it manually in this case.\n","date":"April 23, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/creditrisk-testing-1/","title":"Rule Based Risk Engine Testing Part 1- Background"},{"categories":null,"contents":"Build API Testing Framework-1 - Learn Http Api API now, in most cases, it is a HTTP API which over http protocol. It is hard to explain without a example, so let\u0026rsquo;s start with a HelloWorld API sample. The main purposes of these apis are to do the CRUD(Create/Read/Update/Delete) against the resouce HelloWorld. Here are HTTP Methods mapping to CRUD:\n   HTTP Method CRUD Resource Response     GET Read /HelloWorld/{id} 200:success/404: not found   POST Create /HelloWorld 200:success/404: not found   Update Update /HelloWorld/{id} 200:success/404: not found   Delete Delete /HelloWorld/{id} 200:success/404: not found    It is easy to implement a sets of APIs against resource HelloWorld based on SpringBoot, here comes demo codes:\n@RestController public class HelloWorldController {   @GetMapping(\u0026#34;/HelloWorld/{id}\u0026#34;)  public BaseResponse getHelloWorld(@PathVariable Long id) {  return BaseResponse.OK().data(HelloWorldDTO.builder().id(id).msg(\u0026#34;Hello World\u0026#34;).build());   }    @PostMapping(\u0026#34;/HelloWorld\u0026#34;)  public BaseResponse\u0026lt;HelloWorldDTO\u0026gt; createHelloWorld(@RequestBody HelloWorldDTO requestBody) {  return BaseResponse.OK().data(requestBody);  }   @PutMapping(\u0026#34;/HelloWorld/{id}\u0026#34;)  public BaseResponse\u0026lt;HelloWorldDTO\u0026gt; updateHelloWorld(@PathVariable Long id, @RequestBody HelloWorldDTO updateData) {   return BaseResponse.OK().data(updateData);  }   @DeleteMapping(\u0026#34;/HelloWorld/{id}\u0026#34;)  public BaseResponse\u0026lt;HelloWorldDTO\u0026gt; deleteHelloWorld(@PathVariable Long id) {  return BaseResponse.OK().data(HelloWorldDTO.builder().id(id).msg(\u0026#34;deleted!\u0026#34;).build());  } } Start the web server, actaully there are 4 apis with different HTTP methods, GET/DELETE/POST/PUT, use postman to check what happened:\nIt represents how the api work, and how to use postman to invoke the http api to get a result.\nSo the api testing is simple, a client send a http request, then get the http response to check if the response is correct.\nIn this case, if you want to start a api automation testing, what kind of codes need to write? In this case, it is very simple:\n A clint to invoke http api: Client Data builder to build input data: InputData Verify the response: OutputData  the code example generated bu postman(java and OkHttpClient) is :\nOkHttpClient client = new OkHttpClient();  MediaType mediaType = MediaType.parse(\u0026#34;application/json\u0026#34;); RequestBody body = RequestBody.create(mediaType, \u0026#34;{\\\u0026#34;msg\\\u0026#34;:123}\u0026#34;); Request request = new Request.Builder()  .url(\u0026#34;http://localhost:9090/HelloWorld\u0026#34;)  .post(body)  .addHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)  .addHeader(\u0026#34;cache-control\u0026#34;, \u0026#34;no-cache\u0026#34;)  .addHeader(\u0026#34;Postman-Token\u0026#34;, \u0026#34;ac6e83d3-8446-4ae7-81ea-59316ca5cce7\u0026#34;)  .build();  Response response = client.newCall(request).execute(); Copy these codes, and run in maven project, your first API automation code is completed.\nBy the way, there are several questions for HTTP API:\n What is Idempotent Methods? GET/HEAD/PUT/DELETE are declared idemponten What Option method used for? Is http api stateless? What does the stateless mean? All the information is in the request.  In Next Chapter, let\u0026rsquo;s write code and go through these cases.\n","date":"April 20, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/apitesting-intro/","title":"Build API Testing Framework-1 - Learn Http Api"},{"categories":null,"contents":"Build API Testing Framework-1 - Learn Http Api API now, in most cases, it is a HTTP API which over http protocol. It is hard to explain without a example, so let\u0026rsquo;s start with a HelloWorld API sample. The main purposes of these apis are to do the CRUD(Create/Read/Update/Delete) against the resouce HelloWorld. Here are HTTP Methods mapping to CRUD:\n   HTTP Method CRUD Resource Response     GET Read /HelloWorld/{id} 200:success/404: not found   POST Create /HelloWorld 200:success/404: not found   Update Update /HelloWorld/{id} 200:success/404: not found   Delete Delete /HelloWorld/{id} 200:success/404: not found    It is easy to implement a sets of APIs against resource HelloWorld based on SpringBoot, here comes demo codes:\n@RestController public class HelloWorldController {   @GetMapping(\u0026#34;/HelloWorld/{id}\u0026#34;)  public BaseResponse getHelloWorld(@PathVariable Long id) {  return BaseResponse.OK().data(HelloWorldDTO.builder().id(id).msg(\u0026#34;Hello World\u0026#34;).build());   }    @PostMapping(\u0026#34;/HelloWorld\u0026#34;)  public BaseResponse\u0026lt;HelloWorldDTO\u0026gt; createHelloWorld(@RequestBody HelloWorldDTO requestBody) {  return BaseResponse.OK().data(requestBody);  }   @PutMapping(\u0026#34;/HelloWorld/{id}\u0026#34;)  public BaseResponse\u0026lt;HelloWorldDTO\u0026gt; updateHelloWorld(@PathVariable Long id, @RequestBody HelloWorldDTO updateData) {   return BaseResponse.OK().data(updateData);  }   @DeleteMapping(\u0026#34;/HelloWorld/{id}\u0026#34;)  public BaseResponse\u0026lt;HelloWorldDTO\u0026gt; deleteHelloWorld(@PathVariable Long id) {  return BaseResponse.OK().data(HelloWorldDTO.builder().id(id).msg(\u0026#34;deleted!\u0026#34;).build());  } } Start the web server, actaully there are 4 apis with different HTTP methods, GET/DELETE/POST/PUT, use postman to check what happened:\nIt represents how the api work, and how to use postman to invoke the http api to get a result.\nSo the api testing is simple, a client send a http request, then get the http response to check if the response is correct.\nIn this case, if you want to start a api automation testing, what kind of codes need to write? In this case, it is very simple:\n A clint to invoke http api: Client Data builder to build input data: InputData Verify the response: OutputData  the code example generated bu postman(java and OkHttpClient) is :\nOkHttpClient client = new OkHttpClient();  MediaType mediaType = MediaType.parse(\u0026#34;application/json\u0026#34;); RequestBody body = RequestBody.create(mediaType, \u0026#34;{\\\u0026#34;msg\\\u0026#34;:123}\u0026#34;); Request request = new Request.Builder()  .url(\u0026#34;http://localhost:9090/HelloWorld\u0026#34;)  .post(body)  .addHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;)  .addHeader(\u0026#34;cache-control\u0026#34;, \u0026#34;no-cache\u0026#34;)  .addHeader(\u0026#34;Postman-Token\u0026#34;, \u0026#34;ac6e83d3-8446-4ae7-81ea-59316ca5cce7\u0026#34;)  .build();  Response response = client.newCall(request).execute(); Copy these codes, and run in maven project, your first API automation code is completed.\nBy the way, there are several questions for HTTP API:\n What is Idempotent Methods? GET/HEAD/PUT/DELETE are declared idemponten What Option method used for? Is http api stateless? What does the stateless mean? All the information is in the request.  In Next Chapter, let\u0026rsquo;s write code and go through these cases.\n","date":"April 20, 2019","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/apitesting-intro/","title":"Build API Testing Framework-1 - Learn Http Api"},{"categories":null,"contents":"Think in Testing 1: Be Tough If someone tell you that software testing or quality assurance is an easy job to do, he/she might not understand what a tester or qa do. There are many perspective a tester or qa involved:\n Testing Requirement Clarification Dev Process/Release Process Planning  Almost every phase QA is involved, it can burn you out easily. Here I just want to talk about some bad thing might happed, and why be tough is a basic charactor of a QA or Tester.\nDon\u0026rsquo;t Be a maid Don\u0026rsquo;t be a maid, and don\u0026rsquo;t spend too much time on other\u0026rsquo;s careless and irresponsibility. Need to fix it.\nIn many Chinese domestic company, Tester and QA is a maid of Developer, everything could be in testing scope. Let me summarize several common cases:\n Some incomplete task, need to test Some codes never work, neet to test Some bug can\u0026rsquo;t be produced, need to test Some performance issues can\u0026rsquo;t be measured, need to test What ever the requirement is, no matter you tester invovled or not, send it to test  And more important thing is that normally a tester/qa might face 5+ developers. If you can not be tough to Dev, your time and career might be spent for taking care of these guys mistakes,careless. Tester/QA is responsible for the product, not for careleass. Yes, your are finding bugs, but what behind these bugs are careless and irresponsibility. You need to fix careless and irresponsibility though it is tough, so be tough.\nWhen a production bug occurred, no one will stand in your side. So you need to exposure the facts, I mean real facts, where these bugs? and Why so many bugs, then you can push to reduce bugs, and push DEV moving forward, otherwise every dirty work will on your shoulder. Does DEV not know Unit test can help quality? They know, Does DEV not know they should tell you a little bit more what a requirement is, because they know you don\u0026rsquo;t invloved at all in first place? They know, explaination is not a techinical work, in their option, it is not worth to do, that\u0026rsquo;s it.\nSo just tell the dev/dev manager what you want, what the result right now, what is good and what is bad, they will learn from that. Dev Manager love to see feedback. Only thing need to pay attention might be the reporting skill, and how to handle conflict.\nBe a maid is no future in tech world, no one really care about what the careless is, they care about the careless issue should be never happened. You can\u0026rsquo;t only spend time for others careless, you need to fix it for the root cause. Good Luck, and we tester have long way to go, be tough!\nShow the Data,Metrics Show the data, metrics is good to be professional, and just focus on the thing your team are talked about, not finger point. It can help you be tough and reasonable. But What kind data you can show? It is a question, and also hard to implement. Based on my experience, data like:\n How many Bugs in a sprint? How the bugs distributed? How a typical bug impact the whole process? What the turn around time for the bug or an iteration?  It is hard to collect data, but it is still worth to collect some of them.\n","date":"November 20, 2018","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/thoughts-be-a-touch-tester/","title":"Be Tough as a QA"},{"categories":null,"contents":"Loan Calculation Example  Loan Rule Defintion Installment Calculation Overdue Calculation IRR Calculation  Loan Rule Definition Installments Calculation  repayment-Principal: ROUND(10000/3,2) repayment-interest: ROUND(10000*2%,2)  Advanced Repayment calculation Overall Payment = Current Term Repayment + Remain Principal+ default penalty(10000*1%)\nOverdue Repayment calculation For example:\nLast Term: 4-1 is the repayment day, but actually repayment is occurred in 4-10, then it is default. And the default fee is over your imagination.\n Term1 Default Penalty: ROUND(3333.33*(0.02/30)1.5(60+9),2) Term2 Default Penalty: ROUND(3333.33*(0.02/30)1.5(30+9),2) Term3 Default Penalty: ROUND(3333.34*(0.02/30)1.5(0+9),2)  Don\u0026rsquo;t be default, man!!\nIRR Calculation ","date":"August 13, 2018","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/en/api-testing/loan-calculation/","title":"Loan Calculation Testing"},{"categories":["Performance","Java"],"contents":"以下简单介绍一下如何使用JunitPerf进行性能测试，JunitPerf是基于JUnit4的一个单元性能测试插件，对于会远程调用API测试比较合适，如果想要比较nanosecond 延迟的则需要使用JMH.\nJunitPerf 依赖声明 此例子假设使用MAVEN管理项目，所以在POM文件中添加：\n\u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.github.noconnor\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;junitperf\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;1.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 构建压力测试类 假设你想衡量DemoPerfService 类中的getServiceId方法：\npublic class DemoPerfService {   public String getServiceId(String userId){   return UUID.randomUUID().toString();  } } 那么你可以构建如下的测试类：\npublic class DemoServiceTest {  @Rule  public JUnitPerfRule perfTestRule = new JUnitPerfRule();  DemoPerfService demoPerfService;  @Before  public void setupService(){  this.demoPerfService = new DemoPerfService();  }  @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  public void getServiceId_withoutTestRequirement() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  } 直接运行就可以进行压力测试,默认的测试报告可以在build/reports 目录下获取：\n以下是对于测试类的几点说明：\n   Item 定义说明 Default值或说明     @Rule 申明为JUnit 的Rule类    JUnitPerfRule JUnitPerf 测试规则类    @JunitPerfTest 声明为性能测试方法    threads 测试使用的线程数    durationMs 测试持续时间    warmUpMs 测试热身时间 热身时间的测试数据不会计算进最后的测试结果   maxExecutionsPerSecond 方法执行的上限 RateLimiter，控制TPS上限    对自己的测试设置期望值 使用@JUnitPerfTestRequirement 可以给性能测试设置期望值，这个annotation的属性有:\n   属性 定义     percentits 设置例如90%/95%/50% 响应时间的期望   executionsPerSec 期望每秒执行测试(TPS)   allowedErrorPercentage 允许错误比例   minLatency 期望最小延时，如果实际最小延时超过这个数，则失败   maxLatency 期望最大延时，如果实际最大延时超过这个，则失败   meanLatency 期望中位数延时    下面是使用了JUnitPerfTestRequirement的一个测试方法,需要和@JUnitPerfTest一起使用：\n @JUnitPerfTest 定义了压测的运行参数 @JUnitPerfTestRequirement定义了压测的期望值  具体代码如下例:\n @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  @JUnitPerfTestRequirement(percentiles = \u0026#34;90:7,95:7,98:7,99:8\u0026#34;, executionsPerSec = 10_000, allowedErrorPercentage = 0.10f)  public void getServiceId() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  } 运行之后，如果发现没有满足JUnitPerfTestRequirement定义，则报错:\njava.lang.AssertionError: Test throughput threshold not achieved Expected: is \u0026lt;true\u0026gt;  but: was \u0026lt;false\u0026gt; Expected :is \u0026lt;true\u0026gt; 是不是很简单！\n设置测试报告地址 JUnitPerf 有不同的测试报告，个人觉得HTML的测试报告比较实用，具体只需要:\n@Rule public JUnitPerfRule perfTestRule = new JUnitPerfRule(new HtmlReportGenerator(\u0026#34;perf/report.html\u0026#34;)); 完整的例子 public class DemoServiceTest {  @Rule // public JUnitPerfRule perfTestRule = new JUnitPerfRule(new HtmlReportGenerator(\u0026#34;perf/report.html\u0026#34;));  public JUnitPerfRule perfTestRule = new JUnitPerfRule();  DemoPerfService demoPerfService;  @Before  public void setupService(){  this.demoPerfService = new DemoPerfService();  }   @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  @JUnitPerfTestRequirement(percentiles = \u0026#34;90:7,95:7,98:7,99:8\u0026#34;, executionsPerSec = 10_000, allowedErrorPercentage = 0.10f)  public void getServiceId() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  }   @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  public void getServiceId_withoutTestRequirement() {   String result =demoPerfService.getServiceId(\u0026#34;userid\u0026#34;);  System.out.println(result);  Assert.assertNotNull(result);  } } 最后可以再设定的目录中查看测试报告，测试报告和默认的HTML 测试报告是一致的.\n一点问题 压力测试过程中，有时数据不能复用，举个例子来说，如果想测试完全没有访问redis缓存情况下，通过userid查询的user信息速度，那么压测的时候userid就不能复用，因为一旦访问了就会放入redis缓存而影响结果，这个可以通过使用其他的方法解决，比如曾今使用过BlockingQueue的方法进行过尝试，具体方法如下：\n 读取所有userid的文件 把userid放到一个BlockingQueue中 压测时获取userid通过BlockingQueue去获取  这样就解决了数据不能重复的方法，具体方法可以参考如下代码:\n static BlockingQueue\u0026lt;String\u0026gt; distinctIdQueue ;  @Rule  public JUnitPerfRule perfTestRule =  new JUnitPerfRule(new HtmlReportGenerator(\u0026#34;data/report_test.html\u0026#34;));   @BeforeClass  public static void setupQueue() throws IOException {   distinctIdQueue = new LinkedBlockingQueue\u0026lt;\u0026gt;();  Files.readAllLines(  Paths.get(\u0026#34;data/userid.txt\u0026#34;)  ).parallelStream().forEach(  item-\u0026gt; {  try {  distinctIdQueue.put(item);  } catch (InterruptedException e) {  e.printStackTrace();  }  }  );   }   @Test  @JUnitPerfTest(threads = 50,durationMs = 1200,warmUpMs = 100,maxExecutionsPerSecond = 110)  @JUnitPerfTestRequirement(percentiles = \u0026#34;90:7,95:7,98:7,99:8\u0026#34;, executionsPerSec = 10_000, allowedErrorPercentage = 0.10f)  public void getServiceId() {  String uesrId = distinctIdQueue.take();  String result =demoPerfService.getServiceId(userId);  System.out.println(result);  Assert.assertNotNull(result);  } } ","date":"July 24, 2018","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/junit-perf/","title":"使用JunitPerf进行性能测试"},{"categories":null,"contents":"REST: Representational State Transfer REST 提倡无需Session，每次请求都带上身份认证，同样 REST基于HTTP的也是无状态的.不过REST API的安全性都需要自己实现.REST WEB SERVICE 的核心是RESOURCE(资源).资源可以使用URI来表示，一般REST风格的请求对应关系如下：\n   HTTP 方法 行为 实例     GET 获取资源信息 http://example.com/api/v1/orders   GET 获取某个特定资源信息 http://example.com/api/v1/orders/123   POST 创建新资源 http://example.com/api/v1/orders   PUT 更新资源 http://example.com/api/v1/orders/123   DELTE 删除资源 http://example.com/api/v1/orders/123    对于请求数据一般用jSON或者XMl来表示，一般使用JSON\n身份认证  HTTP Basic HTTP Digest API Key oAuth JWK  HTTP Basic HTTP Basic 其实就看下面例子就可以了:\nbase64编码前:Basic admin:admin base64编码后:Basic YWRtaW46YWRtaW4= 放到Header中:Authorization: Basic YWRtaW46YWRtaW4= API Key API Key 是用户通过身份认证之后服务端给客户端分配一个API Key\n Oauth1.0 Oauth2  JWT: JSON Web Token JWT 是JSON Web Token,用于发送可通过数字签名和认证的东西,它包含一个紧凑的,URL安全的 JSON对象,服务端可通过解析该值来验证是否有操作权限,是否过期等安全性检查。由于其紧凑的特点, 可放在url中或者 HTTP Authorization头中,具体的算法就如下图 授权 身份认证之后就是授权，不同的用户，授予不同的访问权限，如Admin，Normal，Auditor 等.\nHTTPS SSL 重要数据需要通过HTTPS来传输.\n速率限制 根据用户判断某段时间的请求次数，存在内存数据库(redis,memcached),达到最大数即不接受用户的请求。\n X-Rate-Limit-Rest  错误处理  登陆，注册等统一进行记录管理 统一处理如401，403这样的错误 非法参数统一处理  重要的ID不透明处理 如/user/123,如果id是个重要的信息，可以通过对id进行url62,uuid处理\n","date":"April 12, 2016","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/api-testing/rest-api_security/","title":"Rest API Security"},{"categories":["devops"],"contents":"Ansible 介绍 Ansible可以用来帮助IT自动化，关于ansible的一点说明:\nAnsible is a radically simple IT automation platform that makes your applications and systems easier to deploy and maintain. Automate everything from code deployment to network configuration to cloud management, in a language that approaches plain English, using SSH, with no agents to install on remote systems. ansible-docs\nInstallation- 安装 在MAC 上面安装ansible有两种方式：\n python pip  pip install ansible  brew  brew install ansible  install in centos  sudo yum install epel-release sudo yum install ansible -y ansible playbook 的简单使用 ansible的大的框架先跳过，我们通过例子来说明ansible的使用。\n下面简单介绍一个使用ansible的例子：\n  配置hosts文件 在当前目录创建一个hosts文件：\n [jenkins]  192.168.3.50   配置ansible yml playbook文件 配置当前一个yml文件:\n- hosts: jenkins  user: root  accelerate:true  tasks:  - name: restart_nginx  shell: sh /root/auto_publish_qadoc.sh   运行命令\n ansible-playbook playbook.yml -i hosts -vv 就可以运行这些命令了,最简单的ansible就是这样上手非常容易. 不过仔细看看他的帮助文档的话，其实对于python不熟的人还是会有一定难度，不过如果写过程序的人，写过python东西的人来说，其实 过一下这个document估计也就是1天时间就可以上手干活了.\n  Ansible Basic Concept 基本概念 ansible 是一个操作机器的工具,可以通过编排不同的inventory,组合不同的命令来将日常运维的操作 变成可运行的脚本资产,同时也可以积累常用的脚本以便复用.\n下面是关于ansible的一些基础概念的脑图,总体而言ansible包括了以下几个概念：\n inventory: 定义主机,定义操作对象  Host:主机 Group：不同的主机组合成一个组，一个组下面可以有子组，于是就构成了一个树形结构   variable： 变量，主要用来定义对于操作机器时使用的可变参数  Configure hosts for ansible ssh connector  copy ssh key to different hosts  ssh-keygen ssh-copy-id remoteuser@remote.server ssh-keyscan remote.server \u0026gt;\u0026gt; ~/.ssh/known_hosts  check ssh connection  ssh remoteuser@remote.server Done.\nAnsible Ad-hoc Commands ansible 命令的pattern 如下：\nansible \u0026lt;host-pattern\u0026gt; [options] 具体查看ansible 的使用帮助是：\nansible --help ansible ad-hoc command - 检查安装环境 ansible all -m ping -u root ansible ad-hoc command - 执行命令 ansible all -a \u0026#34;/bin/sh echo hello world\u0026#34; ansible ad-hoc command - copy files ansible web -m copy -a \u0026#34;src=/etc/hosts dest=/tmp/hosts\u0026#34; ansible ad-hoc command - yum install ansible web -m yum -a \u0026#34;name=acme state=present\u0026#34; ansible ad-hoc command - add user ansible all -m user -a \u0026#34;name=foo passsword=\u0026lt;crypted password here\u0026gt;\u0026#34; ansible ad-hoc command - download git 包 ansible web -m git -a \u0026#34;repo=git://foo.example.io/repo.git dest=/src/myapp\u0026#34; ansible ad-hoc command - start service ansible web -m service -a \u0026#34;name=httpd state=started\u0026#34; ansible ad-hoc command - 并行运行 ansible web -a \u0026#34;/sbin/reboot\u0026#34; -f 10 ansible ad-hoc command - 查看全部系统信息 ansible all -m setup ansible ad-hoc command 小结 从以上的例子中我们可以看到ansible的命令一般都会使用如下几点：\n module: -m module_args: -a hosts: all/web/\u0026hellip;\u0026hellip;  以上三个组合成为了下面的一个命令：\nansible all -m service -a \u0026#34;name=httpd state=started\u0026#34; 从python的角度看,可以用伪代码的方式:\n def copy(args={}):  for kwarg, v in args.items():  print(\u0026#34;{key}={value}\u0026#34;.format(key=kwarg, value=v))   def test(args={}):  for kwarg, v in args.items():  print(\u0026#34;{key}={value}\u0026#34;.format(key=kwarg, value=v))   module_mapping = {  \u0026#34;copy\u0026#34;: copy,  \u0026#34;test\u0026#34;: test }   def ansible(module, module_args):  func = module_mapping.get(module)  parsed = module_args.split(\u0026#34; \u0026#34;)  args = {}  for module_arg in parsed:  kv = module_arg.split(\u0026#34;=\u0026#34;)  args[kv[0]] = kv[1]  func(args) if __name__ == \u0026#39;__main__\u0026#39;:  ansible(module=\u0026#39;copy\u0026#39;, module_args=\u0026#34;name=name test=test\u0026#34;) mindmap of ansible Ansible 脑图:\nAnsible modules使用介绍 写一个Ansbile Module实际上非常容易，我从看 https://github.com/SeleniumHQ/ansible-selenium.git 这个源码的方式大概可以了解Ansible的一个简单的 插件.\n下面分几个内容来看：\n 插件运行代码 插件的meta的数据  Ansible 插件代码  首先Ansible 插件的入口函数为main函数  所以先定义一个main函数，以及main函数的运行\ndef main():  pass  main()  实现main函数  主要步骤是：\n module定义，Ansible的module，定义这个AnsibleModule的argument_spec,这个里面用来声明这个插件使用的参数 module.params，ansible的输入为task的yml文件，这里面定义的内容都会传递到这个params中 然后根据不同的state的值去调用不同的任务，所有不同的任务的参数都是module，module用来传递了运行时的上下文 实现不同state对应的任务 基本上就结束了一个Ansible插件了   module = AnsibleModule(  argument_spec=dict(  role=dict(choices=[\u0026#39;standalone\u0026#39;, \u0026#39;hub\u0026#39;, \u0026#39;node\u0026#39;], default=\u0026#39;standalone\u0026#39;),  state=dict(choices=[\u0026#39;running\u0026#39;, \u0026#39;stopped\u0026#39;, \u0026#39;restarted\u0026#39;], default=\u0026#39;running\u0026#39;),  version=dict(default=\u0026#39;2.53.0\u0026#39;),  path=dict(default=\u0026#39;.\u0026#39;),  force=dict(default=False, type=\u0026#39;bool\u0026#39;),  args=dict(required=False, default=\u0026#39;\u0026#39;),  java=dict(required=False, default=\u0026#39;/usr/bin/java\u0026#39;),  logfile=dict(required=False, default=\u0026#39;./selenium.log\u0026#39;),  javaargs=dict(required=False, default=[], type=\u0026#39;list\u0026#39;),  ),   supports_check_mode=False,   mutually_exclusive=[]  )   state = module.params[\u0026#39;state\u0026#39;]  role = module.params[\u0026#39;role\u0026#39;]   if state == \u0026#39;running\u0026#39;:  (changed, pid) = start(module)  finish(module, msg=\u0026#39;%sis running\u0026#39; % role, changed=changed, pid=pid)  elif state == \u0026#39;stopped\u0026#39;:  changed = stop(module)  finish(module, msg=\u0026#39;%sis stopped\u0026#39; % role, changed=changed)  elif state == \u0026#39;restarted\u0026#39;:  (changed, pid) = restart(module)  finish(module, msg=\u0026#39;%shas restarted\u0026#39; % role, changed=changed, pid=pid) start 任务的一个例子：\ndef start(module):  \u0026#34;\u0026#34;\u0026#34; Start the Selenium standalone :param module: :return: \u0026#34;\u0026#34;\u0026#34;   _, jar_file = download(module)   changed = False  role = module.params[\u0026#39;role\u0026#39;]  if role != \u0026#39;standalone\u0026#39;:  role = \u0026#34;-role %s\u0026#34; % role  else:  role = \u0026#39;\u0026#39;   if not is_running(module): # in another implementation  changed = True  args = \u0026#39;\u0026#39;  java_args = \u0026#39;\u0026#39;  if module.params[\u0026#39;args\u0026#39;]:  for (k, v) in module.params[\u0026#39;args\u0026#39;].iteritems():  args += \u0026#39;-%s=%s\u0026#39; % (k, v)   if module.params[\u0026#39;javaargs\u0026#39;]:  for arg in module.params[\u0026#39;javaargs\u0026#39;]:  java_args += \u0026#39;-%s\u0026#39; % arg   java_executable = os.path.abspath(os.path.expandvars(module.params[\u0026#39;java\u0026#39;]))  log_file = os.path.abspath(os.path.expandvars(module.params[\u0026#39;logfile\u0026#39;]))   cmd = \u0026#34;%s%s-jar %s%s%s\u0026gt;\u0026gt; %s2\u0026gt;\u0026amp;1 \u0026amp;\u0026#34; % (java_executable,  java_args,  jar_file,  role,  args,  log_file)   os.setsid()   #print cmd  rc = os.system(cmd)   if rc != 0:  abort(module, \u0026#39;Running the %srole returned code %s!\u0026#39; % (role, rc))   pid = get_pid(module)  if pid:  return changed, pid  else:  abort(module, \u0026#39;Couldnt fetch the pid of the running %s! It may have ended abruptly.\u0026#39; % module.params[\u0026#39;role\u0026#39;]) Meta 插件的meta的数据 meta信息一般存放在meta目录中，具体写的方式参考源码:\n https://github.com/SeleniumHQ/ansible-selenium.git  ","date":"March 30, 2016","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/ansible/","title":"Ansible 60分钟入门"},{"categories":["Devops"],"contents":"Jenkins 介绍 Jenkins是一个非常有用的持续集成的工具，可以通过它完成代码的build，测试，发布等一系列的事情.\nFrom Jenkins Home Page\nJenkins is an automation engine with an unparalleled plugin ecosystem to support all of your favorite tools in your delivery pipelines, whether your goal is continuous integration, automated testing, or continuous delivery. Jenkins 使用 关于Jenkins的基本使用网上有很多的教程，基本使用其事没有太多说的，它是个平台，可以集成很多不同的工具，脚本等等. 总结下来这些东西包括：\n jenkins parameter setting, string, choice, \u0026hellip;\u0026hellip; JAVA 的maven, ant, gradle 等打包工具，其他语言也有类似的build，deploy，依赖管理的工具 定制化的脚本，可以在一个Jenkins的build步骤中运行这些脚本如shell命令，python脚本 定制插件来完成自己的特殊的目的  这些内容非常庞大，自己也不可能完全都知道，如果遇到实际的一些问题需要解决的话, 大体的逻辑就是，如果遇到一些特殊需求，那么先去找插件看能不能完成，如果没有插件就再想shell，python脚本等不同的事情，或者自己开发插件.\nJenkins 的实践问题 随着Jenkins里面的任务越来越多，管理的环境越来越多，变更越来愈多，手工管理就会遇到一些问题：\n 比如为了改一个IP地址，可能需要没一个任务都去改具体的配置，比如部署同一个war到不同的测试环境，就需要给不同的job改IP 为了不同的环境配置不同的任务，需要很多的人工的配置修改等等 如果需要迁移一个多应用的测试环境，那么需要很多的复制，修改工作  那么为了解决这些问题，个人觉得可以改善的地方是：\n 定义一些类型项目的模版，抽象一些参数出来给Jenkins里面的Job做参数话，当然有时需要修改的是默认值 在定义了一些模版之后，就可以通过操作Jenkins API的方式来操作 在尝试了一些Jenkins API之后，感觉纯粹通过API的方式去操作，不一定比复制Jenkins 任务，然后修改来的快，但是通过Jenkins API的方式 来操作Jenkins 的好处是，如果这些东西融入到运维的流程中，那么它会提高生产率  一些体会是，可能代码方式的操作单个单个来看不一定会提高多少生产率(参数一样要设)，但是如果放在一个流程的角度看，那么他的效率是高的，比如你如果需要运维帮你建环境，那么你需要提供一些信息，而这些信息就可以直接建立Jenkins的Job了，那么作为用户你只提供一次信息，就可以完成你需要的所有事情，这样效率就高了.\n我对于自动化一切的看法是，也许对于单个任务来说，通过写代码的方式不一定是最优方式，但是如果放在一个流程中来看，那么一定是.所以平常可以积累点不同类型的脚本，代码，然后在某个时间点，也许连接你的这些脚本，代码，就可以流水线化一些你的工作了，不要以为这不会带来，我觉得这一天一定会有的。\nJenkins API 的使用 对于Jenkins API来说，我使用过Java和Python的，总结下来大同小异，逻辑上可以分为几个层次：\n Job: 不同类型的Job  添加，修改，删除Job Job的详细信息 可以通过Job的config.xml文件来修改配置 Job创建属于哪个父类和Jenkins的URL有关系   View 基本功能和Job类似  Jenkins API - JAVA 我自己使用的是这个Jenkins的这个API client.\n \u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;com.offbytwo.jenkins\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jenkins-client\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;0.3.3\u0026lt;/version\u0026gt;  \u0026lt;/dependency\u0026gt; 这个包中最主要的两个类是：\n JenkinsServer: JenkinsServer 可以认为是一个JenkinsHttpClient的一个Wrapper，封装了一些常用的方法，如getJob，getJobXml等等，具体可以参考他github JenkinsHttpClient：可以通过这个HttpClient组装URL和参数来达到完成调用其他API的方法，提供的一些方法主要包括了:  post post_xml: 主要用来修改job的config.xml    大体的东西就是这些，那么通过这个Jenkins的API client，完成了一些一些功能：\n 复制Job,根据参数修改复制出来的Job 复制View，根据参数修改复制出来的View，同时包括了所有的子Job 查询到使用了某个shell 命令或者某个配置的任务  一些实例代码如下：\n复制任务：\npublic class JenkinsReplicator {  private final String COPY_FROM_VIEW_URL = \u0026#34;/view/%s/createItem?\u0026#34;;  private final String DEFAULT_VIEW = \u0026#34;All\u0026#34;;  private JenkinsInstance instance;  private JenkinsHttpClient client;   public JenkinsReplicator(JenkinsInstance instance) {  this.instance = instance;  this.client = instance.getJenkinsHttpClient();  }   /** * @param fromName: copied from issue * @param toName: new Name * @param parentName: to View name */  public void copyItem(String fromName, String toName, String parentName) {  Map\u0026lt;String, String\u0026gt; formData = new HashMap\u0026lt;\u0026gt;();  formData.put(\u0026#34;name\u0026#34;, toName);  formData.put(\u0026#34;mode\u0026#34;, \u0026#34;copy\u0026#34;);  formData.put(\u0026#34;from\u0026#34;, fromName);  formData.put(\u0026#34;json\u0026#34;, String.format(\u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;, \\\u0026#34;mode\\\u0026#34;: \\\u0026#34;copy\\\u0026#34;, \\\u0026#34;from\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;}\u0026#34;, toName, fromName));  formData.put(\u0026#34;Submit\u0026#34;, \u0026#34;OK\u0026#34;);  try {  this.client.post_form(String.format(COPY_FROM_VIEW_URL, parentName), formData, false);  } catch (IOException e) {  throw new JenkinsBaseException(\u0026#34;copy item \u0026#34;+ fromName+ \u0026#34;to \u0026#34; + toName+\u0026#34; in view \u0026#34; + parentName + \u0026#34; failed\u0026#34;, e);  }  } } update config file:\nString configXml = jobDescription.jobConfigXml(); this.getJenkins().updateJob(jobDescription.getJobName(),configXml,false); 复制整个view下面同时包括了不同的子Job:\n@Override  public View copy(String fromName, String toName, String parentNameOrNull) {  View fromView = getByName(fromName);  if (fromView == null) throw new JenkinsViewException(fromName + \u0026#34;view is not found,can\u0026#39;t copy from it!\u0026#34;);  View toView = getOrCreate(toName, fromName, parentNameOrNull);  Map\u0026lt;String, Job\u0026gt; viewJobs = jobController.getJobsByViewName(fromName);  for (Map.Entry\u0026lt;String, Job\u0026gt; entry : viewJobs.entrySet()) {  jobController.copy(entry.getKey(), toName + \u0026#34;_\u0026#34; + entry.getKey(), toView.getName());  }   return getByName(toName);  } Python API 使用 Python的Jenkins API client 可以通过以下命令安装：\n pip install jenkinsapi 基本的python jenkins api client 和JAVA的概念比较类似，不过python 的这个jenkinsapi很明显要比java的这个客户端功能要丰富的多的多，后面会详细介绍这个python client api的使用.\n代码 GITHUB\n","date":"March 30, 2016","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2016-03-30-jenkins_basic/","title":"Jenkins API的简单介绍"},{"categories":["DevTips"],"contents":"由于一直都在进行测试的工作，所以会关注Assertion的工具，发现两个不错的Assertion 第三方包，准备在实践中使用. 这两个分别是：\n Google Truth(http://google.github.io/truth/usage/) assertj  这个里面有很多自己想实现的比较的功能。一下是一些简单的试用的代码。\nGoogle Truth 基础的验证：\n@Test  public void test_basic_truth(){  Set\u0026lt;String\u0026gt; foo = Sets.newHashSet();  assertThat(foo).isEmpty();  assertThat(foo).isNotNull();  assertThat(5).isEqualTo(5L);  assertThat(5L).isEqualTo(5);  assert_().that(50).isEqualTo(50);  assertThat(\u0026#34;test\u0026#34;).isEqualTo(\u0026#34;test\u0026#34;);  assertThat(\u0026#34;test\u0026#34;).contains(\u0026#34;te\u0026#34;);  } Collections/Maps的验证:\n@Test  public void test_basic_truth_maps_collections(){  Set\u0026lt;String\u0026gt; foo = Sets.newHashSet();  assertThat(foo).isEmpty();  assertThat(foo).isNotNull();  foo.add(\u0026#34;test\u0026#34;);  foo.add(\u0026#34;test1\u0026#34;);  foo.add(\u0026#34;test2\u0026#34;);  assertThat(foo).contains(\u0026#34;test\u0026#34;);  assertThat(foo).containsAllOf(\u0026#34;test\u0026#34;, \u0026#34;test1\u0026#34;);  assertThat(foo).containsExactly(\u0026#34;test2\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;test1\u0026#34;);  assertThat(foo).containsNoneOf(\u0026#34;test889\u0026#34;, \u0026#34;test10\u0026#34;);   Map\u0026lt;String,String\u0026gt; maps = Maps.newHashMap();  maps.put(\u0026#34;test\u0026#34;, \u0026#34;test1\u0026#34;);  maps.put(\u0026#34;test1\u0026#34;, \u0026#34;test2\u0026#34;);  maps.put(\u0026#34;test2\u0026#34;, \u0026#34;test3\u0026#34;);  assertThat(maps).containsKey(\u0026#34;test1\u0026#34;);  assertThat(maps).containsEntry(\u0026#34;test1\u0026#34;, \u0026#34;test2\u0026#34;);  assertThat(maps).doesNotContainEntry(\u0026#34;test0\u0026#34;, \u0026#34;test0\u0026#34;);  } assertj 基础的验证：\n@Test  public void test_contains(){  assertThat(\u0026#34;aaa\u0026#34;).contains(\u0026#34;aa\u0026#34;);  }   @Test  public void test_list_contains(){  List\u0026lt;String\u0026gt; result = Lists.newArrayList(\u0026#34;abcd\u0026#34;,\u0026#34;ddds\u0026#34;,\u0026#34;ttest\u0026#34;);  assertThat(result).contains(\u0026#34;ddds\u0026#34;);  }  @Test  public void test_list_contains_onlyonce(){  List\u0026lt;String\u0026gt; result = Lists.newArrayList(\u0026#34;abcd\u0026#34;,\u0026#34;ddds\u0026#34;,\u0026#34;ttest\u0026#34;);  assertThat(result).containsOnlyOnce(\u0026#34;ddds\u0026#34;);  }   @Test  public void test_list_contains_ELementOf(){  List\u0026lt;String\u0026gt; result = Lists.newArrayList(\u0026#34;abcd\u0026#34;,\u0026#34;ddds\u0026#34;,\u0026#34;ttest\u0026#34;);  assertThat(result).containsExactlyElementsOf(Lists.newArrayList(\u0026#34;abcd\u0026#34;, \u0026#34;ddds\u0026#34;, \u0026#34;ttest\u0026#34;));  } Guava 的验证：\n@Test  public void MultiMap_assertions() {  Multimap\u0026lt;String, String\u0026gt; actual = ArrayListMultimap.create();  actual.putAll(\u0026#34;Lakers\u0026#34;, newArrayList(\u0026#34;Kobe Bryant\u0026#34;, \u0026#34;Magic Johnson\u0026#34;, \u0026#34;Kareem Abdul Jabbar\u0026#34;));  actual.putAll(\u0026#34;Spurs\u0026#34;, newArrayList(\u0026#34;Tony Parker\u0026#34;, \u0026#34;Tim Duncan\u0026#34;, \u0026#34;Manu Ginobili\u0026#34;));   assertThat(actual).containsKeys(\u0026#34;Lakers\u0026#34;, \u0026#34;Spurs\u0026#34;);  assertThat(actual).contains(entry(\u0026#34;Lakers\u0026#34;, \u0026#34;Kobe Bryant\u0026#34;),  entry(\u0026#34;Spurs\u0026#34;, \u0026#34;Tim Duncan\u0026#34;));  }   @Test  public void multiple_set_assertions() {  Multimap\u0026lt;String, String\u0026gt; listMultimap = ArrayListMultimap.create();  listMultimap.putAll(\u0026#34;Spurs\u0026#34;, newArrayList(\u0026#34;Tony Parker\u0026#34;, \u0026#34;Tim Duncan\u0026#34;, \u0026#34;Manu Ginobili\u0026#34;));  listMultimap.putAll(\u0026#34;Bulls\u0026#34;, newArrayList(\u0026#34;Michael Jordan\u0026#34;, \u0026#34;Scottie Pippen\u0026#34;, \u0026#34;Derrick Rose\u0026#34;));   Multimap\u0026lt;String, String\u0026gt; setMultimap = TreeMultimap.create();  setMultimap.putAll(\u0026#34;Spurs\u0026#34;, newHashSet(\u0026#34;Tony Parker\u0026#34;, \u0026#34;Tim Duncan\u0026#34;, \u0026#34;Manu Ginobili\u0026#34;));  setMultimap.putAll(\u0026#34;Bulls\u0026#34;, newHashSet(\u0026#34;Michael Jordan\u0026#34;, \u0026#34;Scottie Pippen\u0026#34;, \u0026#34;Derrick Rose\u0026#34;));  // assertion will pass as listMultimap and setMultimap have the same content  assertThat(listMultimap).hasSameEntriesAs(setMultimap);  // this assertion FAILS even though both multimaps have the same content  assertThat(listMultimap).isEqualTo(setMultimap);  }    @Test  public void range_assertions() {  Range\u0026lt;Integer\u0026gt; range = Range.closed(10, 12);  assertThat(range).isNotEmpty()  .contains(10, 11, 12)  .hasClosedLowerBound()  .hasLowerEndpointEqualTo(10)  .hasUpperEndpointEqualTo(12);  }   @Test  public void table_assertion() {  // Table assertions  Table\u0026lt;Integer, String, String\u0026gt; bestMovies = HashBasedTable.create();   bestMovies.put(1970, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;M.A.S.H\u0026#34;);  bestMovies.put(1994, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Pulp Fiction\u0026#34;);  bestMovies.put(2008, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Entre les murs\u0026#34;);  bestMovies.put(2000, \u0026#34;Best picture Oscar\u0026#34;, \u0026#34;American Beauty\u0026#34;);  bestMovies.put(2011, \u0026#34;Goldene Bär\u0026#34;, \u0026#34;A Separation\u0026#34;);   assertThat(bestMovies).hasRowCount(5).hasColumnCount(3).hasSize(5)  .containsValues(\u0026#34;American Beauty\u0026#34;, \u0026#34;A Separation\u0026#34;, \u0026#34;Pulp Fiction\u0026#34;)  .containsCell(1994, \u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Pulp Fiction\u0026#34;)  .containsColumns(\u0026#34;Palme d\u0026#39;Or\u0026#34;, \u0026#34;Best picture Oscar\u0026#34;, \u0026#34;Goldene Bär\u0026#34;)  .containsRows(1970, 1994, 2000, 2008, 2011);  }   @Test  public void test_opotions() {  // Optional assertions  Optional\u0026lt;String\u0026gt; optional = Optional.of(\u0026#34;Test\u0026#34;);  assertThat(optional).isPresent().contains(\u0026#34;Test\u0026#34;);   Optional\u0026lt;Long\u0026gt; optionalNum = Optional.of(12L);  assertThat(optionalNum).extractingValue()  .isInstanceOf(Long.class)  .isEqualTo(12L);   optional = Optional.of(\u0026#34;Bill\u0026#34;); // extractingCharSequence allows to chain String specific assertion  assertThat(optional).extractingCharSequence()  .startsWith(\u0026#34;Bi\u0026#34;);   } 日期的验证：\n@Test  public void date_before(){   DateTime dateTime = new DateTime();  DateTime firstDateTime = new DateTime();  firstDateTime.plus(10000L);  assertThat(dateTime).isBefore(firstDateTime);  assertThat(dateTime).isAfter(\u0026#34;2004-12-13T21:39:45.618-08:00\u0026#34;);  assertThat(dateTime).isAfter(\u0026#34;2004-12-13T21:39:00\u0026#34;);  assertThat(dateTime).isAfter(\u0026#34;2004-12-13T21:39:00\u0026#34;);   }   @Test  public void joda_datetime_compare(){   DateTime utcTime = new DateTime(2013, 6, 10, 0, 0, DateTimeZone.UTC);  DateTime cestTime = new DateTime(2013, 6, 10, 2, 0, DateTimeZone.forID(\u0026#34;Europe/Berlin\u0026#34;));   assertThat(utcTime).as(\u0026#34;in UTC time\u0026#34;).isEqualTo(cestTime);  } ","date":"February 1, 2016","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2016-02-01-assertions/","title":"assertions"},{"categories":["DevTips"],"contents":"再试用了Web 开发的框架之后，归纳一下大致的一个基础Web 开发需要的那些元素:\n URL Router，如何定义URL的访问 Request Handler/Response Handler， HTTP请求/返回的处理  如果组织这些Request Handler/Response Handler 如何定义全局/局部的URL拦截器 如何处理特殊的HTTP Header 如何处理Session/Cookie   Database Access Layer/ORM， 数据操作CRUD  如何CRUD 如何进行分页，排序，filterByCriteria\u0026hellip;..等数据库的常见操作 如何管理事务 如何定义，初始化数据库表 如何组织不同的数据库操作成不同的业务动作 详细，复杂的ORM操作可以不用太在意   Template Render,模版渲染  不同模版的试用 静态资源的访问   单元测试  断言，EXCEPTION检查 Mock 数据，内存数据库的使用   Web Application部署  不同环境的配置管理 不同语言的打包工具，如MAVEN，GRADLE 不同的构建工具,GULP 不同的服务器，NGINX，TOMCAT，JBOSS    ","date":"January 27, 2016","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2016-01-27-web-dev/","title":"WEB 开发的几个重点"},{"categories":["Thoughts"],"contents":"在做一件事情之前，问一句为什么是必要的.做自动化测试之前也是一样，不管如何总是要有一个理由的吗，哪怕是所有的人都做，我也要做这样的理由. 以下说说我觉得要做自动化的理由.\n为什么自动化(Why Automation Testing) 为什么自动化,对于测试的而言的理由 VS 实际情况\n 自动化可以减少重复的回归测试(实际中的我问题:那么回归测试在你日常的测试中比例是多少) 自动化测试可以提高自己的编码能力(这个原因无论如何是成立的) 自动化测试可以进行更快的迭代（实际中的问题：自动化测试的不稳定可能不一定起到预想的作用） 自动化测试可以做更多的回归测试内容，减少风险(实际中的问题：不稳定的测试可能不一定能够达到目的) 不同的测试环境可以运行相同的测试(实际的问题： 可能没有那么多的环境，一般情况下都有测试环境，集成环境，预发布环境，生产环境，其实不是没个公司都需要这样做的\u0026hellip;\u0026hellip;) 对于被测系统有更深刻的理解.由于需要编写代码，有时需要更深刻的理解内部的代码实现原理(实际中因人而异\u0026hellip;\u0026hellip;) 自动化测试不仅仅包括进行测试，还包括一切去提高交付产品效率质量的东西，对于测试而言提出了新要求(always true if QA really does this) 功能测试的业务知识可能在这家公司有用，到别家就没用了，但是会写代码可以积累自己(always true) 无论是性能测试和安全测试都需要代码能力，通过自动化代码的编写可以更好的了解，掌握性能测试或者安全测试(实际情况：不是没个人都对编码感兴趣的)  为什么自动化,对于公司的而言的理由 VS 实际情况\n 测试用例通过代码的方式积累下来，自动化测试可能不会立竿见影，但是他有复利的效果（实际情况：遗留的测试代码真的有用吗？） 系统如果重构那么通过自动化测试来完成很大一部分的功能测试（实际情况：遗留的测试代码真的有用吗？） 减少回归测试少测漏测风险（实际情况：遗留的测试代码真的有用吗？） 可以加速交付(交付流水线中不同的环境可以通过代码来跑，实际情况：遗留的测试代码真的有用吗？)  How to automation test  有统一的框架(框架一定要有IoC／DI的概念使用) 有扩展性的框架 方便实用，可以代码生产的工具链 安装自动化测试金字塔（单元，接口，UI）方式 千万不要使用自动化测试的anti-pattern 有规划，一步一步优化，不要贪多  ","date":"January 10, 2016","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/opinons/2016-01-10-why_how_automation/","title":"为什么自动化，如何自动化"},{"categories":["thoughts"],"contents":"Thoughtworks 发布了2015年技术雷达，看看他提到的东西可以长长见识。\n技术篇 这里提到了几篇Martin Flower的文章，抽时间一定要看看。\n Test Double nonDeterminism microservice 基本上他写的文章确实有必要看看的。  安全 －Thread Modeling\n工具,语言，观念  graphiz hoodie couchdb Flux git as cms phoneix server functional reactive programing （FRP） Spark kylin.io TOTP 密码机制，two－factor authentication Deis.io H2O TSDB,OpenTSB,influxDB,Cassandra SPDY mountebank polly/brighter consul.io/DNS+HTTP,consulTemplate Hamms Rest-assured ZAP Kafka Blackbox Bokeh data visualization Vega /D3.js Gor NaCI Orgami PdfMaker SoundCloud Quick object C/swift security monkey  ","date":"December 28, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/2015-12-28-next-reading/","title":"下一步的技术了解"},{"categories":["DevTips"],"contents":"HTTP Status Codes This page is created from HTTP status code information found at ietf.org and Wikipedia. Click on the category heading or the status code link to read more.\n1xx Informational  100 Continue 101 Switching Protocols 102 Processing (WebDAV)  2xx Success  200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 207 Multi-Status (WebDAV) 208 Already Reported (WebDAV) 226 IM Used  3xx Redirection  300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 305 Use Proxy 306 (Unused) 307 Temporary Redirect 308 Permanent Redirect (experiemental)  4xx Client Error  401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Request Entity Too Large 414 Request-URI Too Long 415 Unsupported Media Type 416 Requested Range Not Satisfiable 417 Expectation Failed 418 I\u0026rsquo;m a teapot (RFC 2324) 420 Enhance Your Calm (Twitter) 422 Unprocessable Entity (WebDAV) 423 Locked (WebDAV) 424 Failed Dependency (WebDAV) 425 Reserved for WebDAV 426 Upgrade Required 428 Precondition Required 429 Too Many Requests 431 Request Header Fields Too Large 444 No Response (Nginx) 449 Retry With (Microsoft) 450 Blocked by Windows Parental Controls (Microsoft) 499 Client Closed Request (Nginx)  5xx Server Error  500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported 506 Variant Also Negotiates (Experimental) 507 Insufficient Storage (WebDAV) 508 Loop Detected (WebDAV) 509 Bandwidth Limit Exceeded (Apache) 510 Not Extended 511 Network Authentication Required 598 Network read timeout error 599 Network connect timeout error  ","date":"December 23, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2015-12-23-http_status_code/","title":"http status code HTTP 状态码"},{"categories":["api-testing"],"contents":"在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。\n下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：\n 如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法  如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：\n 通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试  我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:\n 发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们  总体上我自己的总结是如下图:\n接口自动化测试脚手架的构建 根据以上的分析如果自己需要实现的话，最主要需要实现一下其实就是请求的构建，请求构建包括了:\n 发起请求的客户端 请求数据的构建  对于发起请求的客户端就直接使用了Spring RestTemplate,考虑的主要原因如下:\n 使用相对比较方便,模块化比较清晰 可以使用HTTPClient的实现 Spring RestTemplate所在的包还有其他一些接口的支持，以后如果使用其他接口可以不需要换包也可以做  在实际的使用过程中，其实也遇到了一些问题，比如如下的内容:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  如何解决这些问题,在后面再详细介绍，这里说明一下使用RestTemplate的一个主要流程：\n   构建请求，设置请求的Header，URL，Accept，ContextType，Token等等    调用请求获取返回的Response， 这个ResponseRestTemplate中实际上封装了一个ResponseEntity的类，里面包括了请求状态，Body之类 RestTemplate 有个好处就是如果给RestTemplate设定了MessageConverter的话，他可以自动把请求的返回类型直接转换，比如你发起请求的时候设置了JOSN的Message Converter，他可以帮你把类，或者字符串自己转化为JSON来发送，同样如果是返回值是JSON的话，也可以帮你自己将JSON转换成你指定类型的JAVA BEAN    说完这个流程，我们就说说如何通过RestTemplate构建一个简单的HTTP请求:\n Map\u0026lt;String,String\u0026gt; urlVariable = new Map\u0026lt;String,String\u0026gt; ();  urlVariable.put(\u0026#34;q\u0026#34;,\u0026#34;test\u0026#34;);  JavaBean javaBean = restTemplate.getForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  JavaBean javaBean1 = restTemplate.postForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  ResponseEntity e = restTemplate.getForEntity(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable); 实际上使用RestTemplate还是挺简单的，不过为了让使测试更为方便一点，然后每个人的代码更统一点，自己重新封装了一下RestTemplate的使用，主要分为三个概念:\n Service 的描述 测试数据 客户端调用  接口服务描述 Service的描述实际上就是一个JSON文件，只不过自己规定了一下，格式类似于,这个文件描述了API的定义，当然API的body没有在这个里面，不过为了不把事情搞复杂，就暂时不放在这个里面.\n{ \u0026#34;apiDomainName\u0026#34;: \u0026#34;applicationName\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;application/json, text/javascript, */*\u0026#34; }, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;pathParameters\u0026#34;: [], \u0026#34;queryParameters\u0026#34;: [ \u0026#34;username\u0026#34;, ], \u0026#34;resourceURL\u0026#34;: \u0026#34;/application/subdomain\u0026#34; } 测试数据类：\n private Map\u0026lt;String, String\u0026gt; queryParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; pathParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; headers = Maps.newHashMap();  private T body; 而如何调用客户端就变成,而且其实每一个API的访问其实都可以这样子来做，\n ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call(); 说明一下的是：\n serviceDescriptionPath就是接口的描述 requestData就是需要进行测试的数据  然后实际上接口的描述是开发还没有开发好的时候就已经定了的，所以这里的变量就变成如何构建requestData了\n构建RequestData 构建requestData实际上就是设计测试用例，那么这里也是使用Excel的方式，将不同的值填写到excel里面，不过为了减少set值这样的操作，这个脚手架就提供了一些工具，可以直接将数据设置到RequestData实例，具体的操作如下:\nExcel是如下格式的：\n   变量名 测试用例1 测试用例2     data.queryParameters(username) 1 1   data.queryParameters(year) 2015 2014   data.queryParameters(month) 10 11    说明一下，通过反射的方式，可以直接生成一个requestData的实例,同时queryParameters中值已经设置好了，这样调用代码中就不需要写类似于：\n RequestData data = new RequestData();  data.queryParameters.put(\u0026#34;username\u0026#34;,\u0026#34;1\u0026#34;);  data.queryParameters.put(\u0026#34;year\u0026#34;,\u0026#34;2015\u0026#34;); 这里有兴趣的同学可以参考这个包:里面其实已经有很方便的通过反射去赋值了,\n\u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.jodd\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jodd-bean\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.6.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用TestNG的DataProvider 刚才讲述了如何发生生成数据，那么通过Excel的方式提供不同的数据，就可以通过TestNG的DataProvider了 所以测试数据通过，TestNG data provider的实现在这里就不多少了，网上其实有很多内容了.\n接口测试的代码看起来就是这个样子了 @DataProvider(name = \u0026#34;data\u0026#34;)  public Iterator\u0026lt;Object[]\u0026gt; getAPITestData(Method m) throws Exception {  Map\u0026lt;String, Class\u0026gt; clazz = new HashMap\u0026lt;String, Class\u0026gt;();  clazz.put(\u0026#34;RequestData\u0026#34;, RequestData.class);  Iterator\u0026lt;Object[]\u0026gt; y = TestData.provider(\u0026#34;testcase/api1.xls\u0026#34;, m, clazzMap);   return y;  }   @Test(dataProvider = \u0026#34;data\u0026#34;)  public void testAPITest(RequestData data) {  ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call();  Assert.assertEqual(response.getStatus,200); // response 的期望值实际可以通过dataprovider传入  } 而且几乎所有的代码都差不多成这个样子了，那么获取可以写个代码生成的东西,当然最后通过了JsonPath写了一些获取JSON值的工具，这个暂时也就不说了.\n那么代码生成吧 当封装好这些东西之后，发现所有的接口都类似了，然后就做了代码生成的工具了,代码生成器的入口实际上个就是那个服务描述文件开始的， 所以代码生成器的参数就是服务描述文件，在实际的使用的过程中，接口描述这个文件也可以自动生成，目前总共支持以下几种:\n 手动编写描述文件 抓取开发API规格网站接口的描述，自动生成描述文件 解析HAR文件自动生成描述文件，解析HAR其实不难，就是繁琐一点字段有点多  后续想打通和POSTMAN的连接，可以接收POSTMAN的导出文件，然后也可以导出POSTMANT的，以后开BUG就什么也不说，直接放一个POSTMAN文件其实也挺帅的\n至此一个接口测试的脚手架就大致完成了.总结起来就是:\n 封装了RestTemplate，让他接受一个接口的描述文件，一个请求的数据 通过Excel传数据给请求的数据进行数据驱动 相同类似的代码进行代码生成  最后其实这样子使用下来,接口构建几个简单一点的自动化测试用例，其实也就是几分钟的事情.\n一些细节 在实现过程中，实际上还有一些特殊情况，比如说需要token，认证信息，这些通过一个公用函数的方式就可以解决，然后在代码生成的时候 直接讲这个放在实际测试的接口前面调用. 后有就是上面说到的的:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  HTTPS的访问是通过如下代码解决的,创建一个略SSL的httpclient就可以了\npublic static RestTemplateClientHelper getHttpClientImplInstance(){  RestTemplateClientHelper client = new RestTemplateClientHelper();  HttpClient httpClient = getIgnoreSSLHttpClient();  client.setTemplate(new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient)));  return client;  }   /** * 获取忽略SSL的httpclient，支持https的请求 * @return */  private static HttpClient getIgnoreSSLHttpClient() {  CloseableHttpClient httpClient = null;  try {   httpClient = HttpClients.custom().  setHostnameVerifier(new AllowAllHostnameVerifier()).  setSslcontext(new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {  public boolean isTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {  return true;  }  }).build()).build();  } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {  logger.error(e);  }  return httpClient;  } 还有一个就是有时开发的接口返回类型(accept type)不能让RestTemplate处理，那么其实添加自己定义个MessageConverter就好了: 下面是一个修改阿里自己的FastJSON的MessageConverter的例子, 其实也没改什么，就是捕捉了一个异常，主要是不知道什么原因调用时候readInternal就抛出和编码格式有关系的异常，然后就捕捉了一下异常反正也就把那个问题就没有了，不过这个改法应该也是有问题的.\npublic class ModifiedFastJsonHttpMessageConverter extends AbstractHttpMessageConverter\u0026lt;Object\u0026gt; {  ........  public ModifiedFastJsonHttpMessageConverter() {  super(new MediaType(\u0026#34;application\u0026#34;, \u0026#34;json\u0026#34;, UTF8), new MediaType(\u0026#34;application\u0026#34;, \u0026#34;*+json\u0026#34;, UTF8));  this.charset = UTF8;  this.features = new SerializerFeature[0];  }   ............   protected Object readInternal(Class\u0026lt;?\u0026gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {  ByteArrayOutputStream baos = new ByteArrayOutputStream();  InputStream in = inputMessage.getBody();  byte[] buf = new byte[1024];   while(true) {  int bytes = in.read(buf);  if(bytes == -1) {  byte[] bytes1 = baos.toByteArray();  try {  return JSON.parseObject(bytes1, 0, bytes1.length, this.charset.newDecoder(), clazz);  }catch (Exception e){  return baos.toString(\u0026#34;UTF-8\u0026#34;);  }  }   if(bytes \u0026gt; 0) {  baos.write(buf, 0, bytes);  }  }  }  ........  } 后续的一些想法 后续希望在这个基础上再做点其他的一些事情:\n 增加POSTMAN的代码生成的支持 探索能不能通过API接口描述直接生成JMETER的JMX文件，可以讲基础的JMETER性能测试的基础代码也生成好 整理一下放到GITHUB上面，其实整个脚手架自己也就是几个文件而已，:) 建立一个MOCK SERVER，方便模拟一些API调用的方式 做一个简单点获取JSON中指定字段，然后传递给下一个API使用的工具  一些资源  unitest json-placeholder wiremock mockbin  ","date":"November 27, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/api-testing/2015-11-27-webservice-automation/","title":"自动化测试－接口测试"},{"categories":["Thoughts"],"contents":"在敏捷开发交付的流程中，自动化测试实际上被放在一个看起来挺重要的位置，而自动化测试中，接口测试是一个投入产出比比较高的 一种自动化测试的形式，而我自己也做了一个这样的脚手架一样的东西可以方便进行自动化测试，关键是在一些现有第三包的基础上做实现，其实一个脚手架不需要几个JAVA类就可以完成了，至少我自己的这个在10个文件以内.要论行数估计也没有多少代码量，主要时间其实都是在想怎么更方便的写自动化测试，怎么使用以后的开源代码了。\n下面介绍一下我自己如何完成这个自动化接口测试 脚手架设计和实现的，以及我自己实现过程中的种种发现。主要从以下几个方面来讲：\n 如何构建接口自动化测试的脚手架 关于接口测试参考的一些资源 关于接口测试的后续的一些想法  如何构建接口自动化测试的脚手架 接口测试本文中主要是指HTTP的请求，构建接口自动化测试脚手架的时候，首先先看看平常接口测试，测试人员时如何做的，我了解主要是以下几种方式：\n 通过操作页面/APP来触发接口调用 使用诸如SOAPYUI/JMETER/POSTMAN 或者其他的客户端工具来进行接口测试  我自己都使用过SOAPUI/JMETER/POSTMAN,不能说使用的多么深入，但是常用的功能也都有用过，比如SOAPUI构建一个项目完整的接口自动化测试用例，大概有200+以上的用例，可以支持不同的测试环境，检查点中可以检查数据库,使用XPATH/XQUERY来检查／获取指定的值，进行不同API的数据传递等等，这些工具(指功能测试方面)大体的逻辑我觉得是类似的,基本上都有:\n 发起请求的客户端,需要测试人员构建，也有通过WSDL/WADL自己生成的，不过数据都是需要测试人员输入的 根据表达式进行取值的Resolver,就是可以根据XPATH/XQUERY语法，或者其他的语法来获取指定的值， 就是用来传递上下文数据的一种方式 外部可以参数话数据，比如环境配置 可以查看测试结果，这个其实可以理解为某种测试框架的一个功能，不如JUNIT，TESTNG，他们  总体上我自己的总结是如下图:\n接口自动化测试脚手架的构建 根据以上的分析如果自己需要实现的话，最主要需要实现一下其实就是请求的构建，请求构建包括了:\n 发起请求的客户端 请求数据的构建  对于发起请求的客户端就直接使用了Spring RestTemplate,考虑的主要原因如下:\n 使用相对比较方便,模块化比较清晰 可以使用HTTPClient的实现 Spring RestTemplate所在的包还有其他一些接口的支持，以后如果使用其他接口可以不需要换包也可以做  在实际的使用过程中，其实也遇到了一些问题，比如如下的内容:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  如何解决这些问题,在后面再详细介绍，这里说明一下使用RestTemplate的一个主要流程：\n   构建请求，设置请求的Header，URL，Accept，ContextType，Token等等    调用请求获取返回的Response， 这个ResponseRestTemplate中实际上封装了一个ResponseEntity的类，里面包括了请求状态，Body之类 RestTemplate 有个好处就是如果给RestTemplate设定了MessageConverter的话，他可以自动把请求的返回类型直接转换，比如你发起请求的时候设置了JOSN的Message Converter，他可以帮你把类，或者字符串自己转化为JSON来发送，同样如果是返回值是JSON的话，也可以帮你自己将JSON转换成你指定类型的JAVA BEAN    说完这个流程，我们就说说如何通过RestTemplate构建一个简单的HTTP请求:\n Map\u0026lt;String,String\u0026gt; urlVariable = new Map\u0026lt;String,String\u0026gt; ();  urlVariable.put(\u0026#34;q\u0026#34;,\u0026#34;test\u0026#34;);  JavaBean javaBean = restTemplate.getForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  JavaBean javaBean1 = restTemplate.postForObject(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable);  ResponseEntity e = restTemplate.getForEntity(\u0026#34;http://www.baidu.com\u0026#34;,JavaBean.class,urlVariable); 实际上使用RestTemplate还是挺简单的，不过为了让使测试更为方便一点，然后每个人的代码更统一点，自己重新封装了一下RestTemplate的使用，主要分为三个概念:\n Service 的描述 测试数据 客户端调用  接口服务描述 Service的描述实际上就是一个JSON文件，只不过自己规定了一下，格式类似于,这个文件描述了API的定义，当然API的body没有在这个里面，不过为了不把事情搞复杂，就暂时不放在这个里面.\n{ \u0026#34;apiDomainName\u0026#34;: \u0026#34;applicationName\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Accept\u0026#34;: \u0026#34;application/json, text/javascript, */*\u0026#34; }, \u0026#34;method\u0026#34;: \u0026#34;POST\u0026#34;, \u0026#34;pathParameters\u0026#34;: [], \u0026#34;queryParameters\u0026#34;: [ \u0026#34;username\u0026#34;, ], \u0026#34;resourceURL\u0026#34;: \u0026#34;/application/subdomain\u0026#34; } 测试数据类：\n private Map\u0026lt;String, String\u0026gt; queryParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; pathParameters = Maps.newHashMap();  private Map\u0026lt;String, String\u0026gt; headers = Maps.newHashMap();  private T body; 而如何调用客户端就变成,而且其实每一个API的访问其实都可以这样子来做，\n ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call(); 说明一下的是：\n serviceDescriptionPath就是接口的描述 requestData就是需要进行测试的数据  然后实际上接口的描述是开发还没有开发好的时候就已经定了的，所以这里的变量就变成如何构建requestData了\n构建RequestData 构建requestData实际上就是设计测试用例，那么这里也是使用Excel的方式，将不同的值填写到excel里面，不过为了减少set值这样的操作，这个脚手架就提供了一些工具，可以直接将数据设置到RequestData实例，具体的操作如下:\nExcel是如下格式的：\n   变量名 测试用例1 测试用例2     data.queryParameters(username) 1 1   data.queryParameters(year) 2015 2014   data.queryParameters(month) 10 11    说明一下，通过反射的方式，可以直接生成一个requestData的实例,同时queryParameters中值已经设置好了，这样调用代码中就不需要写类似于：\n RequestData data = new RequestData();  data.queryParameters.put(\u0026#34;username\u0026#34;,\u0026#34;1\u0026#34;);  data.queryParameters.put(\u0026#34;year\u0026#34;,\u0026#34;2015\u0026#34;); 这里有兴趣的同学可以参考这个包:里面其实已经有很方便的通过反射去赋值了,\n\u0026lt;dependency\u0026gt;  \u0026lt;groupId\u0026gt;org.jodd\u0026lt;/groupId\u0026gt;  \u0026lt;artifactId\u0026gt;jodd-bean\u0026lt;/artifactId\u0026gt;  \u0026lt;version\u0026gt;3.6.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用TestNG的DataProvider 刚才讲述了如何发生生成数据，那么通过Excel的方式提供不同的数据，就可以通过TestNG的DataProvider了 所以测试数据通过，TestNG data provider的实现在这里就不多少了，网上其实有很多内容了.\n接口测试的代码看起来就是这个样子了 @DataProvider(name = \u0026#34;data\u0026#34;)  public Iterator\u0026lt;Object[]\u0026gt; getAPITestData(Method m) throws Exception {  Map\u0026lt;String, Class\u0026gt; clazz = new HashMap\u0026lt;String, Class\u0026gt;();  clazz.put(\u0026#34;RequestData\u0026#34;, RequestData.class);  Iterator\u0026lt;Object[]\u0026gt; y = TestData.provider(\u0026#34;testcase/api1.xls\u0026#34;, m, clazzMap);   return y;  }   @Test(dataProvider = \u0026#34;data\u0026#34;)  public void testAPITest(RequestData data) {  ResponseEntity response = RestTemplateHelper.build(serviceDescriptionPath,requestData).call();  Assert.assertEqual(response.getStatus,200); // response 的期望值实际可以通过dataprovider传入  } 而且几乎所有的代码都差不多成这个样子了，那么获取可以写个代码生成的东西,当然最后通过了JsonPath写了一些获取JSON值的工具，这个暂时也就不说了.\n那么代码生成吧 当封装好这些东西之后，发现所有的接口都类似了，然后就做了代码生成的工具了,代码生成器的入口实际上个就是那个服务描述文件开始的， 所以代码生成器的参数就是服务描述文件，在实际的使用的过程中，接口描述这个文件也可以自动生成，目前总共支持以下几种:\n 手动编写描述文件 抓取开发API规格网站接口的描述，自动生成描述文件 解析HAR文件自动生成描述文件，解析HAR其实不难，就是繁琐一点字段有点多  后续想打通和POSTMAN的连接，可以接收POSTMAN的导出文件，然后也可以导出POSTMANT的，以后开BUG就什么也不说，直接放一个POSTMAN文件其实也挺帅的\n至此一个接口测试的脚手架就大致完成了.总结起来就是:\n 封装了RestTemplate，让他接受一个接口的描述文件，一个请求的数据 通过Excel传数据给请求的数据进行数据驱动 相同类似的代码进行代码生成  最后其实这样子使用下来,接口构建几个简单一点的自动化测试用例，其实也就是几分钟的事情.\n一些细节 在实现过程中，实际上还有一些特殊情况，比如说需要token，认证信息，这些通过一个公用函数的方式就可以解决，然后在代码生成的时候 直接讲这个放在实际测试的接口前面调用. 后有就是上面说到的的:\n HTTPS的访问 开发接口定义不够准确的问题,造成使用RestTemplate时候出现了一些不在开始预期范中的问题  HTTPS的访问是通过如下代码解决的,创建一个略SSL的httpclient就可以了\npublic static RestTemplateClientHelper getHttpClientImplInstance(){  RestTemplateClientHelper client = new RestTemplateClientHelper();  HttpClient httpClient = getIgnoreSSLHttpClient();  client.setTemplate(new RestTemplate(new HttpComponentsClientHttpRequestFactory(httpClient)));  return client;  }   /** * 获取忽略SSL的httpclient，支持https的请求 * @return */  private static HttpClient getIgnoreSSLHttpClient() {  CloseableHttpClient httpClient = null;  try {   httpClient = HttpClients.custom().  setHostnameVerifier(new AllowAllHostnameVerifier()).  setSslcontext(new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() {  public boolean isTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {  return true;  }  }).build()).build();  } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {  logger.error(e);  }  return httpClient;  } 还有一个就是有时开发的接口返回类型(accept type)不能让RestTemplate处理，那么其实添加自己定义个MessageConverter就好了: 下面是一个修改阿里自己的FastJSON的MessageConverter的例子, 其实也没改什么，就是捕捉了一个异常，主要是不知道什么原因调用时候readInternal就抛出和编码格式有关系的异常，然后就捕捉了一下异常反正也就把那个问题就没有了，不过这个改法应该也是有问题的.\npublic class ModifiedFastJsonHttpMessageConverter extends AbstractHttpMessageConverter\u0026lt;Object\u0026gt; {  ........  public ModifiedFastJsonHttpMessageConverter() {  super(new MediaType(\u0026#34;application\u0026#34;, \u0026#34;json\u0026#34;, UTF8), new MediaType(\u0026#34;application\u0026#34;, \u0026#34;*+json\u0026#34;, UTF8));  this.charset = UTF8;  this.features = new SerializerFeature[0];  }   ............   protected Object readInternal(Class\u0026lt;?\u0026gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {  ByteArrayOutputStream baos = new ByteArrayOutputStream();  InputStream in = inputMessage.getBody();  byte[] buf = new byte[1024];   while(true) {  int bytes = in.read(buf);  if(bytes == -1) {  byte[] bytes1 = baos.toByteArray();  try {  return JSON.parseObject(bytes1, 0, bytes1.length, this.charset.newDecoder(), clazz);  }catch (Exception e){  return baos.toString(\u0026#34;UTF-8\u0026#34;);  }  }   if(bytes \u0026gt; 0) {  baos.write(buf, 0, bytes);  }  }  }  ........  } 后续的一些想法 后续希望在这个基础上再做点其他的一些事情:\n 增加POSTMAN的代码生成的支持 探索能不能通过API接口描述直接生成JMETER的JMX文件，可以讲基础的JMETER性能测试的基础代码也生成好 整理一下放到GITHUB上面，其实整个脚手架自己也就是几个文件而已，:) 建立一个MOCK SERVER，方便模拟一些API调用的方式 做一个简单点获取JSON中指定字段，然后传递给下一个API使用的工具  一些资源  unitest json-placeholder wiremock mockbin  ","date":"November 27, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/opinons/2015-11-27-webservice-automation/","title":"自动化测试－接口测试"},{"categories":["automation","javascript"],"contents":"自己学习Phatomjs的教程,分享之.\nQuick Start 首先phantomjs是个什么? 以下是官方网站的解释:\nPhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG. phantomjs可以用来做什么?\n HEADLESS WEBSITETESTING SCREENSHOT PAGE AUTOMATION NETWORK MONITORING \u0026hellip;\u0026hellip; depends on your imagination  这里主要来介绍一下PhantomJS的基础用法,包括了:\n 基础语法 HEADLESS WEB TESTING SCREEN Capture Network Monitoring Page Automation  安装PhantomJS请参考: http://phantomjs.org/download.html\n基础语法  Hello World  console.log(\u0026#39;Hello World!\u0026#39;); phantom.exit(); result:\nphantomjs hello_world.js Hello World!  Page Loading 一下代码是访问百度首页,计算页面加载时间并且截屏的例子:  var page = require(\u0026#39;webpage\u0026#39;).create(); var url = \u0026#39;http://www.baidu.com\u0026#39;; t = Date.now(); page.open(url, function (status) {  console.log(\u0026#34;Status:\u0026#34; + status);  if (status !== \u0026#39;success\u0026#39;) {  console.log(\u0026#39;FAIL to load the address\u0026#39;);  } else {  t = Date.now() - t;  console.log(\u0026#39;Loading \u0026#39; + url);  console.log(\u0026#39;Loading time \u0026#39; + t + \u0026#39; msec\u0026#39;);  page.render(\u0026#39;baidu.png\u0026#39;); //capture the screenshot  }   phantom.exit(); }) 运行结果：\n●✚  phantomjs pageload.js [10:43:41] Status:success Loading http://www.baidu.com Loading time 699 msec 是不是很简单，只要几行代码就可以实现了,这里主要使用了:webpage 这个模块\n Code Evaluation  通过evaluate 方法可以在当前页面运行js程序，但是也仅限于当前页面的范围\nvar page = require(\u0026#39;webpage\u0026#39;).create(); page.onConsoleMessage = function(msg) {  console.log(\u0026#39;Page title is \u0026#39; + msg); }; page.open(\u0026#34;http://www.baidu.com\u0026#34;, function(status) {  page.evaluate(function() {  console.log(document.title);  var element = document.getElementById(\u0026#39;kw\u0026#39;);  console.log(element.getAttribute(\u0026#39;name\u0026#39;));  });  phantom.exit(); }); 运行结果：\nphantomjs code_evaluation.js [10:51:55] Page title is 一张网页，要经历怎样的过程，才能抵达用户面前？ 一位新人，要经历怎样的成长，才能站在技术之巅？ 探寻这里的秘密； 体验这里的挑战； 成为这里的主人； 加入百度，加入网页搜索，你，可以影响世界。  Page title is 请将简历发送至 %c ps_recruiter@baidu.com（ 邮件标题请以“姓名-应聘XX职位-来自console”命名） color:red Page title is 职位介绍：http://dwz.cn/hr2013 Page title is 百度一下，你就知道 Page title is wd  On request and Response  通过phantomjs 监听request和response，代码：\nvar page = require(\u0026#39;webpage\u0026#39;).create(); var url=\u0026#34;http://www.baidu.com\u0026#34; page.onResourceRequested = function(request) {  console.log(\u0026#39;Request \u0026#39; + JSON.stringify(request, undefined, 4)); }; page.onResourceReceived = function(response) {  console.log(\u0026#39;Receive \u0026#39; + JSON.stringify(response, undefined, 4)); }; page.open(url,function(){  console.log(\u0026#34;success\u0026#34;);  phantom.exit() }); 运行结果：\n............... } ], \u0026#34;id\u0026#34;: 18, \u0026#34;redirectURL\u0026#34;: null, \u0026#34;stage\u0026#34;: \u0026#34;end\u0026#34;, \u0026#34;status\u0026#34;: 200, \u0026#34;statusText\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2015-10-24T04:05:39.086Z\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=\u0026amp;json=1\u0026amp;p=3\u0026amp;sid=17521_1455_17619_13245_17640_17001_17470_17072_15640_11634_17051\u0026amp;req=2\u0026amp;csor=0\u0026amp;cb=jQuery110209065551124513149_1445659538702\u0026amp;_=1445659538703\u0026#34; } success HEADLESS WEB TESTING please refer here:http://phantomjs.org/headless-testing.html\nSCREENSHOT screen capture is quite simple,just use:\nvar page = require(\u0026#39;webpage\u0026#39;).create(); var url = \u0026#39;http://www.baidu.com\u0026#39;; t = Date.now(); page.open(url, function (status) {  console.log(\u0026#34;Status:\u0026#34; + status);  if (status !== \u0026#39;success\u0026#39;) {  console.log(\u0026#39;FAIL to load the address\u0026#39;);  } else {  t = Date.now() - t;  console.log(\u0026#39;Loading \u0026#39; + url);  console.log(\u0026#39;Loading time \u0026#39; + t + \u0026#39; msec\u0026#39;);  page.render(\u0026#39;baidu.png\u0026#39;); //capture the screenshot  }   phantom.exit(); }) also actual use page.render('baidu.pdf') to generate a PDF file\npage-automation 操作\nvar page = require(\u0026#39;webpage\u0026#39;).create(); var url =\u0026#34;http://www.baidu.com\u0026#34;; var cdn_url= \u0026#39;http://cdn.staticfile.org/jquery/2.1.1-rc2/jquery.min.js\u0026#39;;  page.open(url, function() {  page.includeJs(cdn_url, function() {  page.evaluate(function() {   $(\u0026#34;button\u0026#34;).click();  });  phantom.exit()  });  page.render(\u0026#39;baidu.png\u0026#39;); }); Related Projects 相关的项目请参考： projects\n","date":"October 24, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2015-10-24-phantomjs-usage/","title":"Phantomjs Tutorial"},{"categories":["testing","thoughts"],"contents":"有时面试的时候会随机指定一个产品进行测试,比如一个电梯,你会如何设计测试用例？这个问题很发散,更多的是看应聘者的条理 和分析能力.\n本质上一个电梯是一个太大的范畴，实际测试的过程中很少一下子会有这么巨大的功能让你测试的。 与其说让你设计测试用例，其实好不如说让你想一个电梯有什么功能,然后根据功能再来考虑测试用例,所以更多的 是考察思路,在实际的测试工作中,如果突然有个人说我今天完成了一个电梯的功能,找个人给我测一下吧。 那么多半这个项目就是个让测试欲哭无泪的项目。\n不过既然面试有人问这样的问题，那么就分析分析吧，以下我是把电梯转化为类似互联网产品来做的分析， 完全是个人想法,一定有非常多欠缺。\n后端服务组件和客户端分离(Client-Server/MVC) 首先其实对把一个电梯分成不同的组件：\n 驱动服务: 可以使电梯上下行(后台服务) 门: 开门关门(后台服务) 电梯操作面板: 人机界面,担当用户和电梯的一个中间人作用,将用户操作转化为指令来控制电梯 (app/web page) (如果简单的话可能操作命令转换就都在这个地方了，如果复杂可能还有一个控制系统层) 指令控制系统(调度系统,监听器或者Queue) 呼叫监控系统:(可以暂时不考虑)  这里就先考虑简单的情况，电梯操作面板模块之内将操作转换成指令给电梯的驱动和门服务\n逐个组件来考虑用例 驱动服务可能包含的功能点有如下:  上行, 但是上行有极限位置(可配置)，按照指定步进数量上行 中途等待 步进距离(一层距离)可以配置 下行,下行位置(可配置)，按照指定步进数量下行 承载重量 可靠性监测，使用寿命监测 故障监测  这里注意如果测试电梯产品和测试指定某个大楼的电梯,测试用例的设计考虑点是稍有不同的，如果是电梯产品他就有电梯的配置项需要测试， 如果是测试制定电梯,那么配置项就可以忽略了，配置的就是你目前的配置。\n门服务 关于门的服务可能会想到的是:\n 开门 关门 可靠性  对于开门这个功能的测试用例测试可以围绕:\n 接收到开门指令开门并且只做开门 在电梯运动过程中接收到开门指令不开门 接收不到开门指令则不开门 开门指令被中断 开门接到后的进行开门的响应时间  关门是类似，但是关门需要考虑超重情况下不能关门. 可靠性考虑多少次开门关门之后开门关门的机械组件才失效\n电梯操作面板 操作面板这块实际上分为界面控件状态改变和指令转换两大块,在通过操作操作面板按钮后，同时 改变按钮状态以及发送正确指令,而指令处理这块就可\n 门开关按钮, 开关有效,开关无效 楼层按钮，启用,取消，灯亮，灯关 电梯上下调度, 多个按钮被按下之后,结合电梯自己所在位置决定运行方案 易用性等，因为是见人的地方，所有就有usability 测试  指令控制系统 指令控制系统可以认为根据电梯运行时的上下文,调度电梯运行的一个模块,这里面应该是根据某种规则 发出实际控制电梯的信号，具体什么的规则其实很难断定。\n扩展到多个电梯的调度测试 有可能会有多个电梯的调度，同样也是需要一套规则再来进行测试的\n这个文章写的有点粗糙,主要凭空去想这些case太伤脑袋，但是总体而言个人认为这是一个考虑问题的方向，同时个人觉得在一个短时间内 针对这样一个系统说写出很多测试用例，其实也就是呵呵了。 也许有更好的方法来总结这样的测试,可能类似于探索性测试之类的，希望有人能够指正。 同时我们也可以看到设计测试用例要包含多少东西,测试需要了解:\n 产品需求(没有需要推测:)) 功能 可靠性 性能 扩展性 可用性  从high level看可能还有更多,这些一个人都可以搞定的话,这个人还是人吗?而在实际的工作中这些会有都 多少人都进行相关类型的测试？不说进行这样的测试，估计连衡量这些测试的优先级都不会,有人说的头头 是道，可是真的有多少实践呢？\n生活可能就是这样的,说的天花乱坠的,可能其实都是别人的经验,如果真的自己动手做的时候,就说需要找人做. 然后他就成为领导了.也有更大的领导在说一个什么事情的时候，就接入一个宏大的名词，然后大领导一听，对， 然后他也成了领导了. 而做事的人苦苦的寻觅着那些宏大名次的解答，更为关键的是,很可能是你一个人去寻找 很多宏大名词的解答.\n","date":"October 22, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/2015-10-22-random-testcasedesign/","title":"测试用例设计- 随机指定一个产品的测试"},{"categories":["automation","java"],"contents":"本文主要用来分析Page Factory实现的原理以及一些扩展的可能性。\nPage Factory 的例子 Selenium Page Factory Wiki\n首先解释一下这个例子：\n 使用注解描述元素定位 使用 PageFactory.initElements(driver, page);   public class GoogleSearchPage {  // The element is now looked up using the name attribute  @FindBy(how = How.NAME, using = \u0026#34;q\u0026#34;)  private WebElement searchBox;   public void searchFor(String text) {  // We continue using the element just as before  searchBox.sendKeys(text);  searchBox.submit();  }   public void searchFor(String text) {  GoogleSearchPage page＝ PageFactory.initElements(new ChromeDriver(), GoogleSearchPage.class);  } } 以上一个显而易见的好处就是减少了查找元素的代码量，比如类似于一下的代码：\n driver.findElement(By.id(\u0026#34;q\u0026#34;)) 但是只有这样的好处吗？我们先从分析Selenium Page Factory实现的原理说起\n##Page Factory 实现的原理\nPageFactory 是使用反射(Reflection)和动态代理(dynamic proxies)的方式来创建页面的每 每个元素:\n PageFactory: initElements and proxyFields  public static void initElements(FieldDecorator decorator, Object page) {  for(Class proxyIn = page.getClass(); proxyIn != Object.class; proxyIn = proxyIn.getSuperclass()) {  proxyFields(decorator, page, proxyIn);  }  }  private static void proxyFields(FieldDecorator decorator, Object page, Class\u0026lt;?\u0026gt; proxyIn) {  Field[] fields = proxyIn.getDeclaredFields();  Field[] arr$ = fields;  int len$ = fields.length;   for(int i$ = 0; i$ \u0026lt; len$; ++i$) {  Field field = arr$[i$];  Object value = decorator.decorate(page.getClass().getClassLoader(), field);  if(value != null) {  try {  field.setAccessible(true);  field.set(page, value);  } catch (IllegalAccessException var10) {  throw new RuntimeException(var10);  }  }  }  }  FieldDecorator：DefaultFieldDecorator 源码 从DefaultFieldDecorator的源码看:   实现decorate方法,WebElement 和List 都是通过proxy的方式创建的 每个Proxy的方式都有一个对应的invocationHandler处理 Selenium的源码有两个invocationHandler：  LocatingElementHandler LocatingElementListHandler    public Object decorate(ClassLoader loader, Field field) {  if(!WebElement.class.isAssignableFrom(field.getType()) \u0026amp;\u0026amp; !this.isDecoratableList(field)) {  return null;  } else {  ElementLocator locator = this.factory.createLocator(field);  return locator == null?null:(WebElement.class.isAssignableFrom(field.getType())?this.proxyForLocator(loader, locator):(List.class.isAssignableFrom(field.getType())?this.proxyForListLocator(loader, locator):null));  }  }   private boolean isDecoratableList(Field field) {  if(!List.class.isAssignableFrom(field.getType())) {  return false;  } else {  Type genericType = field.getGenericType();  if(!(genericType instanceof ParameterizedType)) {  return false;  } else {  Type listType = ((ParameterizedType)genericType).getActualTypeArguments()[0];  return !WebElement.class.equals(listType)?false:field.getAnnotation(FindBy.class) != null || field.getAnnotation(FindBys.class) != null || field.getAnnotation(FindAll.class) != null;  }  }  }   protected WebElement proxyForLocator(ClassLoader loader, ElementLocator locator) {  LocatingElementHandler handler = new LocatingElementHandler(locator);  WebElement proxy = (WebElement)Proxy.newProxyInstance(loader, new Class[]{WebElement.class, WrapsElement.class, Locatable.class}, handler);  return proxy;  }   protected List\u0026lt;WebElement\u0026gt; proxyForListLocator(ClassLoader loader, ElementLocator locator) {  LocatingElementListHandler handler = new LocatingElementListHandler(locator);  List proxy = (List)Proxy.newProxyInstance(loader, new Class[]{List.class}, handler);  return proxy;  } 我们再看一下LocatingElementHandler,可以看到实际在待用PageFactory创建的元素时候 都是通过这个掉用LocatingElementHandler:\npublic class LocatingElementHandler implements InvocationHandler {  private final ElementLocator locator;   public LocatingElementHandler(ElementLocator locator) {  this.locator = locator;  }   public Object invoke(Object object, Method method, Object[] objects) throws Throwable {  WebElement element;  try {  element = this.locator.findElement();  } catch (NoSuchElementException var7) {  if(\u0026#34;toString\u0026#34;.equals(method.getName())) {  return \u0026#34;Proxy element for: \u0026#34; + this.locator.toString();  }   throw var7;  }   if(\u0026#34;getWrappedElement\u0026#34;.equals(method.getName())) {  return element;  } else {  try {  return method.invoke(element, objects);  } catch (InvocationTargetException var6) {  throw var6.getCause();  }  }  } } 以上Selenium PageFactory大致的实现，从过程来看： PageFaction-\u0026gt; initElements-\u0026gt; proxyFields\nPage Factory 有什么好处 个人理解的好处:\n 可以通过修改InvocationHandler里面的处理,比如 element = this.locator.findElement(); 如果都使用wait().util的方式,这样可以使所有查找的元素更加稳定 使用了proxy的方式,在实例化WebElement的时候，实际上不管WebElement存在不存在都可以创建 而实际findElement都会延迟到真的调用这个元素时执行,这带来一个好处就是如果WebElement的实例创建后 页面DOM刷新后,需要重新查找WebElement,否则可能抛出StaleElementReferenceException,而Proxy之后每次都会自动 查找,这样就减少了代码处理 工厂的设计模式同时也带了了灵活程度,在创建页面或者页面元素的时候,可以开始添加统一的前置或者后置的处理  但是可惜的是Selenium并没有提供开发的接口来让用户定制,所以如果自己定制PageFactory模式,则需要自己去实现Selenium这 一套方法,同时加入自己特殊的实现\n","date":"September 24, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2015-09-24-page-factory/","title":"Page Factory in Selenium"},{"categories":["Automation","Java"],"contents":"如果需要定制TestNG的测试报告,可以先想一下首先需要什么的数据,其实最简单的数据就是测试用例成功失败的数据, 那么实际上TestNG提供了ITestListener的接口可以让你获取这些测试数据. 同时IReporter 接口可以让用户在调用最后自己生成测试报告.\n所以其实只要用一个类实现ITestListener,IReporter就可以了.\nITestListener,IReporter实现 一下是我一个最简单的实现, 实际上TestNG开放出来的这些监听器,主要是让你可以获取TestNG 测试容器中运行测试的数据,上下文. 关于代码里面的ITestResult, xmlSuites,suites 可以自行查找\npublic class TestNGSimpleReport implements ITestListener, IReporter {  private List\u0026lt;String\u0026gt; testPassed = Lists.newArrayList();  private List\u0026lt;String\u0026gt; testFailed = Lists.newArrayList();  private List\u0026lt;String\u0026gt; testSkipped = Lists.newArrayList();   @Override  public void generateReport(List\u0026lt;XmlSuite\u0026gt; xmlSuites, List\u0026lt;ISuite\u0026gt; suites,  String outputDirectory) {  System.out.println(\u0026#34;Passed Case: \u0026#34; + testPassed.size());  System.out.println(\u0026#34;testFailed Case: \u0026#34; + testFailed.size());  System.out.println(\u0026#34;testSkipped Case: \u0026#34; + testSkipped.size());   for (String passed : testPassed) {  System.out.println(\u0026#34;passed case:\u0026#34; + passed);  }  for (String passed : testFailed) {  System.out.println(\u0026#34;failed case:\u0026#34; + passed);  }   for (String passed : testSkipped) {  System.out.println(\u0026#34;skipped case:\u0026#34; + passed);  }   }   @Override  public void onTestStart(ITestResult result) {   }   @Override  public void onTestSuccess(ITestResult result) {  testPassed.add(result.getMethod().getMethodName());  }   @Override  public void onTestFailure(ITestResult result) {  testFailed.add(result.getMethod().getMethodName());  }   @Override  public void onTestSkipped(ITestResult result) {  testSkipped.add(result.getMethod().getMethodName());  }   @Override  public void onTestFailedButWithinSuccessPercentage(ITestResult result) {   }   @Override  public void onStart(ITestContext context) {   }   @Override  public void onFinish(ITestContext context) {   } } 编写TestNG的测试 public class TestNGTest {   @Test  public void test_pass(){  System.out.println(\u0026#34;passed_case\u0026#34;);  }   @Test  public void test_failed(){  Assert.assertTrue(false);  }   @Test  public void test_pass_2(){  System.out.println(\u0026#34;passed_case_2\u0026#34;);  } } 将监听器放入Testng.xml文件  \u0026lt;suite name=\u0026#34;SimpleReport\u0026#34;\u0026gt;  \u0026lt;listeners\u0026gt;  \u0026lt;listener class-name=\u0026#34;com.hedwig.testng.TestNGSimpleReport\u0026#34;/\u0026gt;  \u0026lt;/listeners\u0026gt;  \u0026lt;test verbose=\u0026#34;1\u0026#34; name=\u0026#34;simple test\u0026#34; \u0026gt;  \u0026lt;classes\u0026gt;  \u0026lt;class name=\u0026#34;com.hedwig.testng.TestNGTest\u0026#34;/\u0026gt;  \u0026lt;/classes\u0026gt;  \u0026lt;/test\u0026gt;   \u0026lt;/suite\u0026gt; 运行Testng.xml文件,查看结果 结果如下,是不是很简单? 如果想做的cool一点,可以将这些数据写到一个html模版,写入文件就可以了\n=============================================== SimpleReport Total tests run: 3, Failures: 1, Skips: 0 ===============================================  Passed Case: 2 testFailed Case: 1 testSkipped Case: 0 passed case:test_pass passed case:test_pass_2 failed case:test_failed ","date":"September 24, 2015","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/automation/2015-09-24-testng-simple-report/","title":"TestNG 报告定制最简单的原理"},{"categories":null,"contents":"引子 作为全职测试大概有8年时间了，总体来说整个这8年不是一个愉快的过程。其中辛苦可能没有做过测试的人未必能理解。对于一个职场人来说不够愉快的点个人认为大概可能是以下几点：\n 成就感不多 个人技术积累不多 可供选择的机会相对较少，转型难度大  问题分析 1. 成就感不多 1.1.决定产品好坏的不是测试 大体可以罗列一下一个好的产品的几个要素：\n 解决了其他人没有解决的重要问题 易用，好用 扩展性好，定制能力强 稳定，bug少 性能出色 交付快，成本低  个人认为以上几点中测试几乎都无法起到决定因素。测试人可能看到某些新的需求，但是很难从更高层面上来看待产品；可用性上面同样也是一样的问题，可以提出优化的点，但是可能只是点到为止了；扩展性，定制能力，基本上看架构设计和开发的质量；至于稳定，bug少，性能好这个也要看团队了，大体上个人认为还是开发权重高；交付快，成本低，个人认为这块测试有一些权重，而且我认为测试需要投入更多的东西在这个层面\n 1.2. 测试人缺少作品，在公司战略里面地位不突出 作为软件行业研发部门的人来说，大体可以认为都是匠人，匠人最重要的是什么？就是作品，那么软件测试人的作品是什么？貌似你做的产品和你关系不大，你几乎没有贡献一行代码；你提出了多少实现了的需求呢？貌似也不多吧，有人说有，那不错，但是站在更高层面上看，你的新需求只是一个点，产品是讲战略的，你和产品战略其实还很远，你当然不服气说，那开发不也就是按照需求开发代码吗，但是有时候有这么一个问题会问开发，这个你能做吗？如果回答是不能，可能暂时就不做了，但是如果问测试，这个你能测吗，如果回答是不能，产品一样做，一样发布; 没有作品，那么在公司产品战略里面一定是低的，公司制定产品战略规划，测试其实是没有任何话语权的。没有战略位置，那么测试地位是一定是不高的，所以影响力相对一定低的，那么薪资一定会相对低的，所以成就感自然会少点\n 1.3. 被人认可的机会少 和开发比较起来，花费同样的精力，测试得到的认可会少点；测试一般是不出事的时候没人知道，出事了才知道；所以得到负面的露脸机会要来的多一点，自然认可的机会就少一点。在大公司里面如果需要outstanding，你需要有额外的看得见的东西，但是测试发现bug不是就是你工作的正常范围吗？\n 1.4. 被放大了的责任范围，造成测试人能力不足问题被放大 测试的负面消息为什么会机会大呢？一个产品出现问题，第一个想到的就是测试，即使没有关系但是根本无法脱身，哪怕是需求不对，还是会有人问为什么测试没有质疑；哪怕开发修改了一些代码，但是在讨论范围的时候从来没有提起过，出问题时测试还是认为是第一责任人；测试的责任范围被扩的很大，大到大体上超过了很多测试人的能力范围了。\n 2. 技术积累不够 2.1.大部分情况下测试训练的不是熟练技术，而是熟练业务 日常工作当中，大部分测试熟悉的还是业务，而不是技术实现的细节；但是当你换了工作你以前熟悉的业务也就不能算你这家公司的积累了\n 2.2. 锻炼技术的机会少 大部分测试其实很难有机会写工业级的代码，即使你写自动化测试，其实很多什么更多的堆代码；很少做过好好的设计，或者使用一些设计模式；也很少会用算法；同样更加不太可能深入了解那些开源框架的原理；测试一直都是忙于解决那些重要而且紧急的事情，却很少有时间处理那些重要但不紧急的事情，这个一个硬伤。\n 2.3. 开发有design pattern，测试有 Testing Pattern吗？ 2.4. 测试接触面比较广，似乎全部有点懂，但是又不太懂，真要解决难题时，测试可能有用的只有理念了，理念是什么呢，那就是流程，哈哈，自嘲一个，可是什么样的流程呢，流程每一步解决什么问题，测试人都清楚吗？技术积累需要专的，至少有一到两个点是专的，否则谈什么积累 反思为什么技术积累不够的时候，我更加相信测试的责任范围被放大了，为何？一个天天挣扎在对公司重要而且紧急的任务上面，同时认为决定了公司产品质量的职位，居然可能是研发部门平均薪资水平最低的职位，似乎这个结论是不是完全不make sense? 如果领导一直认为质量问题是测试的话，我觉的如果这样反过来想想的话，可能觉得问题不一定是测试了。\n3. 机会不多，转型困难 其实以上两点分析，自然会造成第三点，积累不够，经常有负面新闻的人，自然机会不多；没有一个突出特点的人，转型自然也困难，往哪里转呢？似乎都可以做做，似乎又都不能做\u0026hellip;\u0026hellip;\n改进和实施 以上分析了造成测试不愉快的几个原因，以下就想想如何解决这些，未必能解决什么但是想还是要想的：\n1. 积累自己的产品  测试需要有自己的通用代码库，自己的作品，软件业的我相信还是匠人的世界，所以有作品和没有作品就表示你是匠人还不是，所以我自己一定要想想写点通用的测试代码；我常常想到像工厂流水线制造产品的时候，其实他们面对的问题和测试遇到的问题是一样的，工厂可以购买通用机器设备来加快生产效率，同时也有自己构建工具来做，那么测试也可以去构建自己的工具来加快交付，整个交付其实就像工厂在大规模生产。 构建测试的工具产品去加快交付！ 提高自身在交付中的地位，通过自动化测试，持续集成的实施，去加快交付； 需要提炼Testing Pattern  2. 更深入的学习  深入学习1-2门语言，以及一个数据库 熟练使用Linux，常用服务器如Apache，tomcat，jboss  3. 更多的将测试的观点表达  不停的讲，质量光靠测试是不够的，需要团队的合作；不停的提醒团队，产品是给客户的，不是个测试测的；要站在更高的层面看产品，而不是通过测试就表示任务完成了 不停的去想如何改进团队效率，如何让需求设计到测试用例的设计，执行更有效率；我相信这里有很多事情可以做，如果去更好效率的做端到端的交付，一定需要更好的产品，而不是什么quality center，rational 。。。。。。  ","date":"September 24, 2013","image":"https://qdriven.github.io/images/thoughts/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_623608_650x0_resize_q90_box.jpg","permalink":"/blog/qa-thoughts/2013-09-24-thoughts_on_testing/","title":"关于测试职业疑惑的一点想法"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/about/","title":"About The Author"},{"categories":null,"contents":"Nerver late than never.\n","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/contact/","title":"Let's, Talk About You"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/privacy-policy/","title":"Privacy Policy"},{"categories":null,"contents":"","date":"January 1, 1","image":"https://qdriven.github.io/images/author_hu37ae56563c66f39bdbf8622184166817_4018496_650x0_resize_box_3.png","permalink":"/search/","title":"Search Result"}]